// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Attribute() AttributeResolver
	Implementation() ImplementationResolver
	ImplementationRevision() ImplementationRevisionResolver
	Interface() InterfaceResolver
	InterfaceGroup() InterfaceGroupResolver
	Query() QueryResolver
	RepoMetadata() RepoMetadataResolver
	Type() TypeResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Attribute struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	AttributeRevision struct {
		Metadata  func(childComplexity int) int
		Revision  func(childComplexity int) int
		Signature func(childComplexity int) int
		Spec      func(childComplexity int) int
	}

	AttributeSpec struct {
		AdditionalRefs func(childComplexity int) int
	}

	GenericMetadata struct {
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	Implementation struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	ImplementationAction struct {
		Args            func(childComplexity int) int
		RunnerInterface func(childComplexity int) int
	}

	ImplementationAdditionalInput struct {
		TypeInstances func(childComplexity int) int
	}

	ImplementationAdditionalOutput struct {
		TypeInstances func(childComplexity int) int
	}

	ImplementationImport struct {
		Alias              func(childComplexity int) int
		AppVersion         func(childComplexity int) int
		InterfaceGroupPath func(childComplexity int) int
		Methods            func(childComplexity int) int
	}

	ImplementationImportMethod struct {
		Name     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	ImplementationMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	ImplementationRequirement struct {
		AllOf  func(childComplexity int) int
		AnyOf  func(childComplexity int) int
		OneOf  func(childComplexity int) int
		Prefix func(childComplexity int) int
	}

	ImplementationRequirementItem struct {
		Alias            func(childComplexity int) int
		TypeRef          func(childComplexity int) int
		ValueConstraints func(childComplexity int) int
	}

	ImplementationRevision struct {
		Interfaces func(childComplexity int) int
		Metadata   func(childComplexity int) int
		Revision   func(childComplexity int) int
		Signature  func(childComplexity int) int
		Spec       func(childComplexity int) int
	}

	ImplementationSpec struct {
		Action                      func(childComplexity int) int
		AdditionalInput             func(childComplexity int) int
		AdditionalOutput            func(childComplexity int) int
		AppVersion                  func(childComplexity int) int
		Implements                  func(childComplexity int) int
		Imports                     func(childComplexity int) int
		OutputTypeInstanceRelations func(childComplexity int) int
		Requires                    func(childComplexity int) int
	}

	InputParameters struct {
		JSONSchema func(childComplexity int) int
	}

	InputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
		Verbs   func(childComplexity int) int
	}

	Interface struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	InterfaceGroup struct {
		Interfaces func(childComplexity int, filter *InterfaceFilter) int
		Metadata   func(childComplexity int) int
		Signature  func(childComplexity int) int
	}

	InterfaceInput struct {
		Parameters    func(childComplexity int) int
		TypeInstances func(childComplexity int) int
	}

	InterfaceOutput struct {
		TypeInstances func(childComplexity int) int
	}

	InterfaceReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	InterfaceRevision struct {
		ImplementationRevisions func(childComplexity int, filter *ImplementationRevisionFilter) int
		Metadata                func(childComplexity int) int
		Revision                func(childComplexity int) int
		Signature               func(childComplexity int) int
		Spec                    func(childComplexity int) int
	}

	InterfaceSpec struct {
		Input  func(childComplexity int) int
		Output func(childComplexity int) int
	}

	LatestSemVerTaggingStrategy struct {
		PointsTo func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
		URL   func(childComplexity int) int
	}

	OutputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
	}

	Query struct {
		Attribute       func(childComplexity int, path string) int
		Attributes      func(childComplexity int, filter *AttributeFilter) int
		Implementation  func(childComplexity int, path string) int
		Implementations func(childComplexity int, filter *ImplementationFilter) int
		Interface       func(childComplexity int, path string) int
		InterfaceGroup  func(childComplexity int, path string) int
		InterfaceGroups func(childComplexity int, filter *InterfaceGroupFilter) int
		Interfaces      func(childComplexity int, filter *InterfaceFilter) int
		RepoMetadata    func(childComplexity int) int
		Type            func(childComplexity int, path string) int
		Types           func(childComplexity int, filter *TypeFilter) int
	}

	RepoImplementationAppVersionConfig struct {
		SemVerTaggingStrategy func(childComplexity int) int
	}

	RepoImplementationConfig struct {
		AppVersion func(childComplexity int) int
	}

	RepoMetadata struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	RepoMetadataRevision struct {
		Metadata  func(childComplexity int) int
		Revision  func(childComplexity int) int
		Signature func(childComplexity int) int
		Spec      func(childComplexity int) int
	}

	RepoMetadataSpec struct {
		Implementation func(childComplexity int) int
		OcfVersion     func(childComplexity int) int
		OchVersion     func(childComplexity int) int
	}

	RepoOCFVersion struct {
		Default   func(childComplexity int) int
		Supported func(childComplexity int) int
	}

	SemVerTaggingStrategy struct {
		Latest func(childComplexity int) int
	}

	Signature struct {
		Och func(childComplexity int) int
	}

	Type struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	TypeInstanceRelationItem struct {
		TypeInstanceName func(childComplexity int) int
		Uses             func(childComplexity int) int
	}

	TypeMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	TypeReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	TypeRevision struct {
		Metadata  func(childComplexity int) int
		Revision  func(childComplexity int) int
		Signature func(childComplexity int) int
		Spec      func(childComplexity int) int
	}

	TypeSpec struct {
		AdditionalRefs func(childComplexity int) int
		JSONSchema     func(childComplexity int) int
	}
}

type AttributeResolver interface {
	Revision(ctx context.Context, obj *Attribute, revision string) (*AttributeRevision, error)
}
type ImplementationResolver interface {
	Revision(ctx context.Context, obj *Implementation, revision string) (*ImplementationRevision, error)
}
type ImplementationRevisionResolver interface {
	Interfaces(ctx context.Context, obj *ImplementationRevision) ([]*Interface, error)
}
type InterfaceResolver interface {
	Revision(ctx context.Context, obj *Interface, revision string) (*InterfaceRevision, error)
}
type InterfaceGroupResolver interface {
	Interfaces(ctx context.Context, obj *InterfaceGroup, filter *InterfaceFilter) ([]*Interface, error)
}
type QueryResolver interface {
	RepoMetadata(ctx context.Context) (*RepoMetadata, error)
	InterfaceGroups(ctx context.Context, filter *InterfaceGroupFilter) ([]*InterfaceGroup, error)
	InterfaceGroup(ctx context.Context, path string) (*InterfaceGroup, error)
	Interfaces(ctx context.Context, filter *InterfaceFilter) ([]*Interface, error)
	Interface(ctx context.Context, path string) (*Interface, error)
	Types(ctx context.Context, filter *TypeFilter) ([]*Type, error)
	Type(ctx context.Context, path string) (*Type, error)
	Implementations(ctx context.Context, filter *ImplementationFilter) ([]*Implementation, error)
	Implementation(ctx context.Context, path string) (*Implementation, error)
	Attributes(ctx context.Context, filter *AttributeFilter) ([]*Attribute, error)
	Attribute(ctx context.Context, path string) (*Attribute, error)
}
type RepoMetadataResolver interface {
	Revision(ctx context.Context, obj *RepoMetadata, revision string) (*RepoMetadataRevision, error)
}
type TypeResolver interface {
	Revision(ctx context.Context, obj *Type, revision string) (*TypeRevision, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Attribute.latestRevision":
		if e.complexity.Attribute.LatestRevision == nil {
			break
		}

		return e.complexity.Attribute.LatestRevision(childComplexity), true

	case "Attribute.name":
		if e.complexity.Attribute.Name == nil {
			break
		}

		return e.complexity.Attribute.Name(childComplexity), true

	case "Attribute.path":
		if e.complexity.Attribute.Path == nil {
			break
		}

		return e.complexity.Attribute.Path(childComplexity), true

	case "Attribute.prefix":
		if e.complexity.Attribute.Prefix == nil {
			break
		}

		return e.complexity.Attribute.Prefix(childComplexity), true

	case "Attribute.revision":
		if e.complexity.Attribute.Revision == nil {
			break
		}

		args, err := ec.field_Attribute_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Attribute.Revision(childComplexity, args["revision"].(string)), true

	case "Attribute.revisions":
		if e.complexity.Attribute.Revisions == nil {
			break
		}

		return e.complexity.Attribute.Revisions(childComplexity), true

	case "AttributeRevision.metadata":
		if e.complexity.AttributeRevision.Metadata == nil {
			break
		}

		return e.complexity.AttributeRevision.Metadata(childComplexity), true

	case "AttributeRevision.revision":
		if e.complexity.AttributeRevision.Revision == nil {
			break
		}

		return e.complexity.AttributeRevision.Revision(childComplexity), true

	case "AttributeRevision.signature":
		if e.complexity.AttributeRevision.Signature == nil {
			break
		}

		return e.complexity.AttributeRevision.Signature(childComplexity), true

	case "AttributeRevision.spec":
		if e.complexity.AttributeRevision.Spec == nil {
			break
		}

		return e.complexity.AttributeRevision.Spec(childComplexity), true

	case "AttributeSpec.additionalRefs":
		if e.complexity.AttributeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.AttributeSpec.AdditionalRefs(childComplexity), true

	case "GenericMetadata.description":
		if e.complexity.GenericMetadata.Description == nil {
			break
		}

		return e.complexity.GenericMetadata.Description(childComplexity), true

	case "GenericMetadata.displayName":
		if e.complexity.GenericMetadata.DisplayName == nil {
			break
		}

		return e.complexity.GenericMetadata.DisplayName(childComplexity), true

	case "GenericMetadata.documentationURL":
		if e.complexity.GenericMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.GenericMetadata.DocumentationURL(childComplexity), true

	case "GenericMetadata.iconURL":
		if e.complexity.GenericMetadata.IconURL == nil {
			break
		}

		return e.complexity.GenericMetadata.IconURL(childComplexity), true

	case "GenericMetadata.maintainers":
		if e.complexity.GenericMetadata.Maintainers == nil {
			break
		}

		return e.complexity.GenericMetadata.Maintainers(childComplexity), true

	case "GenericMetadata.name":
		if e.complexity.GenericMetadata.Name == nil {
			break
		}

		return e.complexity.GenericMetadata.Name(childComplexity), true

	case "GenericMetadata.path":
		if e.complexity.GenericMetadata.Path == nil {
			break
		}

		return e.complexity.GenericMetadata.Path(childComplexity), true

	case "GenericMetadata.prefix":
		if e.complexity.GenericMetadata.Prefix == nil {
			break
		}

		return e.complexity.GenericMetadata.Prefix(childComplexity), true

	case "GenericMetadata.supportURL":
		if e.complexity.GenericMetadata.SupportURL == nil {
			break
		}

		return e.complexity.GenericMetadata.SupportURL(childComplexity), true

	case "Implementation.latestRevision":
		if e.complexity.Implementation.LatestRevision == nil {
			break
		}

		return e.complexity.Implementation.LatestRevision(childComplexity), true

	case "Implementation.name":
		if e.complexity.Implementation.Name == nil {
			break
		}

		return e.complexity.Implementation.Name(childComplexity), true

	case "Implementation.path":
		if e.complexity.Implementation.Path == nil {
			break
		}

		return e.complexity.Implementation.Path(childComplexity), true

	case "Implementation.prefix":
		if e.complexity.Implementation.Prefix == nil {
			break
		}

		return e.complexity.Implementation.Prefix(childComplexity), true

	case "Implementation.revision":
		if e.complexity.Implementation.Revision == nil {
			break
		}

		args, err := ec.field_Implementation_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Implementation.Revision(childComplexity, args["revision"].(string)), true

	case "Implementation.revisions":
		if e.complexity.Implementation.Revisions == nil {
			break
		}

		return e.complexity.Implementation.Revisions(childComplexity), true

	case "ImplementationAction.args":
		if e.complexity.ImplementationAction.Args == nil {
			break
		}

		return e.complexity.ImplementationAction.Args(childComplexity), true

	case "ImplementationAction.runnerInterface":
		if e.complexity.ImplementationAction.RunnerInterface == nil {
			break
		}

		return e.complexity.ImplementationAction.RunnerInterface(childComplexity), true

	case "ImplementationAdditionalInput.typeInstances":
		if e.complexity.ImplementationAdditionalInput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInput.TypeInstances(childComplexity), true

	case "ImplementationAdditionalOutput.typeInstances":
		if e.complexity.ImplementationAdditionalOutput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalOutput.TypeInstances(childComplexity), true

	case "ImplementationImport.alias":
		if e.complexity.ImplementationImport.Alias == nil {
			break
		}

		return e.complexity.ImplementationImport.Alias(childComplexity), true

	case "ImplementationImport.appVersion":
		if e.complexity.ImplementationImport.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationImport.AppVersion(childComplexity), true

	case "ImplementationImport.interfaceGroupPath":
		if e.complexity.ImplementationImport.InterfaceGroupPath == nil {
			break
		}

		return e.complexity.ImplementationImport.InterfaceGroupPath(childComplexity), true

	case "ImplementationImport.methods":
		if e.complexity.ImplementationImport.Methods == nil {
			break
		}

		return e.complexity.ImplementationImport.Methods(childComplexity), true

	case "ImplementationImportMethod.name":
		if e.complexity.ImplementationImportMethod.Name == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Name(childComplexity), true

	case "ImplementationImportMethod.revision":
		if e.complexity.ImplementationImportMethod.Revision == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Revision(childComplexity), true

	case "ImplementationMetadata.attributes":
		if e.complexity.ImplementationMetadata.Attributes == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Attributes(childComplexity), true

	case "ImplementationMetadata.description":
		if e.complexity.ImplementationMetadata.Description == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Description(childComplexity), true

	case "ImplementationMetadata.displayName":
		if e.complexity.ImplementationMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DisplayName(childComplexity), true

	case "ImplementationMetadata.documentationURL":
		if e.complexity.ImplementationMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DocumentationURL(childComplexity), true

	case "ImplementationMetadata.iconURL":
		if e.complexity.ImplementationMetadata.IconURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.IconURL(childComplexity), true

	case "ImplementationMetadata.maintainers":
		if e.complexity.ImplementationMetadata.Maintainers == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Maintainers(childComplexity), true

	case "ImplementationMetadata.name":
		if e.complexity.ImplementationMetadata.Name == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Name(childComplexity), true

	case "ImplementationMetadata.path":
		if e.complexity.ImplementationMetadata.Path == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Path(childComplexity), true

	case "ImplementationMetadata.prefix":
		if e.complexity.ImplementationMetadata.Prefix == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Prefix(childComplexity), true

	case "ImplementationMetadata.supportURL":
		if e.complexity.ImplementationMetadata.SupportURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.SupportURL(childComplexity), true

	case "ImplementationRequirement.allOf":
		if e.complexity.ImplementationRequirement.AllOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AllOf(childComplexity), true

	case "ImplementationRequirement.anyOf":
		if e.complexity.ImplementationRequirement.AnyOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AnyOf(childComplexity), true

	case "ImplementationRequirement.oneOf":
		if e.complexity.ImplementationRequirement.OneOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.OneOf(childComplexity), true

	case "ImplementationRequirement.prefix":
		if e.complexity.ImplementationRequirement.Prefix == nil {
			break
		}

		return e.complexity.ImplementationRequirement.Prefix(childComplexity), true

	case "ImplementationRequirementItem.alias":
		if e.complexity.ImplementationRequirementItem.Alias == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.Alias(childComplexity), true

	case "ImplementationRequirementItem.typeRef":
		if e.complexity.ImplementationRequirementItem.TypeRef == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.TypeRef(childComplexity), true

	case "ImplementationRequirementItem.valueConstraints":
		if e.complexity.ImplementationRequirementItem.ValueConstraints == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.ValueConstraints(childComplexity), true

	case "ImplementationRevision.interfaces":
		if e.complexity.ImplementationRevision.Interfaces == nil {
			break
		}

		return e.complexity.ImplementationRevision.Interfaces(childComplexity), true

	case "ImplementationRevision.metadata":
		if e.complexity.ImplementationRevision.Metadata == nil {
			break
		}

		return e.complexity.ImplementationRevision.Metadata(childComplexity), true

	case "ImplementationRevision.revision":
		if e.complexity.ImplementationRevision.Revision == nil {
			break
		}

		return e.complexity.ImplementationRevision.Revision(childComplexity), true

	case "ImplementationRevision.signature":
		if e.complexity.ImplementationRevision.Signature == nil {
			break
		}

		return e.complexity.ImplementationRevision.Signature(childComplexity), true

	case "ImplementationRevision.spec":
		if e.complexity.ImplementationRevision.Spec == nil {
			break
		}

		return e.complexity.ImplementationRevision.Spec(childComplexity), true

	case "ImplementationSpec.action":
		if e.complexity.ImplementationSpec.Action == nil {
			break
		}

		return e.complexity.ImplementationSpec.Action(childComplexity), true

	case "ImplementationSpec.additionalInput":
		if e.complexity.ImplementationSpec.AdditionalInput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalInput(childComplexity), true

	case "ImplementationSpec.additionalOutput":
		if e.complexity.ImplementationSpec.AdditionalOutput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalOutput(childComplexity), true

	case "ImplementationSpec.appVersion":
		if e.complexity.ImplementationSpec.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationSpec.AppVersion(childComplexity), true

	case "ImplementationSpec.implements":
		if e.complexity.ImplementationSpec.Implements == nil {
			break
		}

		return e.complexity.ImplementationSpec.Implements(childComplexity), true

	case "ImplementationSpec.imports":
		if e.complexity.ImplementationSpec.Imports == nil {
			break
		}

		return e.complexity.ImplementationSpec.Imports(childComplexity), true

	case "ImplementationSpec.outputTypeInstanceRelations":
		if e.complexity.ImplementationSpec.OutputTypeInstanceRelations == nil {
			break
		}

		return e.complexity.ImplementationSpec.OutputTypeInstanceRelations(childComplexity), true

	case "ImplementationSpec.requires":
		if e.complexity.ImplementationSpec.Requires == nil {
			break
		}

		return e.complexity.ImplementationSpec.Requires(childComplexity), true

	case "InputParameters.jsonSchema":
		if e.complexity.InputParameters.JSONSchema == nil {
			break
		}

		return e.complexity.InputParameters.JSONSchema(childComplexity), true

	case "InputTypeInstance.name":
		if e.complexity.InputTypeInstance.Name == nil {
			break
		}

		return e.complexity.InputTypeInstance.Name(childComplexity), true

	case "InputTypeInstance.typeRef":
		if e.complexity.InputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.InputTypeInstance.TypeRef(childComplexity), true

	case "InputTypeInstance.verbs":
		if e.complexity.InputTypeInstance.Verbs == nil {
			break
		}

		return e.complexity.InputTypeInstance.Verbs(childComplexity), true

	case "Interface.latestRevision":
		if e.complexity.Interface.LatestRevision == nil {
			break
		}

		return e.complexity.Interface.LatestRevision(childComplexity), true

	case "Interface.name":
		if e.complexity.Interface.Name == nil {
			break
		}

		return e.complexity.Interface.Name(childComplexity), true

	case "Interface.path":
		if e.complexity.Interface.Path == nil {
			break
		}

		return e.complexity.Interface.Path(childComplexity), true

	case "Interface.prefix":
		if e.complexity.Interface.Prefix == nil {
			break
		}

		return e.complexity.Interface.Prefix(childComplexity), true

	case "Interface.revision":
		if e.complexity.Interface.Revision == nil {
			break
		}

		args, err := ec.field_Interface_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Interface.Revision(childComplexity, args["revision"].(string)), true

	case "Interface.revisions":
		if e.complexity.Interface.Revisions == nil {
			break
		}

		return e.complexity.Interface.Revisions(childComplexity), true

	case "InterfaceGroup.interfaces":
		if e.complexity.InterfaceGroup.Interfaces == nil {
			break
		}

		args, err := ec.field_InterfaceGroup_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfaceGroup.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "InterfaceGroup.metadata":
		if e.complexity.InterfaceGroup.Metadata == nil {
			break
		}

		return e.complexity.InterfaceGroup.Metadata(childComplexity), true

	case "InterfaceGroup.signature":
		if e.complexity.InterfaceGroup.Signature == nil {
			break
		}

		return e.complexity.InterfaceGroup.Signature(childComplexity), true

	case "InterfaceInput.parameters":
		if e.complexity.InterfaceInput.Parameters == nil {
			break
		}

		return e.complexity.InterfaceInput.Parameters(childComplexity), true

	case "InterfaceInput.typeInstances":
		if e.complexity.InterfaceInput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceInput.TypeInstances(childComplexity), true

	case "InterfaceOutput.typeInstances":
		if e.complexity.InterfaceOutput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceOutput.TypeInstances(childComplexity), true

	case "InterfaceReference.path":
		if e.complexity.InterfaceReference.Path == nil {
			break
		}

		return e.complexity.InterfaceReference.Path(childComplexity), true

	case "InterfaceReference.revision":
		if e.complexity.InterfaceReference.Revision == nil {
			break
		}

		return e.complexity.InterfaceReference.Revision(childComplexity), true

	case "InterfaceRevision.implementationRevisions":
		if e.complexity.InterfaceRevision.ImplementationRevisions == nil {
			break
		}

		args, err := ec.field_InterfaceRevision_implementationRevisions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfaceRevision.ImplementationRevisions(childComplexity, args["filter"].(*ImplementationRevisionFilter)), true

	case "InterfaceRevision.metadata":
		if e.complexity.InterfaceRevision.Metadata == nil {
			break
		}

		return e.complexity.InterfaceRevision.Metadata(childComplexity), true

	case "InterfaceRevision.revision":
		if e.complexity.InterfaceRevision.Revision == nil {
			break
		}

		return e.complexity.InterfaceRevision.Revision(childComplexity), true

	case "InterfaceRevision.signature":
		if e.complexity.InterfaceRevision.Signature == nil {
			break
		}

		return e.complexity.InterfaceRevision.Signature(childComplexity), true

	case "InterfaceRevision.spec":
		if e.complexity.InterfaceRevision.Spec == nil {
			break
		}

		return e.complexity.InterfaceRevision.Spec(childComplexity), true

	case "InterfaceSpec.input":
		if e.complexity.InterfaceSpec.Input == nil {
			break
		}

		return e.complexity.InterfaceSpec.Input(childComplexity), true

	case "InterfaceSpec.output":
		if e.complexity.InterfaceSpec.Output == nil {
			break
		}

		return e.complexity.InterfaceSpec.Output(childComplexity), true

	case "LatestSemVerTaggingStrategy.pointsTo":
		if e.complexity.LatestSemVerTaggingStrategy.PointsTo == nil {
			break
		}

		return e.complexity.LatestSemVerTaggingStrategy.PointsTo(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Maintainer.url":
		if e.complexity.Maintainer.URL == nil {
			break
		}

		return e.complexity.Maintainer.URL(childComplexity), true

	case "OutputTypeInstance.name":
		if e.complexity.OutputTypeInstance.Name == nil {
			break
		}

		return e.complexity.OutputTypeInstance.Name(childComplexity), true

	case "OutputTypeInstance.typeRef":
		if e.complexity.OutputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.OutputTypeInstance.TypeRef(childComplexity), true

	case "Query.attribute":
		if e.complexity.Query.Attribute == nil {
			break
		}

		args, err := ec.field_Query_attribute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attribute(childComplexity, args["path"].(string)), true

	case "Query.attributes":
		if e.complexity.Query.Attributes == nil {
			break
		}

		args, err := ec.field_Query_attributes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attributes(childComplexity, args["filter"].(*AttributeFilter)), true

	case "Query.implementation":
		if e.complexity.Query.Implementation == nil {
			break
		}

		args, err := ec.field_Query_implementation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementation(childComplexity, args["path"].(string)), true

	case "Query.implementations":
		if e.complexity.Query.Implementations == nil {
			break
		}

		args, err := ec.field_Query_implementations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementations(childComplexity, args["filter"].(*ImplementationFilter)), true

	case "Query.interface":
		if e.complexity.Query.Interface == nil {
			break
		}

		args, err := ec.field_Query_interface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interface(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroup":
		if e.complexity.Query.InterfaceGroup == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroup(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroups":
		if e.complexity.Query.InterfaceGroups == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroups(childComplexity, args["filter"].(*InterfaceGroupFilter)), true

	case "Query.interfaces":
		if e.complexity.Query.Interfaces == nil {
			break
		}

		args, err := ec.field_Query_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "Query.repoMetadata":
		if e.complexity.Query.RepoMetadata == nil {
			break
		}

		return e.complexity.Query.RepoMetadata(childComplexity), true

	case "Query.type":
		if e.complexity.Query.Type == nil {
			break
		}

		args, err := ec.field_Query_type_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Type(childComplexity, args["path"].(string)), true

	case "Query.types":
		if e.complexity.Query.Types == nil {
			break
		}

		args, err := ec.field_Query_types_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Types(childComplexity, args["filter"].(*TypeFilter)), true

	case "RepoImplementationAppVersionConfig.semVerTaggingStrategy":
		if e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy == nil {
			break
		}

		return e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy(childComplexity), true

	case "RepoImplementationConfig.appVersion":
		if e.complexity.RepoImplementationConfig.AppVersion == nil {
			break
		}

		return e.complexity.RepoImplementationConfig.AppVersion(childComplexity), true

	case "RepoMetadata.latestRevision":
		if e.complexity.RepoMetadata.LatestRevision == nil {
			break
		}

		return e.complexity.RepoMetadata.LatestRevision(childComplexity), true

	case "RepoMetadata.name":
		if e.complexity.RepoMetadata.Name == nil {
			break
		}

		return e.complexity.RepoMetadata.Name(childComplexity), true

	case "RepoMetadata.path":
		if e.complexity.RepoMetadata.Path == nil {
			break
		}

		return e.complexity.RepoMetadata.Path(childComplexity), true

	case "RepoMetadata.prefix":
		if e.complexity.RepoMetadata.Prefix == nil {
			break
		}

		return e.complexity.RepoMetadata.Prefix(childComplexity), true

	case "RepoMetadata.revision":
		if e.complexity.RepoMetadata.Revision == nil {
			break
		}

		args, err := ec.field_RepoMetadata_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RepoMetadata.Revision(childComplexity, args["revision"].(string)), true

	case "RepoMetadata.revisions":
		if e.complexity.RepoMetadata.Revisions == nil {
			break
		}

		return e.complexity.RepoMetadata.Revisions(childComplexity), true

	case "RepoMetadataRevision.metadata":
		if e.complexity.RepoMetadataRevision.Metadata == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Metadata(childComplexity), true

	case "RepoMetadataRevision.revision":
		if e.complexity.RepoMetadataRevision.Revision == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Revision(childComplexity), true

	case "RepoMetadataRevision.signature":
		if e.complexity.RepoMetadataRevision.Signature == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Signature(childComplexity), true

	case "RepoMetadataRevision.spec":
		if e.complexity.RepoMetadataRevision.Spec == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Spec(childComplexity), true

	case "RepoMetadataSpec.implementation":
		if e.complexity.RepoMetadataSpec.Implementation == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.Implementation(childComplexity), true

	case "RepoMetadataSpec.ocfVersion":
		if e.complexity.RepoMetadataSpec.OcfVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.OcfVersion(childComplexity), true

	case "RepoMetadataSpec.ochVersion":
		if e.complexity.RepoMetadataSpec.OchVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.OchVersion(childComplexity), true

	case "RepoOCFVersion.default":
		if e.complexity.RepoOCFVersion.Default == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Default(childComplexity), true

	case "RepoOCFVersion.supported":
		if e.complexity.RepoOCFVersion.Supported == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Supported(childComplexity), true

	case "SemVerTaggingStrategy.latest":
		if e.complexity.SemVerTaggingStrategy.Latest == nil {
			break
		}

		return e.complexity.SemVerTaggingStrategy.Latest(childComplexity), true

	case "Signature.och":
		if e.complexity.Signature.Och == nil {
			break
		}

		return e.complexity.Signature.Och(childComplexity), true

	case "Type.latestRevision":
		if e.complexity.Type.LatestRevision == nil {
			break
		}

		return e.complexity.Type.LatestRevision(childComplexity), true

	case "Type.name":
		if e.complexity.Type.Name == nil {
			break
		}

		return e.complexity.Type.Name(childComplexity), true

	case "Type.path":
		if e.complexity.Type.Path == nil {
			break
		}

		return e.complexity.Type.Path(childComplexity), true

	case "Type.prefix":
		if e.complexity.Type.Prefix == nil {
			break
		}

		return e.complexity.Type.Prefix(childComplexity), true

	case "Type.revision":
		if e.complexity.Type.Revision == nil {
			break
		}

		args, err := ec.field_Type_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Type.Revision(childComplexity, args["revision"].(string)), true

	case "Type.revisions":
		if e.complexity.Type.Revisions == nil {
			break
		}

		return e.complexity.Type.Revisions(childComplexity), true

	case "TypeInstanceRelationItem.typeInstanceName":
		if e.complexity.TypeInstanceRelationItem.TypeInstanceName == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.TypeInstanceName(childComplexity), true

	case "TypeInstanceRelationItem.uses":
		if e.complexity.TypeInstanceRelationItem.Uses == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.Uses(childComplexity), true

	case "TypeMetadata.attributes":
		if e.complexity.TypeMetadata.Attributes == nil {
			break
		}

		return e.complexity.TypeMetadata.Attributes(childComplexity), true

	case "TypeMetadata.description":
		if e.complexity.TypeMetadata.Description == nil {
			break
		}

		return e.complexity.TypeMetadata.Description(childComplexity), true

	case "TypeMetadata.displayName":
		if e.complexity.TypeMetadata.DisplayName == nil {
			break
		}

		return e.complexity.TypeMetadata.DisplayName(childComplexity), true

	case "TypeMetadata.documentationURL":
		if e.complexity.TypeMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.TypeMetadata.DocumentationURL(childComplexity), true

	case "TypeMetadata.iconURL":
		if e.complexity.TypeMetadata.IconURL == nil {
			break
		}

		return e.complexity.TypeMetadata.IconURL(childComplexity), true

	case "TypeMetadata.maintainers":
		if e.complexity.TypeMetadata.Maintainers == nil {
			break
		}

		return e.complexity.TypeMetadata.Maintainers(childComplexity), true

	case "TypeMetadata.name":
		if e.complexity.TypeMetadata.Name == nil {
			break
		}

		return e.complexity.TypeMetadata.Name(childComplexity), true

	case "TypeMetadata.path":
		if e.complexity.TypeMetadata.Path == nil {
			break
		}

		return e.complexity.TypeMetadata.Path(childComplexity), true

	case "TypeMetadata.prefix":
		if e.complexity.TypeMetadata.Prefix == nil {
			break
		}

		return e.complexity.TypeMetadata.Prefix(childComplexity), true

	case "TypeMetadata.supportURL":
		if e.complexity.TypeMetadata.SupportURL == nil {
			break
		}

		return e.complexity.TypeMetadata.SupportURL(childComplexity), true

	case "TypeReference.path":
		if e.complexity.TypeReference.Path == nil {
			break
		}

		return e.complexity.TypeReference.Path(childComplexity), true

	case "TypeReference.revision":
		if e.complexity.TypeReference.Revision == nil {
			break
		}

		return e.complexity.TypeReference.Revision(childComplexity), true

	case "TypeRevision.metadata":
		if e.complexity.TypeRevision.Metadata == nil {
			break
		}

		return e.complexity.TypeRevision.Metadata(childComplexity), true

	case "TypeRevision.revision":
		if e.complexity.TypeRevision.Revision == nil {
			break
		}

		return e.complexity.TypeRevision.Revision(childComplexity), true

	case "TypeRevision.signature":
		if e.complexity.TypeRevision.Signature == nil {
			break
		}

		return e.complexity.TypeRevision.Signature(childComplexity), true

	case "TypeRevision.spec":
		if e.complexity.TypeRevision.Spec == nil {
			break
		}

		return e.complexity.TypeRevision.Spec(childComplexity), true

	case "TypeSpec.additionalRefs":
		if e.complexity.TypeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.TypeSpec.AdditionalRefs(childComplexity), true

	case "TypeSpec.jsonSchema":
		if e.complexity.TypeSpec.JSONSchema == nil {
			break
		}

		return e.complexity.TypeSpec.JSONSchema(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: `"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Pattern of the path of a given node, e.g. cap.core.type.platform.*
"""
scalar NodePathPattern

"""
Path for the parent node, e.g. for Interface it is InterfaceGroup path.
"""
scalar NodePrefix

"""
Name of a given node. Name is immutable between different revisions of a given node.
"""
scalar NodeName

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

"""
Range of versions, e.g. "1.14.x, 1.15.0 - 1.15.3"
"""
scalar VersionRange

input InterfaceFilter {
    prefixPattern: NodePathPattern
}

input ImplementationFilter {
  prefixPattern: NodePathPattern
}

input ImplementationRevisionFilter {
  prefixPattern: NodePathPattern

  """
  If provided, Implementations are filtered by the ones that have satisfied requirements with provided TypeInstance values.
  For example, to find all Implementations that can be run on a given system, user can provide values of all existing TypeInstances.
  """
  requirementsSatisfiedBy: [TypeInstanceValue!]
  attributes: [AttributeFilterInput!]
}

input TypeInstanceValue {
    typeRef: TypeReferenceInput

    """
    Value of the available requirement. If not provided, all valueConstraints conditions are treated as satisfied.
    Currently not supported.
    """
    value: Any
}

input TypeReferenceInput {
    path: NodePath!

    """
    If not provided, latest revision for a given Type is used
    """
    revision: Version
}

input AttributeFilterInput {
    path: NodePath!
    rule: FilterRule = INCLUDE

    """
    If not provided, latest revision for a given Attribute is used
    """
    revision: Version
}

enum FilterRule {
    INCLUDE
    EXCLUDE
}

input InterfaceGroupFilter {
    prefixPattern: NodePathPattern
}

input AttributeFilter {
    prefixPattern: NodePathPattern
}

input TypeFilter {
    prefixPattern: NodePathPattern
}

type RepoMetadata {
    name: NodeName!
    prefix: NodePrefix!
    path: NodePath!

    latestRevision: RepoMetadataRevision
    revision(revision: Version!): RepoMetadataRevision
    revisions: [RepoMetadataRevision!]!
}

type RepoMetadataRevision {
    metadata: GenericMetadata!
    revision: Version!
    spec: RepoMetadataSpec!
    signature: Signature!
}

type RepoMetadataSpec {
    ochVersion: Version!
    ocfVersion: RepoOCFVersion!
    implementation: RepoImplementationConfig!
}

type RepoImplementationConfig {
    appVersion: RepoImplementationAppVersionConfig!
}

type RepoImplementationAppVersionConfig {
    semVerTaggingStrategy: SemVerTaggingStrategy!
}

type SemVerTaggingStrategy {
    latest: LatestSemVerTaggingStrategy!
}

type LatestSemVerTaggingStrategy {
    pointsTo: SemVerTaggingStrategyTags!
}

enum SemVerTaggingStrategyTags {
    STABLE, EDGE
}

type RepoOCFVersion {
    default: Version!
    supported: [Version!]!
}

type InterfaceGroup {
    metadata: GenericMetadata!
    signature: Signature!
    interfaces(filter: InterfaceFilter): [Interface!]!
}

type Interface {
    name: NodeName!
    prefix: NodePrefix!
    path: NodePath!

    latestRevision: InterfaceRevision
    revision(revision: Version!): InterfaceRevision
    revisions: [InterfaceRevision!]!
}

type InterfaceRevision {
    metadata: GenericMetadata!
    revision: Version!
    spec: InterfaceSpec!

    """
    List Implementations for a given Interface
    """
    implementationRevisions(filter: ImplementationRevisionFilter = {}): [ImplementationRevision!]!
    signature: Signature!
}

type InterfaceSpec {
    input: InterfaceInput!
    output: InterfaceOutput!
}

type InterfaceInput {
    parameters: InputParameters
    typeInstances: [InputTypeInstance]!
}

type InputParameters {
    jsonSchema: Any
}

type InterfaceOutput {
    typeInstances: [OutputTypeInstance]!
}

interface TypeInstanceFields {
    name: String!
    typeRef: TypeReference!
}

type InputTypeInstance implements TypeInstanceFields {
    name: String!
    typeRef: TypeReference!
    verbs: [TypeInstanceOperationVerb!]!
}

enum TypeInstanceOperationVerb {
    CREATE, GET, LIST, UPDATE, DELETE
}

type OutputTypeInstance implements TypeInstanceFields {
    name: String!
    typeRef: TypeReference!
}

type Type {
    name: NodeName!
    prefix: NodePrefix!
    path: NodePath!

    latestRevision: TypeRevision
    revision(revision: Version!): TypeRevision
    revisions: [TypeRevision!]!
}

type TypeRevision {
    metadata: TypeMetadata!
    revision: Version!
    spec: TypeSpec!
    signature: Signature!
}

type TypeSpec {
    additionalRefs: [NodePath!]
    jsonSchema: Any
}

type Implementation {
    name: NodeName!
    prefix: NodePrefix!
    path: NodePath!

    latestRevision: ImplementationRevision
    revision(revision: Version!): ImplementationRevision
    revisions: [ImplementationRevision!]!
}

type ImplementationRevision {
    metadata: ImplementationMetadata!
    revision: Version!
    spec: ImplementationSpec!

    interfaces: [Interface!]! # resolver based on "implements" section
    signature: Signature!
}

type ImplementationSpec {
    appVersion: VersionRange!
    implements: [InterfaceReference!]!
    requires: [ImplementationRequirement!]!
    imports: [ImplementationImport!]
    action: ImplementationAction!
    additionalInput: ImplementationAdditionalInput
    additionalOutput: ImplementationAdditionalOutput
    outputTypeInstanceRelations: [TypeInstanceRelationItem!]!
}

type ImplementationAdditionalInput {
    typeInstances: [InputTypeInstance!]!
}

type ImplementationAdditionalOutput {
    typeInstances: [OutputTypeInstance!]!
}

type TypeInstanceRelationItem {
    typeInstanceName: String!

    """
    Contains list of Type Instance names, which a given TypeInstance uses (depends on).
    If empty, a given TypeInstance doesn't have any dependencies.
    """
    uses: [String!]
}


type InterfaceReference {
    path: NodePath!
    revision: Version!
}

type ImplementationRequirement {
    prefix: NodePrefix!
    oneOf: [ImplementationRequirementItem!]!
    anyOf: [ImplementationRequirementItem!]!
    allOf: [ImplementationRequirementItem!]!
}

type ImplementationRequirementItem {
    typeRef: TypeReference!

    """
    Holds the configuration constraints for the given entry based on Type value.
    Currently not supported.
    """
    valueConstraints: Any

    """
    If provided, the TypeInstance of the Type, configured in policy, is injected to the workflow under the alias.
    """
    alias: String
}

type TypeReference {
    path: NodePath!
    revision: Version!
}

type ImplementationImport {
    interfaceGroupPath: NodePath!
    alias: String
    appVersion: VersionRange
    methods: [ImplementationImportMethod!]!
}

type ImplementationImportMethod {
    name: NodeName!

    """
    If not provided, latest revision for a given Interface is used
    """
    revision: Version
}

type ImplementationAction {
    """
    The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
    """
    runnerInterface: String!
    args: Any
}

type Attribute {
    name: NodeName!
    prefix: NodePrefix!
    path: NodePath!

    latestRevision: AttributeRevision
    revision(revision: Version!): AttributeRevision
    revisions: [AttributeRevision!]!
}

type AttributeRevision {
    metadata: GenericMetadata!
    revision: Version!
    spec: AttributeSpec!
    signature: Signature!
}

# It is defined to make sure that all metadata types have the same base fields.
# Unfortunately all Types that implement an Interface have to repeat the same fields,
# however it's the only way to do so.
interface MetadataBaseFields {
    name: NodeName!
    prefix: NodePrefix # resolver
    path: NodePath
    displayName: String
    description: String!
    maintainers: [Maintainer!]!
    documentationURL: String
    supportURL: String
    iconURL: String
}

type GenericMetadata implements MetadataBaseFields {
    name: NodeName!
    prefix: NodePrefix # resolver
    path: NodePath
    displayName: String
    description: String!
    maintainers: [Maintainer!]!
    documentationURL: String
    supportURL: String
    iconURL: String
}

type ImplementationMetadata implements MetadataBaseFields {
    name: NodeName!
    prefix: NodePrefix # resolver
    path: NodePath
    displayName: String
    description: String!
    maintainers: [Maintainer!]!
    documentationURL: String
    supportURL: String
    iconURL: String
    attributes: [AttributeRevision!]!
}

type TypeMetadata implements MetadataBaseFields {
    name: NodeName!
    prefix: NodePrefix # resolver
    path: NodePath
    displayName: String
    description: String!
    maintainers: [Maintainer!]!
    documentationURL: String
    supportURL: String
    iconURL: String
    attributes: [AttributeRevision!]!
}

type Signature {
    och: String!
}

type Maintainer {
    name: String
    email: String!
    url: String
}

type AttributeSpec {
    additionalRefs: [NodePath!]!
}

type Query {
    repoMetadata: RepoMetadata

    interfaceGroups(filter: InterfaceGroupFilter): [InterfaceGroup!]!
    interfaceGroup(path: NodePath!): InterfaceGroup

    interfaces(filter: InterfaceFilter): [Interface!]!
    interface(path: NodePath!): Interface

    types(filter: TypeFilter): [Type!]!
    type(path: NodePath!): Type

    implementations(filter: ImplementationFilter): [Implementation!]!
    implementation(path: NodePath!): Implementation

    attributes(filter: AttributeFilter): [Attribute!]!
    attribute(path: NodePath!): Attribute
}

# No mutations for now, as all resources are populated with DB populator

# TODO: Prepare directive for user authorization in https://cshark.atlassian.net/browse/SV-65
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Attribute_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Implementation_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_InterfaceGroup_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_InterfaceRevision_implementationRevisions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ImplementationRevisionFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOImplementationRevisionFilter2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevisionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Interface_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attribute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attributes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AttributeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOAttributeFilter2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ImplementationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOImplementationFilter2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceGroupFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceGroupFilter2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroupFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_types_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTypeFilter2projectvoltrondevvoltronpkgochapigraphqlpublicTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_RepoMetadata_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Type_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Attribute_name(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_prefix(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_path(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Attribute_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Attribute().Revision(rctx, obj, args["revision"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revisions(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AttributeSpec)
	fc.Result = res
	return ec.marshalNAttributeSpec2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_signature(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *AttributeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_name(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_path(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_description(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_name(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_prefix(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_path(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Implementation_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Implementation().Revision(rctx, obj, args["revision"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revisions(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_runnerInterface(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunnerInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_args(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_interfaceGroupPath(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceGroupPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersionRange2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_methods(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Methods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImportMethod)
	fc.Result = res
	return ec.marshalNImplementationImportMethod2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImportMethod(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_path(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_description(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attributes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_oneOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OneOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_anyOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnyOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_allOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_typeRef(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_valueConstraints(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationMetadata)
	fc.Result = res
	return ec.marshalNImplementationMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_spec(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationSpec)
	fc.Result = res
	return ec.marshalNImplementationSpec2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_interfaces(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ImplementationRevision().Interfaces(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_signature(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionRange2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_implements(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Implements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceReference)
	fc.Result = res
	return ec.marshalNInterfaceReference2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_requires(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirement)
	fc.Result = res
	return ec.marshalNImplementationRequirement2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirement(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_imports(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Imports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImport)
	fc.Result = res
	return ec.marshalOImplementationImport2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImport(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_action(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationAction)
	fc.Result = res
	return ec.marshalNImplementationAction2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAction(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalInput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalInput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalInput2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAdditionalInput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalOutput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalOutput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalOutput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalOutput2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAdditionalOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_outputTypeInstanceRelations(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutputTypeInstanceRelations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeInstanceRelationItem)
	fc.Result = res
	return ec.marshalNTypeInstanceRelationItem2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceRelationItem(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameters_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *InputParameters) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameters",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_verbs(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verbs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]TypeInstanceOperationVerb)
	fc.Result = res
	return ec.marshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_name(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_prefix(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_path(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Interface_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Interface().Revision(rctx, obj, args["revision"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revisions(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceRevision)
	fc.Result = res
	return ec.marshalNInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_signature(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_InterfaceGroup_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.InterfaceGroup().Interfaces(rctx, obj, args["filter"].(*InterfaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_parameters(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InputParameters)
	fc.Result = res
	return ec.marshalOInputParameters2projectvoltrondevvoltronpkgochapigraphqlpublicInputParameters(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_path(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_spec(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceSpec)
	fc.Result = res
	return ec.marshalNInterfaceSpec2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_implementationRevisions(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_InterfaceRevision_implementationRevisions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplementationRevisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_signature(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_input(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Input, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceInput)
	fc.Result = res
	return ec.marshalNInterfaceInput2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceInput(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_output(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceOutput)
	fc.Result = res
	return ec.marshalNInterfaceOutput2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _LatestSemVerTaggingStrategy_pointsTo(ctx context.Context, field graphql.CollectedField, obj *LatestSemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LatestSemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointsTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SemVerTaggingStrategyTags)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategyTags2projectvoltrondevvoltronpkgochapigraphqlpublicSemVerTaggingStrategyTags(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_url(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_repoMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoMetadata(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadata)
	fc.Result = res
	return ec.marshalORepoMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InterfaceGroups(rctx, args["filter"].(*InterfaceGroupFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceGroup)
	fc.Result = res
	return ec.marshalNInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroup_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InterfaceGroup(rctx, args["path"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceGroup)
	fc.Result = res
	return ec.marshalOInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Interfaces(rctx, args["filter"].(*InterfaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interface_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Interface(rctx, args["path"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Interface)
	fc.Result = res
	return ec.marshalOInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_types(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_types_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Types(rctx, args["filter"].(*TypeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Type)
	fc.Result = res
	return ec.marshalNType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Type(rctx, args["path"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Type)
	fc.Result = res
	return ec.marshalOType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementations_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Implementations(rctx, args["filter"].(*ImplementationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Implementation)
	fc.Result = res
	return ec.marshalNImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementation_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Implementation(rctx, args["path"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Implementation)
	fc.Result = res
	return ec.marshalOImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attributes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attributes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Attributes(rctx, args["filter"].(*AttributeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Attribute)
	fc.Result = res
	return ec.marshalNAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attribute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attribute_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Attribute(rctx, args["path"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Attribute)
	fc.Result = res
	return ec.marshalOAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationAppVersionConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationAppVersionConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SemVerTaggingStrategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategy2projectvoltrondevvoltronpkgochapigraphqlpublicSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationConfig_appVersion(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationAppVersionConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationAppVersionConfig2projectvoltrondevvoltronpkgochapigraphqlpublicRepoImplementationAppVersionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_name(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_path(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_latestRevision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_RepoMetadata_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoMetadata().Revision(rctx, obj, args["revision"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revisions(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalNRepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_spec(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataSpec)
	fc.Result = res
	return ec.marshalNRepoMetadataSpec2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_signature(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_ochVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OchVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_ocfVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OcfVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoOCFVersion)
	fc.Result = res
	return ec.marshalNRepoOCFVersion2projectvoltrondevvoltronpkgochapigraphqlpublicRepoOCFVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_implementation(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Implementation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationConfig2projectvoltrondevvoltronpkgochapigraphqlpublicRepoImplementationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_default(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_supported(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SemVerTaggingStrategy_latest(ctx context.Context, field graphql.CollectedField, obj *SemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "SemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LatestSemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNLatestSemVerTaggingStrategy2projectvoltrondevvoltronpkgochapigraphqlpublicLatestSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _Signature_och(ctx context.Context, field graphql.CollectedField, obj *Signature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Signature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Och, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_name(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_prefix(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_path(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Type_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Type().Revision(rctx, obj, args["revision"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revisions(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revisions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeRevision)
	fc.Result = res
	return ec.marshalNTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_typeInstanceName(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstanceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_uses(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_name(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_path(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_description(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attributes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_path(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_revision(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeMetadata)
	fc.Result = res
	return ec.marshalNTypeMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicTypeMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeSpec)
	fc.Result = res
	return ec.marshalNTypeSpec2projectvoltrondevvoltronpkgochapigraphqlpublicTypeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_signature(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Signature)
	fc.Result = res
	return ec.marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalONodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAttributeFilter(ctx context.Context, obj interface{}) (AttributeFilter, error) {
	var it AttributeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttributeFilterInput(ctx context.Context, obj interface{}) (AttributeFilterInput, error) {
	var it AttributeFilterInput
	var asMap = obj.(map[string]interface{})

	if _, present := asMap["rule"]; !present {
		asMap["rule"] = "INCLUDE"
	}

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalOFilterRule2projectvoltrondevvoltronpkgochapigraphqlpublicFilterRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationFilter(ctx context.Context, obj interface{}) (ImplementationFilter, error) {
	var it ImplementationFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationRevisionFilter(ctx context.Context, obj interface{}) (ImplementationRevisionFilter, error) {
	var it ImplementationRevisionFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "requirementsSatisfiedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requirementsSatisfiedBy"))
			it.RequirementsSatisfiedBy, err = ec.unmarshalOTypeInstanceValue2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOAttributeFilterInput2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceFilter(ctx context.Context, obj interface{}) (InterfaceFilter, error) {
	var it InterfaceFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceGroupFilter(ctx context.Context, obj interface{}) (InterfaceGroupFilter, error) {
	var it InterfaceGroupFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeFilter(ctx context.Context, obj interface{}) (TypeFilter, error) {
	var it TypeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "prefixPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefixPattern"))
			it.PrefixPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeInstanceValue(ctx context.Context, obj interface{}) (TypeInstanceValue, error) {
	var it TypeInstanceValue
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeRef":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeRef"))
			it.TypeRef, err = ec.unmarshalOTypeReferenceInput2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeReferenceInput(ctx context.Context, obj interface{}) (TypeReferenceInput, error) {
	var it TypeReferenceInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _MetadataBaseFields(ctx context.Context, sel ast.SelectionSet, obj MetadataBaseFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case GenericMetadata:
		return ec._GenericMetadata(ctx, sel, &obj)
	case *GenericMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._GenericMetadata(ctx, sel, obj)
	case ImplementationMetadata:
		return ec._ImplementationMetadata(ctx, sel, &obj)
	case *ImplementationMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImplementationMetadata(ctx, sel, obj)
	case TypeMetadata:
		return ec._TypeMetadata(ctx, sel, &obj)
	case *TypeMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._TypeMetadata(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TypeInstanceFields(ctx context.Context, sel ast.SelectionSet, obj TypeInstanceFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case InputTypeInstance:
		return ec._InputTypeInstance(ctx, sel, &obj)
	case *InputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._InputTypeInstance(ctx, sel, obj)
	case OutputTypeInstance:
		return ec._OutputTypeInstance(ctx, sel, &obj)
	case *OutputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._OutputTypeInstance(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var attributeImplementors = []string{"Attribute"}

func (ec *executionContext) _Attribute(ctx context.Context, sel ast.SelectionSet, obj *Attribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Attribute")
		case "name":
			out.Values[i] = ec._Attribute_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Attribute_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._Attribute_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Attribute_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Attribute_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Attribute_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeRevisionImplementors = []string{"AttributeRevision"}

func (ec *executionContext) _AttributeRevision(ctx context.Context, sel ast.SelectionSet, obj *AttributeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeRevision")
		case "metadata":
			out.Values[i] = ec._AttributeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._AttributeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._AttributeRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signature":
			out.Values[i] = ec._AttributeRevision_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeSpecImplementors = []string{"AttributeSpec"}

func (ec *executionContext) _AttributeSpec(ctx context.Context, sel ast.SelectionSet, obj *AttributeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeSpec")
		case "additionalRefs":
			out.Values[i] = ec._AttributeSpec_additionalRefs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var genericMetadataImplementors = []string{"GenericMetadata", "MetadataBaseFields"}

func (ec *executionContext) _GenericMetadata(ctx context.Context, sel ast.SelectionSet, obj *GenericMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, genericMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GenericMetadata")
		case "name":
			out.Values[i] = ec._GenericMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._GenericMetadata_prefix(ctx, field, obj)
		case "path":
			out.Values[i] = ec._GenericMetadata_path(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._GenericMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GenericMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._GenericMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._GenericMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._GenericMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._GenericMetadata_iconURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImplementors = []string{"Implementation"}

func (ec *executionContext) _Implementation(ctx context.Context, sel ast.SelectionSet, obj *Implementation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Implementation")
		case "name":
			out.Values[i] = ec._Implementation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Implementation_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._Implementation_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Implementation_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Implementation_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Implementation_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationActionImplementors = []string{"ImplementationAction"}

func (ec *executionContext) _ImplementationAction(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationActionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAction")
		case "runnerInterface":
			out.Values[i] = ec._ImplementationAction_runnerInterface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec._ImplementationAction_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalInputImplementors = []string{"ImplementationAdditionalInput"}

func (ec *executionContext) _ImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalInput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalInput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalOutputImplementors = []string{"ImplementationAdditionalOutput"}

func (ec *executionContext) _ImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalOutput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportImplementors = []string{"ImplementationImport"}

func (ec *executionContext) _ImplementationImport(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImport")
		case "interfaceGroupPath":
			out.Values[i] = ec._ImplementationImport_interfaceGroupPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "alias":
			out.Values[i] = ec._ImplementationImport_alias(ctx, field, obj)
		case "appVersion":
			out.Values[i] = ec._ImplementationImport_appVersion(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._ImplementationImport_methods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportMethodImplementors = []string{"ImplementationImportMethod"}

func (ec *executionContext) _ImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImportMethod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportMethodImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImportMethod")
		case "name":
			out.Values[i] = ec._ImplementationImportMethod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._ImplementationImportMethod_revision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationMetadataImplementors = []string{"ImplementationMetadata", "MetadataBaseFields"}

func (ec *executionContext) _ImplementationMetadata(ctx context.Context, sel ast.SelectionSet, obj *ImplementationMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationMetadata")
		case "name":
			out.Values[i] = ec._ImplementationMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._ImplementationMetadata_prefix(ctx, field, obj)
		case "path":
			out.Values[i] = ec._ImplementationMetadata_path(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ImplementationMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ImplementationMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._ImplementationMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._ImplementationMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._ImplementationMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._ImplementationMetadata_iconURL(ctx, field, obj)
		case "attributes":
			out.Values[i] = ec._ImplementationMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementImplementors = []string{"ImplementationRequirement"}

func (ec *executionContext) _ImplementationRequirement(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirement")
		case "prefix":
			out.Values[i] = ec._ImplementationRequirement_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "oneOf":
			out.Values[i] = ec._ImplementationRequirement_oneOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "anyOf":
			out.Values[i] = ec._ImplementationRequirement_anyOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "allOf":
			out.Values[i] = ec._ImplementationRequirement_allOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementItemImplementors = []string{"ImplementationRequirementItem"}

func (ec *executionContext) _ImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirementItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirementItem")
		case "typeRef":
			out.Values[i] = ec._ImplementationRequirementItem_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "valueConstraints":
			out.Values[i] = ec._ImplementationRequirementItem_valueConstraints(ctx, field, obj)
		case "alias":
			out.Values[i] = ec._ImplementationRequirementItem_alias(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRevisionImplementors = []string{"ImplementationRevision"}

func (ec *executionContext) _ImplementationRevision(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRevision")
		case "metadata":
			out.Values[i] = ec._ImplementationRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._ImplementationRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ImplementationRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImplementationRevision_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "signature":
			out.Values[i] = ec._ImplementationRevision_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationSpecImplementors = []string{"ImplementationSpec"}

func (ec *executionContext) _ImplementationSpec(ctx context.Context, sel ast.SelectionSet, obj *ImplementationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationSpec")
		case "appVersion":
			out.Values[i] = ec._ImplementationSpec_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implements":
			out.Values[i] = ec._ImplementationSpec_implements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requires":
			out.Values[i] = ec._ImplementationSpec_requires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imports":
			out.Values[i] = ec._ImplementationSpec_imports(ctx, field, obj)
		case "action":
			out.Values[i] = ec._ImplementationSpec_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "additionalInput":
			out.Values[i] = ec._ImplementationSpec_additionalInput(ctx, field, obj)
		case "additionalOutput":
			out.Values[i] = ec._ImplementationSpec_additionalOutput(ctx, field, obj)
		case "outputTypeInstanceRelations":
			out.Values[i] = ec._ImplementationSpec_outputTypeInstanceRelations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputParametersImplementors = []string{"InputParameters"}

func (ec *executionContext) _InputParameters(ctx context.Context, sel ast.SelectionSet, obj *InputParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputParametersImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputParameters")
		case "jsonSchema":
			out.Values[i] = ec._InputParameters_jsonSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputTypeInstanceImplementors = []string{"InputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _InputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *InputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputTypeInstance")
		case "name":
			out.Values[i] = ec._InputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._InputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "verbs":
			out.Values[i] = ec._InputTypeInstance_verbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceImplementors = []string{"Interface"}

func (ec *executionContext) _Interface(ctx context.Context, sel ast.SelectionSet, obj *Interface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interface")
		case "name":
			out.Values[i] = ec._Interface_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Interface_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._Interface_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Interface_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Interface_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Interface_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceGroupImplementors = []string{"InterfaceGroup"}

func (ec *executionContext) _InterfaceGroup(ctx context.Context, sel ast.SelectionSet, obj *InterfaceGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceGroup")
		case "metadata":
			out.Values[i] = ec._InterfaceGroup_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "signature":
			out.Values[i] = ec._InterfaceGroup_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InterfaceGroup_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceInputImplementors = []string{"InterfaceInput"}

func (ec *executionContext) _InterfaceInput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceInput")
		case "parameters":
			out.Values[i] = ec._InterfaceInput_parameters(ctx, field, obj)
		case "typeInstances":
			out.Values[i] = ec._InterfaceInput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceOutputImplementors = []string{"InterfaceOutput"}

func (ec *executionContext) _InterfaceOutput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceOutput")
		case "typeInstances":
			out.Values[i] = ec._InterfaceOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceReferenceImplementors = []string{"InterfaceReference"}

func (ec *executionContext) _InterfaceReference(ctx context.Context, sel ast.SelectionSet, obj *InterfaceReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceReference")
		case "path":
			out.Values[i] = ec._InterfaceReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._InterfaceReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceRevisionImplementors = []string{"InterfaceRevision"}

func (ec *executionContext) _InterfaceRevision(ctx context.Context, sel ast.SelectionSet, obj *InterfaceRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceRevision")
		case "metadata":
			out.Values[i] = ec._InterfaceRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._InterfaceRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._InterfaceRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementationRevisions":
			out.Values[i] = ec._InterfaceRevision_implementationRevisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signature":
			out.Values[i] = ec._InterfaceRevision_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceSpecImplementors = []string{"InterfaceSpec"}

func (ec *executionContext) _InterfaceSpec(ctx context.Context, sel ast.SelectionSet, obj *InterfaceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceSpec")
		case "input":
			out.Values[i] = ec._InterfaceSpec_input(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "output":
			out.Values[i] = ec._InterfaceSpec_output(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var latestSemVerTaggingStrategyImplementors = []string{"LatestSemVerTaggingStrategy"}

func (ec *executionContext) _LatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *LatestSemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, latestSemVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LatestSemVerTaggingStrategy")
		case "pointsTo":
			out.Values[i] = ec._LatestSemVerTaggingStrategy_pointsTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Maintainer_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outputTypeInstanceImplementors = []string{"OutputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _OutputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *OutputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutputTypeInstance")
		case "name":
			out.Values[i] = ec._OutputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._OutputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "repoMetadata":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoMetadata(ctx, field)
				return res
			})
		case "interfaceGroups":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interfaceGroup":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroup(ctx, field)
				return res
			})
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interface":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interface(ctx, field)
				return res
			})
		case "types":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_types(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_type(ctx, field)
				return res
			})
		case "implementations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "implementation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementation(ctx, field)
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attributes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attribute":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attribute(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationAppVersionConfigImplementors = []string{"RepoImplementationAppVersionConfig"}

func (ec *executionContext) _RepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationAppVersionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationAppVersionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationAppVersionConfig")
		case "semVerTaggingStrategy":
			out.Values[i] = ec._RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationConfigImplementors = []string{"RepoImplementationConfig"}

func (ec *executionContext) _RepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationConfig")
		case "appVersion":
			out.Values[i] = ec._RepoImplementationConfig_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataImplementors = []string{"RepoMetadata"}

func (ec *executionContext) _RepoMetadata(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadata")
		case "name":
			out.Values[i] = ec._RepoMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._RepoMetadata_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._RepoMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._RepoMetadata_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoMetadata_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._RepoMetadata_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataRevisionImplementors = []string{"RepoMetadataRevision"}

func (ec *executionContext) _RepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataRevision")
		case "metadata":
			out.Values[i] = ec._RepoMetadataRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._RepoMetadataRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._RepoMetadataRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signature":
			out.Values[i] = ec._RepoMetadataRevision_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataSpecImplementors = []string{"RepoMetadataSpec"}

func (ec *executionContext) _RepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataSpec")
		case "ochVersion":
			out.Values[i] = ec._RepoMetadataSpec_ochVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ocfVersion":
			out.Values[i] = ec._RepoMetadataSpec_ocfVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementation":
			out.Values[i] = ec._RepoMetadataSpec_implementation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoOCFVersionImplementors = []string{"RepoOCFVersion"}

func (ec *executionContext) _RepoOCFVersion(ctx context.Context, sel ast.SelectionSet, obj *RepoOCFVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoOCFVersionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoOCFVersion")
		case "default":
			out.Values[i] = ec._RepoOCFVersion_default(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "supported":
			out.Values[i] = ec._RepoOCFVersion_supported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var semVerTaggingStrategyImplementors = []string{"SemVerTaggingStrategy"}

func (ec *executionContext) _SemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *SemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, semVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SemVerTaggingStrategy")
		case "latest":
			out.Values[i] = ec._SemVerTaggingStrategy_latest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var signatureImplementors = []string{"Signature"}

func (ec *executionContext) _Signature(ctx context.Context, sel ast.SelectionSet, obj *Signature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signatureImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Signature")
		case "och":
			out.Values[i] = ec._Signature_och(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeImplementors = []string{"Type"}

func (ec *executionContext) _Type(ctx context.Context, sel ast.SelectionSet, obj *Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Type")
		case "name":
			out.Values[i] = ec._Type_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Type_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._Type_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Type_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Type_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Type_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeInstanceRelationItemImplementors = []string{"TypeInstanceRelationItem"}

func (ec *executionContext) _TypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, obj *TypeInstanceRelationItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeInstanceRelationItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeInstanceRelationItem")
		case "typeInstanceName":
			out.Values[i] = ec._TypeInstanceRelationItem_typeInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "uses":
			out.Values[i] = ec._TypeInstanceRelationItem_uses(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeMetadataImplementors = []string{"TypeMetadata", "MetadataBaseFields"}

func (ec *executionContext) _TypeMetadata(ctx context.Context, sel ast.SelectionSet, obj *TypeMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeMetadata")
		case "name":
			out.Values[i] = ec._TypeMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._TypeMetadata_prefix(ctx, field, obj)
		case "path":
			out.Values[i] = ec._TypeMetadata_path(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._TypeMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._TypeMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._TypeMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._TypeMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._TypeMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._TypeMetadata_iconURL(ctx, field, obj)
		case "attributes":
			out.Values[i] = ec._TypeMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeReferenceImplementors = []string{"TypeReference"}

func (ec *executionContext) _TypeReference(ctx context.Context, sel ast.SelectionSet, obj *TypeReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeReference")
		case "path":
			out.Values[i] = ec._TypeReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._TypeReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeRevisionImplementors = []string{"TypeRevision"}

func (ec *executionContext) _TypeRevision(ctx context.Context, sel ast.SelectionSet, obj *TypeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeRevision")
		case "metadata":
			out.Values[i] = ec._TypeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._TypeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._TypeRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "signature":
			out.Values[i] = ec._TypeRevision_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeSpecImplementors = []string{"TypeSpec"}

func (ec *executionContext) _TypeSpec(ctx context.Context, sel ast.SelectionSet, obj *TypeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeSpec")
		case "additionalRefs":
			out.Values[i] = ec._TypeSpec_additionalRefs(ctx, field, obj)
		case "jsonSchema":
			out.Values[i] = ec._TypeSpec_jsonSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v []*Attribute) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAttributeFilterInput2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilterInput(ctx context.Context, v interface{}) (*AttributeFilterInput, error) {
	res, err := ec.unmarshalInputAttributeFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v []*AttributeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNAttributeSpec2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeSpec(ctx context.Context, sel ast.SelectionSet, v *AttributeSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AttributeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGenericMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicGenericMetadata(ctx context.Context, sel ast.SelectionSet, v *GenericMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GenericMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v []*Implementation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationAction2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAction(ctx context.Context, sel ast.SelectionSet, v *ImplementationAction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationAction(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImport2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImport(ctx context.Context, sel ast.SelectionSet, v *ImplementationImport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImport(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImportMethod2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImportMethod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImportMethod2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImportMethod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationImportMethod2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, v *ImplementationImportMethod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImportMethod(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationMetadata(ctx context.Context, sel ast.SelectionSet, v *ImplementationMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirement2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirement(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirement2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirement2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirement(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirement(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirementItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirementItem2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirementItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirementItem(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationSpec2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationSpec(ctx context.Context, sel ast.SelectionSet, v *ImplementationSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v []*Interface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v []*InterfaceGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceInput2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceInput(ctx context.Context, sel ast.SelectionSet, v *InterfaceInput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceInput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceOutput2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceOutput(ctx context.Context, sel ast.SelectionSet, v *InterfaceOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceOutput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceReference2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceReference(ctx context.Context, sel ast.SelectionSet, v []*InterfaceReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceReference2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceReference2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceReference(ctx context.Context, sel ast.SelectionSet, v *InterfaceReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceReference(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v []*InterfaceRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceSpec2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceSpec(ctx context.Context, sel ast.SelectionSet, v *InterfaceSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNLatestSemVerTaggingStrategy2projectvoltrondevvoltronpkgochapigraphqlpublicLatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *LatestSemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._LatestSemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx context.Context, sel ast.SelectionSet, v []*Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2projectvoltrondevvoltronpkgochapigraphqlpublicMaintainer(ctx context.Context, sel ast.SelectionSet, v *Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeName2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeName2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePath2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNNodePath2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNNodePrefix2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePrefix2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationAppVersionConfig2projectvoltrondevvoltronpkgochapigraphqlpublicRepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationAppVersionConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationAppVersionConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationConfig2projectvoltrondevvoltronpkgochapigraphqlpublicRepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v []*RepoMetadataRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataSpec2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoOCFVersion2projectvoltrondevvoltronpkgochapigraphqlpublicRepoOCFVersion(ctx context.Context, sel ast.SelectionSet, v *RepoOCFVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoOCFVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNSemVerTaggingStrategy2projectvoltrondevvoltronpkgochapigraphqlpublicSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *SemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSemVerTaggingStrategyTags2projectvoltrondevvoltronpkgochapigraphqlpublicSemVerTaggingStrategyTags(ctx context.Context, v interface{}) (SemVerTaggingStrategyTags, error) {
	var res SemVerTaggingStrategyTags
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSemVerTaggingStrategyTags2projectvoltrondevvoltronpkgochapigraphqlpublicSemVerTaggingStrategyTags(ctx context.Context, sel ast.SelectionSet, v SemVerTaggingStrategyTags) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSignature2projectvoltrondevvoltronpkgochapigraphqlpublicSignature(ctx context.Context, sel ast.SelectionSet, v *Signature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Signature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v []*Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, v interface{}) (TypeInstanceOperationVerb, error) {
	var res TypeInstanceOperationVerb
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, sel ast.SelectionSet, v TypeInstanceOperationVerb) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, v interface{}) ([]TypeInstanceOperationVerb, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TypeInstanceOperationVerb, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, sel ast.SelectionSet, v []TypeInstanceOperationVerb) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceOperationVerb2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceOperationVerb(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, v []*TypeInstanceRelationItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceRelationItem2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceRelationItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, v *TypeInstanceRelationItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeInstanceRelationItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceValue2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) (*TypeInstanceValue, error) {
	res, err := ec.unmarshalInputTypeInstanceValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicTypeMetadata(ctx context.Context, sel ast.SelectionSet, v *TypeMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeReference2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReference(ctx context.Context, sel ast.SelectionSet, v *TypeReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v []*TypeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeSpec2projectvoltrondevvoltronpkgochapigraphqlpublicTypeSpec(ctx context.Context, sel ast.SelectionSet, v *TypeSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersion2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNVersion2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersion2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNVersion2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNVersion2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNVersionRange2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionRange2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalAny(v)
}

func (ec *executionContext) marshalOAttribute2projectvoltrondevvoltronpkgochapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAttributeFilter2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilter(ctx context.Context, v interface{}) (*AttributeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAttributeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAttributeFilterInput2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilterInput(ctx context.Context, v interface{}) ([]*AttributeFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AttributeFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAttributeFilterInput2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAttributeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) unmarshalOFilterRule2projectvoltrondevvoltronpkgochapigraphqlpublicFilterRule(ctx context.Context, v interface{}) (*FilterRule, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FilterRule)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFilterRule2projectvoltrondevvoltronpkgochapigraphqlpublicFilterRule(ctx context.Context, sel ast.SelectionSet, v *FilterRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOImplementation2projectvoltrondevvoltronpkgochapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalInput2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalInput(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalOutput2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImplementationFilter2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationFilter(ctx context.Context, v interface{}) (*ImplementationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImplementationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImplementationImport2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImport(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImport2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationImport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOImplementationRevision2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImplementationRevisionFilter2projectvoltrondevvoltronpkgochapigraphqlpublicImplementationRevisionFilter(ctx context.Context, v interface{}) (*ImplementationRevisionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImplementationRevisionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInputParameters2projectvoltrondevvoltronpkgochapigraphqlpublicInputParameters(ctx context.Context, sel ast.SelectionSet, v *InputParameters) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InputParameters(ctx, sel, v)
}

func (ec *executionContext) marshalOInputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalOInterface2projectvoltrondevvoltronpkgochapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceFilter2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceFilter(ctx context.Context, v interface{}) (*InterfaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceGroup2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceGroupFilter2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceGroupFilter(ctx context.Context, v interface{}) (*InterfaceGroupFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceGroupFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceRevision2projectvoltrondevvoltronpkgochapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalONodePath2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONodePath2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalONodePath2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePath2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalONodePathPattern2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePathPattern2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalONodePrefix2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePrefix2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOOutputTypeInstance2projectvoltrondevvoltronpkgochapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadata2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadata(ctx context.Context, sel ast.SelectionSet, v *RepoMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadataRevision2projectvoltrondevvoltronpkgochapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOType2projectvoltrondevvoltronpkgochapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypeFilter2projectvoltrondevvoltronpkgochapigraphqlpublicTypeFilter(ctx context.Context, v interface{}) (*TypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTypeInstanceValue2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) ([]*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeInstanceValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceValue2projectvoltrondevvoltronpkgochapigraphqlpublicTypeInstanceValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeReferenceInput2projectvoltrondevvoltronpkgochapigraphqlpublicTypeReferenceInput(ctx context.Context, v interface{}) (*TypeReferenceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeReferenceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypeRevision2projectvoltrondevvoltronpkgochapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersion2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOVersionRange2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionRange2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
