// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Attribute() AttributeResolver
	Implementation() ImplementationResolver
	ImplementationRevision() ImplementationRevisionResolver
	Interface() InterfaceResolver
	InterfaceGroup() InterfaceGroupResolver
	Query() QueryResolver
	RepoMetadata() RepoMetadataResolver
	Type() TypeResolver
}

type DirectiveRoot struct {
	AdditionalLabels func(ctx context.Context, obj interface{}, next graphql.Resolver, labels []*string) (res interface{}, err error)
	Cypher           func(ctx context.Context, obj interface{}, next graphql.Resolver, statement *string) (res interface{}, err error)
	Index            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Relation         func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, direction *string, from *string, to *string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Attribute struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	AttributeRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	AttributeSpec struct {
		AdditionalRefs func(childComplexity int) int
	}

	GenericMetadata struct {
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	Implementation struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	ImplementationAction struct {
		Args            func(childComplexity int) int
		RunnerInterface func(childComplexity int) int
	}

	ImplementationAdditionalInput struct {
		Parameters    func(childComplexity int) int
		TypeInstances func(childComplexity int) int
	}

	ImplementationAdditionalInputParameter struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
	}

	ImplementationAdditionalOutput struct {
		TypeInstances func(childComplexity int) int
	}

	ImplementationImport struct {
		Alias              func(childComplexity int) int
		AppVersion         func(childComplexity int) int
		InterfaceGroupPath func(childComplexity int) int
		Methods            func(childComplexity int) int
	}

	ImplementationImportMethod struct {
		Name     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	ImplementationMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		License          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	ImplementationRequirement struct {
		AllOf  func(childComplexity int) int
		AnyOf  func(childComplexity int) int
		OneOf  func(childComplexity int) int
		Prefix func(childComplexity int) int
	}

	ImplementationRequirementItem struct {
		Alias            func(childComplexity int) int
		TypeRef          func(childComplexity int) int
		ValueConstraints func(childComplexity int) int
	}

	ImplementationRevision struct {
		Interfaces func(childComplexity int) int
		Metadata   func(childComplexity int) int
		Revision   func(childComplexity int) int
		Spec       func(childComplexity int) int
	}

	ImplementationSpec struct {
		Action                      func(childComplexity int) int
		AdditionalInput             func(childComplexity int) int
		AdditionalOutput            func(childComplexity int) int
		AppVersion                  func(childComplexity int) int
		Implements                  func(childComplexity int) int
		Imports                     func(childComplexity int) int
		OutputTypeInstanceRelations func(childComplexity int) int
		Requires                    func(childComplexity int) int
	}

	InputParameter struct {
		JSONSchema func(childComplexity int) int
		Name       func(childComplexity int) int
		TypeRef    func(childComplexity int) int
	}

	InputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
		Verbs   func(childComplexity int) int
	}

	Interface struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	InterfaceGroup struct {
		Interfaces func(childComplexity int, filter *InterfaceFilter) int
		Metadata   func(childComplexity int) int
		Path       func(childComplexity int) int
	}

	InterfaceInput struct {
		Parameters    func(childComplexity int) int
		TypeInstances func(childComplexity int) int
	}

	InterfaceOutput struct {
		TypeInstances func(childComplexity int) int
	}

	InterfaceReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	InterfaceRevision struct {
		ImplementationRevisions func(childComplexity int) int
		Metadata                func(childComplexity int) int
		Revision                func(childComplexity int) int
		Spec                    func(childComplexity int) int
	}

	InterfaceSpec struct {
		Input  func(childComplexity int) int
		Output func(childComplexity int) int
	}

	LatestSemVerTaggingStrategy struct {
		PointsTo func(childComplexity int) int
	}

	License struct {
		Name func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
		URL   func(childComplexity int) int
	}

	OutputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
	}

	Query struct {
		Attribute       func(childComplexity int, path string) int
		Attributes      func(childComplexity int, filter *AttributeFilter) int
		Implementation  func(childComplexity int, path string) int
		Implementations func(childComplexity int, filter *ImplementationFilter) int
		Interface       func(childComplexity int, path string) int
		InterfaceGroup  func(childComplexity int, path string) int
		InterfaceGroups func(childComplexity int, filter *InterfaceGroupFilter) int
		Interfaces      func(childComplexity int, filter *InterfaceFilter) int
		RepoMetadata    func(childComplexity int) int
		Type            func(childComplexity int, path string) int
		Types           func(childComplexity int, filter *TypeFilter) int
	}

	RepoImplementationAppVersionConfig struct {
		SemVerTaggingStrategy func(childComplexity int) int
	}

	RepoImplementationConfig struct {
		AppVersion func(childComplexity int) int
	}

	RepoMetadata struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	RepoMetadataRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	RepoMetadataSpec struct {
		HubVersion     func(childComplexity int) int
		Implementation func(childComplexity int) int
		OcfVersion     func(childComplexity int) int
	}

	RepoOCFVersion struct {
		Default   func(childComplexity int) int
		Supported func(childComplexity int) int
	}

	SemVerTaggingStrategy struct {
		Latest func(childComplexity int) int
	}

	Type struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	TypeInstanceRelationItem struct {
		TypeInstanceName func(childComplexity int) int
		Uses             func(childComplexity int) int
	}

	TypeMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	TypeReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	TypeRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	TypeSpec struct {
		AdditionalRefs func(childComplexity int) int
		JSONSchema     func(childComplexity int) int
	}
}

type AttributeResolver interface {
	Revision(ctx context.Context, obj *Attribute, revision string) (*AttributeRevision, error)
}
type ImplementationResolver interface {
	Revision(ctx context.Context, obj *Implementation, revision string) (*ImplementationRevision, error)
}
type ImplementationRevisionResolver interface {
	Interfaces(ctx context.Context, obj *ImplementationRevision) ([]*InterfaceRevision, error)
}
type InterfaceResolver interface {
	Revision(ctx context.Context, obj *Interface, revision string) (*InterfaceRevision, error)
}
type InterfaceGroupResolver interface {
	Interfaces(ctx context.Context, obj *InterfaceGroup, filter *InterfaceFilter) ([]*Interface, error)
}
type QueryResolver interface {
	RepoMetadata(ctx context.Context) (*RepoMetadata, error)
	InterfaceGroups(ctx context.Context, filter *InterfaceGroupFilter) ([]*InterfaceGroup, error)
	InterfaceGroup(ctx context.Context, path string) (*InterfaceGroup, error)
	Interfaces(ctx context.Context, filter *InterfaceFilter) ([]*Interface, error)
	Interface(ctx context.Context, path string) (*Interface, error)
	Types(ctx context.Context, filter *TypeFilter) ([]*Type, error)
	Type(ctx context.Context, path string) (*Type, error)
	Implementations(ctx context.Context, filter *ImplementationFilter) ([]*Implementation, error)
	Implementation(ctx context.Context, path string) (*Implementation, error)
	Attributes(ctx context.Context, filter *AttributeFilter) ([]*Attribute, error)
	Attribute(ctx context.Context, path string) (*Attribute, error)
}
type RepoMetadataResolver interface {
	Revision(ctx context.Context, obj *RepoMetadata, revision string) (*RepoMetadataRevision, error)
}
type TypeResolver interface {
	Revision(ctx context.Context, obj *Type, revision string) (*TypeRevision, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Attribute.latestRevision":
		if e.complexity.Attribute.LatestRevision == nil {
			break
		}

		return e.complexity.Attribute.LatestRevision(childComplexity), true

	case "Attribute.name":
		if e.complexity.Attribute.Name == nil {
			break
		}

		return e.complexity.Attribute.Name(childComplexity), true

	case "Attribute.path":
		if e.complexity.Attribute.Path == nil {
			break
		}

		return e.complexity.Attribute.Path(childComplexity), true

	case "Attribute.prefix":
		if e.complexity.Attribute.Prefix == nil {
			break
		}

		return e.complexity.Attribute.Prefix(childComplexity), true

	case "Attribute.revision":
		if e.complexity.Attribute.Revision == nil {
			break
		}

		args, err := ec.field_Attribute_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Attribute.Revision(childComplexity, args["revision"].(string)), true

	case "Attribute.revisions":
		if e.complexity.Attribute.Revisions == nil {
			break
		}

		return e.complexity.Attribute.Revisions(childComplexity), true

	case "AttributeRevision.metadata":
		if e.complexity.AttributeRevision.Metadata == nil {
			break
		}

		return e.complexity.AttributeRevision.Metadata(childComplexity), true

	case "AttributeRevision.revision":
		if e.complexity.AttributeRevision.Revision == nil {
			break
		}

		return e.complexity.AttributeRevision.Revision(childComplexity), true

	case "AttributeRevision.spec":
		if e.complexity.AttributeRevision.Spec == nil {
			break
		}

		return e.complexity.AttributeRevision.Spec(childComplexity), true

	case "AttributeSpec.additionalRefs":
		if e.complexity.AttributeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.AttributeSpec.AdditionalRefs(childComplexity), true

	case "GenericMetadata.description":
		if e.complexity.GenericMetadata.Description == nil {
			break
		}

		return e.complexity.GenericMetadata.Description(childComplexity), true

	case "GenericMetadata.displayName":
		if e.complexity.GenericMetadata.DisplayName == nil {
			break
		}

		return e.complexity.GenericMetadata.DisplayName(childComplexity), true

	case "GenericMetadata.documentationURL":
		if e.complexity.GenericMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.GenericMetadata.DocumentationURL(childComplexity), true

	case "GenericMetadata.iconURL":
		if e.complexity.GenericMetadata.IconURL == nil {
			break
		}

		return e.complexity.GenericMetadata.IconURL(childComplexity), true

	case "GenericMetadata.maintainers":
		if e.complexity.GenericMetadata.Maintainers == nil {
			break
		}

		return e.complexity.GenericMetadata.Maintainers(childComplexity), true

	case "GenericMetadata.name":
		if e.complexity.GenericMetadata.Name == nil {
			break
		}

		return e.complexity.GenericMetadata.Name(childComplexity), true

	case "GenericMetadata.path":
		if e.complexity.GenericMetadata.Path == nil {
			break
		}

		return e.complexity.GenericMetadata.Path(childComplexity), true

	case "GenericMetadata.prefix":
		if e.complexity.GenericMetadata.Prefix == nil {
			break
		}

		return e.complexity.GenericMetadata.Prefix(childComplexity), true

	case "GenericMetadata.supportURL":
		if e.complexity.GenericMetadata.SupportURL == nil {
			break
		}

		return e.complexity.GenericMetadata.SupportURL(childComplexity), true

	case "Implementation.latestRevision":
		if e.complexity.Implementation.LatestRevision == nil {
			break
		}

		return e.complexity.Implementation.LatestRevision(childComplexity), true

	case "Implementation.name":
		if e.complexity.Implementation.Name == nil {
			break
		}

		return e.complexity.Implementation.Name(childComplexity), true

	case "Implementation.path":
		if e.complexity.Implementation.Path == nil {
			break
		}

		return e.complexity.Implementation.Path(childComplexity), true

	case "Implementation.prefix":
		if e.complexity.Implementation.Prefix == nil {
			break
		}

		return e.complexity.Implementation.Prefix(childComplexity), true

	case "Implementation.revision":
		if e.complexity.Implementation.Revision == nil {
			break
		}

		args, err := ec.field_Implementation_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Implementation.Revision(childComplexity, args["revision"].(string)), true

	case "Implementation.revisions":
		if e.complexity.Implementation.Revisions == nil {
			break
		}

		return e.complexity.Implementation.Revisions(childComplexity), true

	case "ImplementationAction.args":
		if e.complexity.ImplementationAction.Args == nil {
			break
		}

		return e.complexity.ImplementationAction.Args(childComplexity), true

	case "ImplementationAction.runnerInterface":
		if e.complexity.ImplementationAction.RunnerInterface == nil {
			break
		}

		return e.complexity.ImplementationAction.RunnerInterface(childComplexity), true

	case "ImplementationAdditionalInput.parameters":
		if e.complexity.ImplementationAdditionalInput.Parameters == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInput.Parameters(childComplexity), true

	case "ImplementationAdditionalInput.typeInstances":
		if e.complexity.ImplementationAdditionalInput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInput.TypeInstances(childComplexity), true

	case "ImplementationAdditionalInputParameter.name":
		if e.complexity.ImplementationAdditionalInputParameter.Name == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInputParameter.Name(childComplexity), true

	case "ImplementationAdditionalInputParameter.typeRef":
		if e.complexity.ImplementationAdditionalInputParameter.TypeRef == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInputParameter.TypeRef(childComplexity), true

	case "ImplementationAdditionalOutput.typeInstances":
		if e.complexity.ImplementationAdditionalOutput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalOutput.TypeInstances(childComplexity), true

	case "ImplementationImport.alias":
		if e.complexity.ImplementationImport.Alias == nil {
			break
		}

		return e.complexity.ImplementationImport.Alias(childComplexity), true

	case "ImplementationImport.appVersion":
		if e.complexity.ImplementationImport.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationImport.AppVersion(childComplexity), true

	case "ImplementationImport.interfaceGroupPath":
		if e.complexity.ImplementationImport.InterfaceGroupPath == nil {
			break
		}

		return e.complexity.ImplementationImport.InterfaceGroupPath(childComplexity), true

	case "ImplementationImport.methods":
		if e.complexity.ImplementationImport.Methods == nil {
			break
		}

		return e.complexity.ImplementationImport.Methods(childComplexity), true

	case "ImplementationImportMethod.name":
		if e.complexity.ImplementationImportMethod.Name == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Name(childComplexity), true

	case "ImplementationImportMethod.revision":
		if e.complexity.ImplementationImportMethod.Revision == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Revision(childComplexity), true

	case "ImplementationMetadata.attributes":
		if e.complexity.ImplementationMetadata.Attributes == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Attributes(childComplexity), true

	case "ImplementationMetadata.description":
		if e.complexity.ImplementationMetadata.Description == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Description(childComplexity), true

	case "ImplementationMetadata.displayName":
		if e.complexity.ImplementationMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DisplayName(childComplexity), true

	case "ImplementationMetadata.documentationURL":
		if e.complexity.ImplementationMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DocumentationURL(childComplexity), true

	case "ImplementationMetadata.iconURL":
		if e.complexity.ImplementationMetadata.IconURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.IconURL(childComplexity), true

	case "ImplementationMetadata.license":
		if e.complexity.ImplementationMetadata.License == nil {
			break
		}

		return e.complexity.ImplementationMetadata.License(childComplexity), true

	case "ImplementationMetadata.maintainers":
		if e.complexity.ImplementationMetadata.Maintainers == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Maintainers(childComplexity), true

	case "ImplementationMetadata.name":
		if e.complexity.ImplementationMetadata.Name == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Name(childComplexity), true

	case "ImplementationMetadata.path":
		if e.complexity.ImplementationMetadata.Path == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Path(childComplexity), true

	case "ImplementationMetadata.prefix":
		if e.complexity.ImplementationMetadata.Prefix == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Prefix(childComplexity), true

	case "ImplementationMetadata.supportURL":
		if e.complexity.ImplementationMetadata.SupportURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.SupportURL(childComplexity), true

	case "ImplementationRequirement.allOf":
		if e.complexity.ImplementationRequirement.AllOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AllOf(childComplexity), true

	case "ImplementationRequirement.anyOf":
		if e.complexity.ImplementationRequirement.AnyOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AnyOf(childComplexity), true

	case "ImplementationRequirement.oneOf":
		if e.complexity.ImplementationRequirement.OneOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.OneOf(childComplexity), true

	case "ImplementationRequirement.prefix":
		if e.complexity.ImplementationRequirement.Prefix == nil {
			break
		}

		return e.complexity.ImplementationRequirement.Prefix(childComplexity), true

	case "ImplementationRequirementItem.alias":
		if e.complexity.ImplementationRequirementItem.Alias == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.Alias(childComplexity), true

	case "ImplementationRequirementItem.typeRef":
		if e.complexity.ImplementationRequirementItem.TypeRef == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.TypeRef(childComplexity), true

	case "ImplementationRequirementItem.valueConstraints":
		if e.complexity.ImplementationRequirementItem.ValueConstraints == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.ValueConstraints(childComplexity), true

	case "ImplementationRevision.interfaces":
		if e.complexity.ImplementationRevision.Interfaces == nil {
			break
		}

		return e.complexity.ImplementationRevision.Interfaces(childComplexity), true

	case "ImplementationRevision.metadata":
		if e.complexity.ImplementationRevision.Metadata == nil {
			break
		}

		return e.complexity.ImplementationRevision.Metadata(childComplexity), true

	case "ImplementationRevision.revision":
		if e.complexity.ImplementationRevision.Revision == nil {
			break
		}

		return e.complexity.ImplementationRevision.Revision(childComplexity), true

	case "ImplementationRevision.spec":
		if e.complexity.ImplementationRevision.Spec == nil {
			break
		}

		return e.complexity.ImplementationRevision.Spec(childComplexity), true

	case "ImplementationSpec.action":
		if e.complexity.ImplementationSpec.Action == nil {
			break
		}

		return e.complexity.ImplementationSpec.Action(childComplexity), true

	case "ImplementationSpec.additionalInput":
		if e.complexity.ImplementationSpec.AdditionalInput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalInput(childComplexity), true

	case "ImplementationSpec.additionalOutput":
		if e.complexity.ImplementationSpec.AdditionalOutput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalOutput(childComplexity), true

	case "ImplementationSpec.appVersion":
		if e.complexity.ImplementationSpec.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationSpec.AppVersion(childComplexity), true

	case "ImplementationSpec.implements":
		if e.complexity.ImplementationSpec.Implements == nil {
			break
		}

		return e.complexity.ImplementationSpec.Implements(childComplexity), true

	case "ImplementationSpec.imports":
		if e.complexity.ImplementationSpec.Imports == nil {
			break
		}

		return e.complexity.ImplementationSpec.Imports(childComplexity), true

	case "ImplementationSpec.outputTypeInstanceRelations":
		if e.complexity.ImplementationSpec.OutputTypeInstanceRelations == nil {
			break
		}

		return e.complexity.ImplementationSpec.OutputTypeInstanceRelations(childComplexity), true

	case "ImplementationSpec.requires":
		if e.complexity.ImplementationSpec.Requires == nil {
			break
		}

		return e.complexity.ImplementationSpec.Requires(childComplexity), true

	case "InputParameter.jsonSchema":
		if e.complexity.InputParameter.JSONSchema == nil {
			break
		}

		return e.complexity.InputParameter.JSONSchema(childComplexity), true

	case "InputParameter.name":
		if e.complexity.InputParameter.Name == nil {
			break
		}

		return e.complexity.InputParameter.Name(childComplexity), true

	case "InputParameter.typeRef":
		if e.complexity.InputParameter.TypeRef == nil {
			break
		}

		return e.complexity.InputParameter.TypeRef(childComplexity), true

	case "InputTypeInstance.name":
		if e.complexity.InputTypeInstance.Name == nil {
			break
		}

		return e.complexity.InputTypeInstance.Name(childComplexity), true

	case "InputTypeInstance.typeRef":
		if e.complexity.InputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.InputTypeInstance.TypeRef(childComplexity), true

	case "InputTypeInstance.verbs":
		if e.complexity.InputTypeInstance.Verbs == nil {
			break
		}

		return e.complexity.InputTypeInstance.Verbs(childComplexity), true

	case "Interface.latestRevision":
		if e.complexity.Interface.LatestRevision == nil {
			break
		}

		return e.complexity.Interface.LatestRevision(childComplexity), true

	case "Interface.name":
		if e.complexity.Interface.Name == nil {
			break
		}

		return e.complexity.Interface.Name(childComplexity), true

	case "Interface.path":
		if e.complexity.Interface.Path == nil {
			break
		}

		return e.complexity.Interface.Path(childComplexity), true

	case "Interface.prefix":
		if e.complexity.Interface.Prefix == nil {
			break
		}

		return e.complexity.Interface.Prefix(childComplexity), true

	case "Interface.revision":
		if e.complexity.Interface.Revision == nil {
			break
		}

		args, err := ec.field_Interface_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Interface.Revision(childComplexity, args["revision"].(string)), true

	case "Interface.revisions":
		if e.complexity.Interface.Revisions == nil {
			break
		}

		return e.complexity.Interface.Revisions(childComplexity), true

	case "InterfaceGroup.interfaces":
		if e.complexity.InterfaceGroup.Interfaces == nil {
			break
		}

		args, err := ec.field_InterfaceGroup_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfaceGroup.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "InterfaceGroup.metadata":
		if e.complexity.InterfaceGroup.Metadata == nil {
			break
		}

		return e.complexity.InterfaceGroup.Metadata(childComplexity), true

	case "InterfaceGroup.path":
		if e.complexity.InterfaceGroup.Path == nil {
			break
		}

		return e.complexity.InterfaceGroup.Path(childComplexity), true

	case "InterfaceInput.parameters":
		if e.complexity.InterfaceInput.Parameters == nil {
			break
		}

		return e.complexity.InterfaceInput.Parameters(childComplexity), true

	case "InterfaceInput.typeInstances":
		if e.complexity.InterfaceInput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceInput.TypeInstances(childComplexity), true

	case "InterfaceOutput.typeInstances":
		if e.complexity.InterfaceOutput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceOutput.TypeInstances(childComplexity), true

	case "InterfaceReference.path":
		if e.complexity.InterfaceReference.Path == nil {
			break
		}

		return e.complexity.InterfaceReference.Path(childComplexity), true

	case "InterfaceReference.revision":
		if e.complexity.InterfaceReference.Revision == nil {
			break
		}

		return e.complexity.InterfaceReference.Revision(childComplexity), true

	case "InterfaceRevision.implementationRevisions":
		if e.complexity.InterfaceRevision.ImplementationRevisions == nil {
			break
		}

		return e.complexity.InterfaceRevision.ImplementationRevisions(childComplexity), true

	case "InterfaceRevision.metadata":
		if e.complexity.InterfaceRevision.Metadata == nil {
			break
		}

		return e.complexity.InterfaceRevision.Metadata(childComplexity), true

	case "InterfaceRevision.revision":
		if e.complexity.InterfaceRevision.Revision == nil {
			break
		}

		return e.complexity.InterfaceRevision.Revision(childComplexity), true

	case "InterfaceRevision.spec":
		if e.complexity.InterfaceRevision.Spec == nil {
			break
		}

		return e.complexity.InterfaceRevision.Spec(childComplexity), true

	case "InterfaceSpec.input":
		if e.complexity.InterfaceSpec.Input == nil {
			break
		}

		return e.complexity.InterfaceSpec.Input(childComplexity), true

	case "InterfaceSpec.output":
		if e.complexity.InterfaceSpec.Output == nil {
			break
		}

		return e.complexity.InterfaceSpec.Output(childComplexity), true

	case "LatestSemVerTaggingStrategy.pointsTo":
		if e.complexity.LatestSemVerTaggingStrategy.PointsTo == nil {
			break
		}

		return e.complexity.LatestSemVerTaggingStrategy.PointsTo(childComplexity), true

	case "License.name":
		if e.complexity.License.Name == nil {
			break
		}

		return e.complexity.License.Name(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Maintainer.url":
		if e.complexity.Maintainer.URL == nil {
			break
		}

		return e.complexity.Maintainer.URL(childComplexity), true

	case "OutputTypeInstance.name":
		if e.complexity.OutputTypeInstance.Name == nil {
			break
		}

		return e.complexity.OutputTypeInstance.Name(childComplexity), true

	case "OutputTypeInstance.typeRef":
		if e.complexity.OutputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.OutputTypeInstance.TypeRef(childComplexity), true

	case "Query.attribute":
		if e.complexity.Query.Attribute == nil {
			break
		}

		args, err := ec.field_Query_attribute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attribute(childComplexity, args["path"].(string)), true

	case "Query.attributes":
		if e.complexity.Query.Attributes == nil {
			break
		}

		args, err := ec.field_Query_attributes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attributes(childComplexity, args["filter"].(*AttributeFilter)), true

	case "Query.implementation":
		if e.complexity.Query.Implementation == nil {
			break
		}

		args, err := ec.field_Query_implementation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementation(childComplexity, args["path"].(string)), true

	case "Query.implementations":
		if e.complexity.Query.Implementations == nil {
			break
		}

		args, err := ec.field_Query_implementations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementations(childComplexity, args["filter"].(*ImplementationFilter)), true

	case "Query.interface":
		if e.complexity.Query.Interface == nil {
			break
		}

		args, err := ec.field_Query_interface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interface(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroup":
		if e.complexity.Query.InterfaceGroup == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroup(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroups":
		if e.complexity.Query.InterfaceGroups == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroups(childComplexity, args["filter"].(*InterfaceGroupFilter)), true

	case "Query.interfaces":
		if e.complexity.Query.Interfaces == nil {
			break
		}

		args, err := ec.field_Query_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "Query.repoMetadata":
		if e.complexity.Query.RepoMetadata == nil {
			break
		}

		return e.complexity.Query.RepoMetadata(childComplexity), true

	case "Query.type":
		if e.complexity.Query.Type == nil {
			break
		}

		args, err := ec.field_Query_type_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Type(childComplexity, args["path"].(string)), true

	case "Query.types":
		if e.complexity.Query.Types == nil {
			break
		}

		args, err := ec.field_Query_types_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Types(childComplexity, args["filter"].(*TypeFilter)), true

	case "RepoImplementationAppVersionConfig.semVerTaggingStrategy":
		if e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy == nil {
			break
		}

		return e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy(childComplexity), true

	case "RepoImplementationConfig.appVersion":
		if e.complexity.RepoImplementationConfig.AppVersion == nil {
			break
		}

		return e.complexity.RepoImplementationConfig.AppVersion(childComplexity), true

	case "RepoMetadata.latestRevision":
		if e.complexity.RepoMetadata.LatestRevision == nil {
			break
		}

		return e.complexity.RepoMetadata.LatestRevision(childComplexity), true

	case "RepoMetadata.name":
		if e.complexity.RepoMetadata.Name == nil {
			break
		}

		return e.complexity.RepoMetadata.Name(childComplexity), true

	case "RepoMetadata.path":
		if e.complexity.RepoMetadata.Path == nil {
			break
		}

		return e.complexity.RepoMetadata.Path(childComplexity), true

	case "RepoMetadata.prefix":
		if e.complexity.RepoMetadata.Prefix == nil {
			break
		}

		return e.complexity.RepoMetadata.Prefix(childComplexity), true

	case "RepoMetadata.revision":
		if e.complexity.RepoMetadata.Revision == nil {
			break
		}

		args, err := ec.field_RepoMetadata_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RepoMetadata.Revision(childComplexity, args["revision"].(string)), true

	case "RepoMetadata.revisions":
		if e.complexity.RepoMetadata.Revisions == nil {
			break
		}

		return e.complexity.RepoMetadata.Revisions(childComplexity), true

	case "RepoMetadataRevision.metadata":
		if e.complexity.RepoMetadataRevision.Metadata == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Metadata(childComplexity), true

	case "RepoMetadataRevision.revision":
		if e.complexity.RepoMetadataRevision.Revision == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Revision(childComplexity), true

	case "RepoMetadataRevision.spec":
		if e.complexity.RepoMetadataRevision.Spec == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Spec(childComplexity), true

	case "RepoMetadataSpec.hubVersion":
		if e.complexity.RepoMetadataSpec.HubVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.HubVersion(childComplexity), true

	case "RepoMetadataSpec.implementation":
		if e.complexity.RepoMetadataSpec.Implementation == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.Implementation(childComplexity), true

	case "RepoMetadataSpec.ocfVersion":
		if e.complexity.RepoMetadataSpec.OcfVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.OcfVersion(childComplexity), true

	case "RepoOCFVersion.default":
		if e.complexity.RepoOCFVersion.Default == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Default(childComplexity), true

	case "RepoOCFVersion.supported":
		if e.complexity.RepoOCFVersion.Supported == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Supported(childComplexity), true

	case "SemVerTaggingStrategy.latest":
		if e.complexity.SemVerTaggingStrategy.Latest == nil {
			break
		}

		return e.complexity.SemVerTaggingStrategy.Latest(childComplexity), true

	case "Type.latestRevision":
		if e.complexity.Type.LatestRevision == nil {
			break
		}

		return e.complexity.Type.LatestRevision(childComplexity), true

	case "Type.name":
		if e.complexity.Type.Name == nil {
			break
		}

		return e.complexity.Type.Name(childComplexity), true

	case "Type.path":
		if e.complexity.Type.Path == nil {
			break
		}

		return e.complexity.Type.Path(childComplexity), true

	case "Type.prefix":
		if e.complexity.Type.Prefix == nil {
			break
		}

		return e.complexity.Type.Prefix(childComplexity), true

	case "Type.revision":
		if e.complexity.Type.Revision == nil {
			break
		}

		args, err := ec.field_Type_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Type.Revision(childComplexity, args["revision"].(string)), true

	case "Type.revisions":
		if e.complexity.Type.Revisions == nil {
			break
		}

		return e.complexity.Type.Revisions(childComplexity), true

	case "TypeInstanceRelationItem.typeInstanceName":
		if e.complexity.TypeInstanceRelationItem.TypeInstanceName == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.TypeInstanceName(childComplexity), true

	case "TypeInstanceRelationItem.uses":
		if e.complexity.TypeInstanceRelationItem.Uses == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.Uses(childComplexity), true

	case "TypeMetadata.attributes":
		if e.complexity.TypeMetadata.Attributes == nil {
			break
		}

		return e.complexity.TypeMetadata.Attributes(childComplexity), true

	case "TypeMetadata.description":
		if e.complexity.TypeMetadata.Description == nil {
			break
		}

		return e.complexity.TypeMetadata.Description(childComplexity), true

	case "TypeMetadata.displayName":
		if e.complexity.TypeMetadata.DisplayName == nil {
			break
		}

		return e.complexity.TypeMetadata.DisplayName(childComplexity), true

	case "TypeMetadata.documentationURL":
		if e.complexity.TypeMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.TypeMetadata.DocumentationURL(childComplexity), true

	case "TypeMetadata.iconURL":
		if e.complexity.TypeMetadata.IconURL == nil {
			break
		}

		return e.complexity.TypeMetadata.IconURL(childComplexity), true

	case "TypeMetadata.maintainers":
		if e.complexity.TypeMetadata.Maintainers == nil {
			break
		}

		return e.complexity.TypeMetadata.Maintainers(childComplexity), true

	case "TypeMetadata.name":
		if e.complexity.TypeMetadata.Name == nil {
			break
		}

		return e.complexity.TypeMetadata.Name(childComplexity), true

	case "TypeMetadata.path":
		if e.complexity.TypeMetadata.Path == nil {
			break
		}

		return e.complexity.TypeMetadata.Path(childComplexity), true

	case "TypeMetadata.prefix":
		if e.complexity.TypeMetadata.Prefix == nil {
			break
		}

		return e.complexity.TypeMetadata.Prefix(childComplexity), true

	case "TypeMetadata.supportURL":
		if e.complexity.TypeMetadata.SupportURL == nil {
			break
		}

		return e.complexity.TypeMetadata.SupportURL(childComplexity), true

	case "TypeReference.path":
		if e.complexity.TypeReference.Path == nil {
			break
		}

		return e.complexity.TypeReference.Path(childComplexity), true

	case "TypeReference.revision":
		if e.complexity.TypeReference.Revision == nil {
			break
		}

		return e.complexity.TypeReference.Revision(childComplexity), true

	case "TypeRevision.metadata":
		if e.complexity.TypeRevision.Metadata == nil {
			break
		}

		return e.complexity.TypeRevision.Metadata(childComplexity), true

	case "TypeRevision.revision":
		if e.complexity.TypeRevision.Revision == nil {
			break
		}

		return e.complexity.TypeRevision.Revision(childComplexity), true

	case "TypeRevision.spec":
		if e.complexity.TypeRevision.Spec == nil {
			break
		}

		return e.complexity.TypeRevision.Spec(childComplexity), true

	case "TypeSpec.additionalRefs":
		if e.complexity.TypeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.TypeSpec.AdditionalRefs(childComplexity), true

	case "TypeSpec.jsonSchema":
		if e.complexity.TypeSpec.JSONSchema == nil {
			break
		}

		return e.complexity.TypeSpec.JSONSchema(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../../hub-js/graphql/public/schema.graphql", Input: `# Neo4j-graphql-js adds some directives during parsing of the schema.
# To make it work for other GraphQL clients, we need to add them to the schema manually, based on:
# https://github.com/neo4j-graphql/neo4j-graphql-js/blob/master/src/augment/directives.js
directive @relation(
  name: String
  direction: String
  from: String
  to: String
) on FIELD_DEFINITION | OBJECT
directive @additionalLabels(labels: [String]) on OBJECT
directive @cypher(statement: String) on FIELD_DEFINITION
directive @index on FIELD_DEFINITION

"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Pattern of the path of a given node, e.g. cap.core.type.platform.*
"""
scalar NodePathPattern

"""
Path for the parent node, e.g. for Interface it is InterfaceGroup path.
"""
scalar NodePrefix

"""
Name of a given node. Name is immutable between different revisions of a given node.
"""
scalar NodeName

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

"""
Range of versions, e.g. "1.14.x, 1.15.0 - 1.15.3"
"""
scalar VersionRange

input InterfaceFilter {
  pathPattern: NodePathPattern
}

input ImplementationFilter {
  pathPattern: NodePathPattern
}

# TODO: Enable lint rule once the InterfaceRevision.implementationRevisionsForRequirements is implemented
# lint-disable defined-types-are-used
"""
Dedicated input type for filtering ImplementationRevisions in future resolver
` + "`" + `InterfaceRevision.implementationRevisionsForRequirements` + "`" + `.

Currently used only for Hub Go client package as the server-side resolver is not implemented.
"""
input ImplementationRevisionFilter {
  pathPattern: NodePathPattern

  """
  If provided, Implementations are filtered by the ones that have satisfied requirements with provided TypeInstance values.
  For example, to find all Implementations that can be run on a given system, user can provide values of all existing TypeInstances.
  """
  requirementsSatisfiedBy: [TypeInstanceValue!]

  """
  Filter by Implementations, which have requirements injection satisfied.
  If provided, all TypeInstance values are merged into ` + "`" + `requirementsSatisfiedBy` + "`" + ` filter values, and, in a result,
  both filters ` + "`" + `requirementsSatisfiedBy` + "`" + ` and ` + "`" + `requiredTypeInstancesInjectionSatisfiedBy` + "`" + ` are used.
  """
  requiredTypeInstancesInjectionSatisfiedBy: [TypeInstanceValue]

  attributes: [AttributeFilterInput!]

  """
  If provided, the ImplementationRevisions for a given Interface will be filtered
  according to provided Type references looked up in the ` + "`" + `Implementation.spec.requires` + "`" + ` field.

  For every item in the array, the returned ImplementationRevisions must specify
  such TypeReference in ` + "`" + `Implementation.spec.requires` + "`" + ` in any of the sections: oneOf, anyOf or allOf.
  """
  requires: [TypeReferenceWithOptionalRevision]
}
# lint-enable defined-types-are-used

input TypeInstanceValue {
  typeRef: TypeReferenceInput!

  """
  Currently not supported.
  Value of the available requirement. If not provided, all valueConstraints conditions are treated as satisfied.
  """
  value: Any
}

input TypeReferenceWithOptionalRevision {
  path: NodePath!
  revision: Version
}

input TypeReferenceInput {
  path: NodePath!
  revision: Version!
}

input AttributeFilterInput {
  path: NodePath!
  rule: FilterRule = INCLUDE

  """
  If not provided, any revision of the Attribute applies to this filter
  """
  revision: Version
}

enum FilterRule {
  INCLUDE
  EXCLUDE
}

input InterfaceGroupFilter {
  pathPattern: NodePathPattern
}

input AttributeFilter {
  pathPattern: NodePathPattern
}

input TypeFilter {
  pathPattern: NodePathPattern
}

type RepoMetadata @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published {revision: $revision}) RETURN r"
    )
  revisions: [RepoMetadataRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type RepoMetadataRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: RepoMetadataSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type RepoMetadataSpec @additionalLabels(labels: ["published"]) {
  hubVersion: Version!
  ocfVersion: RepoOCFVersion! @relation(name: "SUPPORTS", direction: "OUT")
  implementation: RepoImplementationConfig!
    @relation(name: "CONFIGURED", direction: "OUT")
}

type RepoImplementationConfig @additionalLabels(labels: ["published"]) {
  appVersion: RepoImplementationAppVersionConfig!
    @relation(name: "APP_VERSION", direction: "OUT")
}

type RepoImplementationAppVersionConfig
  @additionalLabels(labels: ["published"]) {
  semVerTaggingStrategy: SemVerTaggingStrategy!
    @relation(name: "TAGGING_STRATEGY", direction: "OUT")
}

type SemVerTaggingStrategy @additionalLabels(labels: ["published"]) {
  latest: LatestSemVerTaggingStrategy!
    @relation(name: "LATEST", direction: "OUT")
}

type LatestSemVerTaggingStrategy @additionalLabels(labels: ["published"]) {
  pointsTo: SemVerTaggingStrategyTags!
}

enum SemVerTaggingStrategyTags {
  STABLE
  EDGE
}

type RepoOCFVersion @additionalLabels(labels: ["published"]) {
  supported: [Version!]!
  default: Version!
}

type InterfaceGroup @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  interfaces(filter: InterfaceFilter): [Interface!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type Interface @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published {revision: $revision}) RETURN ir"
    )
  revisions: [InterfaceRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type InterfaceRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: InterfaceSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")

  implementationRevisions: [ImplementationRevision!]!
    @relation(name: "IMPLEMENTS", direction: "IN")

  # TODO: Reimplement the resolver:
  # implementationRevisionsForRequirements(filter: ImplementationRevisionFilter): [ImplementationRevision!]!
  # See the initial implementation: https://github.com/capactio/capact/commit/18bded8aed9d4e7b8a90d23ffc17134d920290e0#diff-73bc98d8e409e7044514f7af22931d76cb7da73504c678421c398f0c0501ef92R203
}

type InterfaceSpec @additionalLabels(labels: ["published"]) {
  input: InterfaceInput! @relation(name: "HAS_INPUT", direction: "OUT")
  output: InterfaceOutput! @relation(name: "OUTPUTS", direction: "OUT")
}

type InterfaceInput @additionalLabels(labels: ["published"]) {
  parameters: [InputParameter!]! @relation(name: "HAS", direction: "OUT")
  typeInstances: [InputTypeInstance]! @relation(name: "HAS", direction: "OUT")
}

type InputParameter @additionalLabels(labels: ["published"]) {
  name: String!
  jsonSchema: Any
  typeRef: TypeReference @relation(name: "OF_TYPE", direction: "OUT")
}

type InterfaceOutput @additionalLabels(labels: ["published"]) {
  typeInstances: [OutputTypeInstance]!
    @relation(name: "OUTPUTS", direction: "OUT")
}

interface TypeInstanceFields {
  name: String!
  typeRef: TypeReference!
}

type InputTypeInstance implements TypeInstanceFields
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
  verbs: [TypeInstanceOperationVerb!]!
    @cypher(
      statement: """
      MATCH (this)
      RETURN [verb IN this.verbs | toUpper(verb)] as verbs
      """
    )
}

enum TypeInstanceOperationVerb {
  CREATE
  GET
  LIST
  UPDATE
  DELETE
}

type OutputTypeInstance implements TypeInstanceFields
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
}

type Type @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r {revision: $revision}) RETURN r"
    )
  revisions: [TypeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type TypeRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: TypeMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: TypeSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type TypeSpec @additionalLabels(labels: ["published"]) {
  additionalRefs: [NodePath!]
  jsonSchema: Any
}

type Implementation @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published {revision: $revision}) RETURN ir"
    )
  revisions: [ImplementationRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: ImplementationMetadata!
    @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: ImplementationSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  interfaces: [InterfaceRevision!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
}

type ImplementationSpec @additionalLabels(labels: ["published"]) {
  appVersion: VersionRange! @index

  implements: [InterfaceReference!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
  requires: [ImplementationRequirement!]!
    @relation(name: "REQUIRES", direction: "OUT")
  imports: [ImplementationImport!] @relation(name: "IMPORTS", direction: "OUT")
  action: ImplementationAction! @relation(name: "DOES", direction: "OUT")
  additionalInput: ImplementationAdditionalInput
    @relation(name: "USES", direction: "OUT")
  additionalOutput: ImplementationAdditionalOutput
    @relation(name: "OUTPUTS", direction: "OUT")
  outputTypeInstanceRelations: [TypeInstanceRelationItem!]!
    @relation(name: "RELATIONS", direction: "OUT")
}

type ImplementationAdditionalInput @additionalLabels(labels: ["published"]) {
  typeInstances: [InputTypeInstance!]
    @relation(name: "CONTAINS", direction: "OUT")
  parameters: [ImplementationAdditionalInputParameter!]
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationAdditionalInputParameter
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
}

type ImplementationAdditionalOutput @additionalLabels(labels: ["published"]) {
  typeInstances: [OutputTypeInstance!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type TypeInstanceRelationItem @additionalLabels(labels: ["published"]) {
  typeInstanceName: String!

  """
  Contains list of Type Instance names, which a given TypeInstance uses (depends on)
  """
  uses: [String!]
}

type InterfaceReference @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  revision: Version! @index
}

type ImplementationRequirement @additionalLabels(labels: ["published"]) {
  prefix: NodePrefix!
  oneOf: [ImplementationRequirementItem!]!
    @relation(name: "ONE_OF", direction: "OUT")
  anyOf: [ImplementationRequirementItem!]!
    @relation(name: "ANY_OF", direction: "OUT")
  allOf: [ImplementationRequirementItem!]!
    @relation(name: "ALL_OF", direction: "OUT")
}

type ImplementationRequirementItem @additionalLabels(labels: ["published"]) {
  typeRef: TypeReference! @relation(name: "REFERENCES_TYPE", direction: "OUT")

  """
  Holds the configuration constraints for the given entry based on Type value.
  Currently not supported.
  """
  valueConstraints: Any

  """
  If provided, the TypeInstance of the Type, configured in policy, is injected to the workflow under the alias.
  """
  alias: String
}

type TypeReference @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  revision: Version! @index
}

type ImplementationImport @additionalLabels(labels: ["published"]) {
  interfaceGroupPath: NodePath!
  alias: String
  appVersion: VersionRange

  methods: [ImplementationImportMethod!]!
    @relation(name: "HAS", direction: "OUT")
}

type ImplementationImportMethod @additionalLabels(labels: ["published"]) {
  name: NodeName!

  """
  If not provided, latest revision for a given Interface is used
  """
  revision: Version
}

type ImplementationAction @additionalLabels(labels: ["published"]) {
  """
  The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
  """
  runnerInterface: String!
  args: Any
    @cypher(
      statement: """
      MATCH (this) RETURN apoc.convert.fromJsonMap(this.args) as args
      """
    )
}

type Attribute @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 2"
    )
  revision(revision: Version!): AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published {revision: $revision}) RETURN r"
    )
  revisions: [AttributeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type AttributeRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  spec: AttributeSpec @relation(name: "SPECIFIED_BY", direction: "OUT")
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
}

# It is defined to make sure that all metadata types have the same base fields.
# Unfortunately all Types that implement an Interface have to repeat the same fields,
# however it's the only way to do so.
interface MetadataBaseFields {
  name: NodeName
  prefix: NodePrefix
  path: NodePath
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type GenericMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type ImplementationMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  license: License! @relation(name: "LICENSED_WITH", direction: "OUT")
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type TypeMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type License @additionalLabels(labels: ["published"]) {
  name: String! @index
}

type Maintainer @additionalLabels(labels: ["published"]) {
  name: String @index
  email: String! @index
  url: String
}

type AttributeSpec @additionalLabels(labels: ["published"]) {
  additionalRefs: [NodePath!]!
}

type Query @additionalLabels(labels: ["published"]) {
  repoMetadata: RepoMetadata

  interfaceGroups(filter: InterfaceGroupFilter = {}): [InterfaceGroup!]!
    @cypher(
      statement: """
      MATCH (this:InterfaceGroup:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  interfaceGroup(path: NodePath!): InterfaceGroup

  interfaces(filter: InterfaceFilter = {}): [Interface!]!
    @cypher(
      statement: """
      MATCH (this:Interface:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  interface(path: NodePath!): Interface

  types(filter: TypeFilter = {}): [Type!]!
    @cypher(
      statement: """
      // Find all children associated with a given path pattern
      OPTIONAL MATCH (b:VirtualType:published)-[:CONTAINS]->(children:Type:published)
      WHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = "*" OR b.path =~ $filter.pathPattern

      WITH children

      // Find all specific Types that matches a given pattern
      MATCH (type:Type:published)
      WHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = "*" OR type.path =~ $filter.pathPattern

      // Flat collection of specify Types and attached children
      UNWIND [type, children] AS res

      WITH res
      // OPTIONAL MATCH may produce NULL values
      WHERE res is NOT NULL
      // Get rid of duplicates
      RETURN DISTINCT res
      """
    )
  type(path: NodePath!): Type

  implementations(filter: ImplementationFilter = {}): [Implementation!]!
    @cypher(
      statement: """
      MATCH (this:Implementation:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )

  implementation(path: NodePath!): Implementation

  attributes(filter: AttributeFilter = {}): [Attribute!]!
    @cypher(
      statement: """
      MATCH (this:Attribute:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  attribute(path: NodePath!): Attribute
}

# TODO: Prepare directive for user authorization in https://github.com/capactio/capact/issues/508
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_additionalLabels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["labels"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
		arg0, err = ec.unmarshalOString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) dir_cypher_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["statement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statement"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["statement"] = arg0
	return args, nil
}

func (ec *executionContext) dir_relation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["direction"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["direction"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["from"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["to"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["to"] = arg3
	return args, nil
}

func (ec *executionContext) field_Attribute_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Implementation_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_InterfaceGroup_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Interface_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attribute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attributes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AttributeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOAttributeFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ImplementationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOImplementationFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceGroupFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceGroupFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroupFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_types_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTypeFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_RepoMetadata_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Type_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Attribute_path(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_name(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_prefix(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 2")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Attribute_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Attribute().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revisions(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeSpec)
	fc.Result = res
	return ec.marshalOAttributeSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *AttributeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNNodePath2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_path(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_name(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_description(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_path(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_name(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_prefix(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Implementation_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Implementation().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published {revision: $revision}) RETURN ir")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revisions(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_runnerInterface(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunnerInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_args(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Args, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this) RETURN apoc.convert.fromJsonMap(this.args) as args")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive0, statement)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(interface{}); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be interface{}`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalOInputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInput_parameters(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Parameters, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationAdditionalInputParameter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalInputParameter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ImplementationAdditionalInputParameter)
	fc.Result = res
	return ec.marshalOImplementationAdditionalInputParameter2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInputParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInputParameter_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInputParameter_typeRef(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*OutputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.OutputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_interfaceGroupPath(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceGroupPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersionRange2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_methods(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Methods, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationImportMethod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationImportMethod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImportMethod)
	fc.Result = res
	return ec.marshalNImplementationImportMethod2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportMethodᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_path(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_description(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_license(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.License, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "LICENSED_WITH")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*License); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.License`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*License)
	fc.Result = res
	return ec.marshalNLicense2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Attributes, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CHARACTERIZED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_oneOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OneOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "ONE_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_anyOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AnyOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "ANY_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_allOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AllOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "ALL_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_typeRef(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "REFERENCES_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_valueConstraints(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationMetadata)
	fc.Result = res
	return ec.marshalNImplementationMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_spec(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationSpec)
	fc.Result = res
	return ec.marshalNImplementationSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_interfaces(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ImplementationRevision().Interfaces(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceRevision)
	fc.Result = res
	return ec.marshalNInterfaceRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionRange2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_implements(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Implements, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceReference)
	fc.Result = res
	return ec.marshalNInterfaceReference2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceReferenceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_requires(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Requires, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "REQUIRES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirement)
	fc.Result = res
	return ec.marshalNImplementationRequirement2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_imports(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Imports, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "IMPORTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationImport); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationImport`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImport)
	fc.Result = res
	return ec.marshalOImplementationImport2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_action(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Action, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DOES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationAction)
	fc.Result = res
	return ec.marshalNImplementationAction2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAction(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalInput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdditionalInput, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "USES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAdditionalInput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalInput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalInput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalOutput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdditionalOutput, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAdditionalOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalOutput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalOutput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_outputTypeInstanceRelations(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OutputTypeInstanceRelations, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "RELATIONS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeInstanceRelationItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.TypeInstanceRelationItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeInstanceRelationItem)
	fc.Result = res
	return ec.marshalNTypeInstanceRelationItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceRelationItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_name(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_typeRef(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalOTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_verbs(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Verbs, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)\nRETURN [verb IN this.verbs | toUpper(verb)] as verbs")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive0, statement)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TypeInstanceOperationVerb); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []capact.io/capact/pkg/hub/api/graphql/public.TypeInstanceOperationVerb`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]TypeInstanceOperationVerb)
	fc.Result = res
	return ec.marshalNTypeInstanceOperationVerb2ᚕcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerbᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_path(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_name(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_prefix(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Interface_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Interface().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published {revision: $revision}) RETURN ir")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revisions(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceRevision)
	fc.Result = res
	return ec.marshalNInterfaceRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_path(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_InterfaceGroup_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.InterfaceGroup().Interfaces(rctx, obj, args["filter"].(*InterfaceFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_parameters(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Parameters, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputParameter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputParameter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputParameter)
	fc.Result = res
	return ec.marshalNInputParameter2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalNInputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*OutputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.OutputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_path(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_spec(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceSpec)
	fc.Result = res
	return ec.marshalNInterfaceSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_implementationRevisions(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ImplementationRevisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "IN")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_input(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Input, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "HAS_INPUT")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceInput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceInput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceInput)
	fc.Result = res
	return ec.marshalNInterfaceInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceInput(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_output(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Output, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceOutput)
	fc.Result = res
	return ec.marshalNInterfaceOutput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _LatestSemVerTaggingStrategy_pointsTo(ctx context.Context, field graphql.CollectedField, obj *LatestSemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LatestSemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointsTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SemVerTaggingStrategyTags)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategyTags2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐSemVerTaggingStrategyTags(ctx, field.Selections, res)
}

func (ec *executionContext) _License_name(ctx context.Context, field graphql.CollectedField, obj *License) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "License",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Email, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_url(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_repoMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RepoMetadata(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadata)
	fc.Result = res
	return ec.marshalORepoMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InterfaceGroups(rctx, args["filter"].(*InterfaceGroupFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this:InterfaceGroup:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceGroup)
	fc.Result = res
	return ec.marshalNInterfaceGroup2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroup_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InterfaceGroup(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceGroup)
	fc.Result = res
	return ec.marshalOInterfaceGroup2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interfaces(rctx, args["filter"].(*InterfaceFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this:Interface:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interface_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interface(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Interface)
	fc.Result = res
	return ec.marshalOInterface2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_types(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_types_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Types(rctx, args["filter"].(*TypeFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "// Find all children associated with a given path pattern\nOPTIONAL MATCH (b:VirtualType:published)-[:CONTAINS]->(children:Type:published)\nWHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = \"*\" OR b.path =~ $filter.pathPattern\n\nWITH children\n\n// Find all specific Types that matches a given pattern\nMATCH (type:Type:published)\nWHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = \"*\" OR type.path =~ $filter.pathPattern\n\n// Flat collection of specify Types and attached children\nUNWIND [type, children] AS res\n\nWITH res\n// OPTIONAL MATCH may produce NULL values\nWHERE res is NOT NULL\n// Get rid of duplicates\nRETURN DISTINCT res")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Type); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Type`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Type)
	fc.Result = res
	return ec.marshalNType2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Type(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Type); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Type`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Type)
	fc.Result = res
	return ec.marshalOType2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementations_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Implementations(rctx, args["filter"].(*ImplementationFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this:Implementation:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Implementation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Implementation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Implementation)
	fc.Result = res
	return ec.marshalNImplementation2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementation_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Implementation(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Implementation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Implementation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Implementation)
	fc.Result = res
	return ec.marshalOImplementation2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementation(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attributes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attributes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Attributes(rctx, args["filter"].(*AttributeFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this:Attribute:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Attribute); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Attribute`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Attribute)
	fc.Result = res
	return ec.marshalNAttribute2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attribute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attribute_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Attribute(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Attribute); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Attribute`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Attribute)
	fc.Result = res
	return ec.marshalOAttribute2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationAppVersionConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationAppVersionConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.SemVerTaggingStrategy, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "TAGGING_STRATEGY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SemVerTaggingStrategy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.SemVerTaggingStrategy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategy2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationConfig_appVersion(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "APP_VERSION")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoImplementationAppVersionConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoImplementationAppVersionConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationAppVersionConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationAppVersionConfig2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoImplementationAppVersionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_path(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_name(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_latestRevision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_RepoMetadata_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.RepoMetadata().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revisions(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalNRepoMetadataRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_spec(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataSpec)
	fc.Result = res
	return ec.marshalNRepoMetadataSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_hubVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_ocfVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OcfVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SUPPORTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoOCFVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoOCFVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoOCFVersion)
	fc.Result = res
	return ec.marshalNRepoOCFVersion2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoOCFVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_implementation(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Implementation, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONFIGURED")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoImplementationConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoImplementationConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationConfig2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoImplementationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_supported(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNVersion2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_default(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SemVerTaggingStrategy_latest(ctx context.Context, field graphql.CollectedField, obj *SemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "SemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Latest, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "LATEST")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LatestSemVerTaggingStrategy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.LatestSemVerTaggingStrategy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LatestSemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNLatestSemVerTaggingStrategy2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐLatestSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_path(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_name(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_prefix(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r) RETURN r ORDER BY r.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Type_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Type().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2ᚖstring(ctx, "MATCH (this)-[:CONTAINS]->(r {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revisions(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeRevision)
	fc.Result = res
	return ec.marshalNTypeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_typeInstanceName(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstanceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_uses(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_path(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_name(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_description(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Attributes, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "CHARACTERIZED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevisionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_path(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_revision(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeMetadata)
	fc.Result = res
	return ec.marshalNTypeMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2ᚖstring(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2ᚖstring(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeSpec)
	fc.Result = res
	return ec.marshalNTypeSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalONodePath2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAttributeFilter(ctx context.Context, obj interface{}) (AttributeFilter, error) {
	var it AttributeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttributeFilterInput(ctx context.Context, obj interface{}) (AttributeFilterInput, error) {
	var it AttributeFilterInput
	var asMap = obj.(map[string]interface{})

	if _, present := asMap["rule"]; !present {
		asMap["rule"] = "INCLUDE"
	}

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalOFilterRule2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐFilterRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationFilter(ctx context.Context, obj interface{}) (ImplementationFilter, error) {
	var it ImplementationFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationRevisionFilter(ctx context.Context, obj interface{}) (ImplementationRevisionFilter, error) {
	var it ImplementationRevisionFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "requirementsSatisfiedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requirementsSatisfiedBy"))
			it.RequirementsSatisfiedBy, err = ec.unmarshalOTypeInstanceValue2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValueᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "requiredTypeInstancesInjectionSatisfiedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiredTypeInstancesInjectionSatisfiedBy"))
			it.RequiredTypeInstancesInjectionSatisfiedBy, err = ec.unmarshalOTypeInstanceValue2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOAttributeFilterInput2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilterInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "requires":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
			it.Requires, err = ec.unmarshalOTypeReferenceWithOptionalRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceWithOptionalRevision(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceFilter(ctx context.Context, obj interface{}) (InterfaceFilter, error) {
	var it InterfaceFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceGroupFilter(ctx context.Context, obj interface{}) (InterfaceGroupFilter, error) {
	var it InterfaceGroupFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeFilter(ctx context.Context, obj interface{}) (TypeFilter, error) {
	var it TypeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeInstanceValue(ctx context.Context, obj interface{}) (TypeInstanceValue, error) {
	var it TypeInstanceValue
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeRef":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeRef"))
			it.TypeRef, err = ec.unmarshalNTypeReferenceInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeReferenceInput(ctx context.Context, obj interface{}) (TypeReferenceInput, error) {
	var it TypeReferenceInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalNVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeReferenceWithOptionalRevision(ctx context.Context, obj interface{}) (TypeReferenceWithOptionalRevision, error) {
	var it TypeReferenceWithOptionalRevision
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _MetadataBaseFields(ctx context.Context, sel ast.SelectionSet, obj MetadataBaseFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case GenericMetadata:
		return ec._GenericMetadata(ctx, sel, &obj)
	case *GenericMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._GenericMetadata(ctx, sel, obj)
	case ImplementationMetadata:
		return ec._ImplementationMetadata(ctx, sel, &obj)
	case *ImplementationMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImplementationMetadata(ctx, sel, obj)
	case TypeMetadata:
		return ec._TypeMetadata(ctx, sel, &obj)
	case *TypeMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._TypeMetadata(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TypeInstanceFields(ctx context.Context, sel ast.SelectionSet, obj TypeInstanceFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case InputTypeInstance:
		return ec._InputTypeInstance(ctx, sel, &obj)
	case *InputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._InputTypeInstance(ctx, sel, obj)
	case OutputTypeInstance:
		return ec._OutputTypeInstance(ctx, sel, &obj)
	case *OutputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._OutputTypeInstance(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var attributeImplementors = []string{"Attribute"}

func (ec *executionContext) _Attribute(ctx context.Context, sel ast.SelectionSet, obj *Attribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Attribute")
		case "path":
			out.Values[i] = ec._Attribute_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Attribute_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Attribute_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Attribute_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Attribute_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Attribute_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeRevisionImplementors = []string{"AttributeRevision"}

func (ec *executionContext) _AttributeRevision(ctx context.Context, sel ast.SelectionSet, obj *AttributeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeRevision")
		case "revision":
			out.Values[i] = ec._AttributeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._AttributeRevision_spec(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._AttributeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeSpecImplementors = []string{"AttributeSpec"}

func (ec *executionContext) _AttributeSpec(ctx context.Context, sel ast.SelectionSet, obj *AttributeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeSpec")
		case "additionalRefs":
			out.Values[i] = ec._AttributeSpec_additionalRefs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var genericMetadataImplementors = []string{"GenericMetadata", "MetadataBaseFields"}

func (ec *executionContext) _GenericMetadata(ctx context.Context, sel ast.SelectionSet, obj *GenericMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, genericMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GenericMetadata")
		case "path":
			out.Values[i] = ec._GenericMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._GenericMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._GenericMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._GenericMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GenericMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._GenericMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._GenericMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._GenericMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._GenericMetadata_iconURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImplementors = []string{"Implementation"}

func (ec *executionContext) _Implementation(ctx context.Context, sel ast.SelectionSet, obj *Implementation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Implementation")
		case "path":
			out.Values[i] = ec._Implementation_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Implementation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Implementation_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Implementation_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Implementation_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Implementation_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationActionImplementors = []string{"ImplementationAction"}

func (ec *executionContext) _ImplementationAction(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationActionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAction")
		case "runnerInterface":
			out.Values[i] = ec._ImplementationAction_runnerInterface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec._ImplementationAction_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalInputImplementors = []string{"ImplementationAdditionalInput"}

func (ec *executionContext) _ImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalInput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalInput_typeInstances(ctx, field, obj)
		case "parameters":
			out.Values[i] = ec._ImplementationAdditionalInput_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalInputParameterImplementors = []string{"ImplementationAdditionalInputParameter"}

func (ec *executionContext) _ImplementationAdditionalInputParameter(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalInputParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalInputParameterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalInputParameter")
		case "name":
			out.Values[i] = ec._ImplementationAdditionalInputParameter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._ImplementationAdditionalInputParameter_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalOutputImplementors = []string{"ImplementationAdditionalOutput"}

func (ec *executionContext) _ImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalOutput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportImplementors = []string{"ImplementationImport"}

func (ec *executionContext) _ImplementationImport(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImport")
		case "interfaceGroupPath":
			out.Values[i] = ec._ImplementationImport_interfaceGroupPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "alias":
			out.Values[i] = ec._ImplementationImport_alias(ctx, field, obj)
		case "appVersion":
			out.Values[i] = ec._ImplementationImport_appVersion(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._ImplementationImport_methods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportMethodImplementors = []string{"ImplementationImportMethod"}

func (ec *executionContext) _ImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImportMethod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportMethodImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImportMethod")
		case "name":
			out.Values[i] = ec._ImplementationImportMethod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._ImplementationImportMethod_revision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationMetadataImplementors = []string{"ImplementationMetadata", "MetadataBaseFields"}

func (ec *executionContext) _ImplementationMetadata(ctx context.Context, sel ast.SelectionSet, obj *ImplementationMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationMetadata")
		case "path":
			out.Values[i] = ec._ImplementationMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ImplementationMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._ImplementationMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ImplementationMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ImplementationMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._ImplementationMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._ImplementationMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._ImplementationMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._ImplementationMetadata_iconURL(ctx, field, obj)
		case "license":
			out.Values[i] = ec._ImplementationMetadata_license(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attributes":
			out.Values[i] = ec._ImplementationMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementImplementors = []string{"ImplementationRequirement"}

func (ec *executionContext) _ImplementationRequirement(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirement")
		case "prefix":
			out.Values[i] = ec._ImplementationRequirement_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "oneOf":
			out.Values[i] = ec._ImplementationRequirement_oneOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "anyOf":
			out.Values[i] = ec._ImplementationRequirement_anyOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "allOf":
			out.Values[i] = ec._ImplementationRequirement_allOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementItemImplementors = []string{"ImplementationRequirementItem"}

func (ec *executionContext) _ImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirementItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirementItem")
		case "typeRef":
			out.Values[i] = ec._ImplementationRequirementItem_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "valueConstraints":
			out.Values[i] = ec._ImplementationRequirementItem_valueConstraints(ctx, field, obj)
		case "alias":
			out.Values[i] = ec._ImplementationRequirementItem_alias(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRevisionImplementors = []string{"ImplementationRevision"}

func (ec *executionContext) _ImplementationRevision(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRevision")
		case "revision":
			out.Values[i] = ec._ImplementationRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ImplementationRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ImplementationRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImplementationRevision_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationSpecImplementors = []string{"ImplementationSpec"}

func (ec *executionContext) _ImplementationSpec(ctx context.Context, sel ast.SelectionSet, obj *ImplementationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationSpec")
		case "appVersion":
			out.Values[i] = ec._ImplementationSpec_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implements":
			out.Values[i] = ec._ImplementationSpec_implements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requires":
			out.Values[i] = ec._ImplementationSpec_requires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imports":
			out.Values[i] = ec._ImplementationSpec_imports(ctx, field, obj)
		case "action":
			out.Values[i] = ec._ImplementationSpec_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "additionalInput":
			out.Values[i] = ec._ImplementationSpec_additionalInput(ctx, field, obj)
		case "additionalOutput":
			out.Values[i] = ec._ImplementationSpec_additionalOutput(ctx, field, obj)
		case "outputTypeInstanceRelations":
			out.Values[i] = ec._ImplementationSpec_outputTypeInstanceRelations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputParameterImplementors = []string{"InputParameter"}

func (ec *executionContext) _InputParameter(ctx context.Context, sel ast.SelectionSet, obj *InputParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputParameterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputParameter")
		case "name":
			out.Values[i] = ec._InputParameter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jsonSchema":
			out.Values[i] = ec._InputParameter_jsonSchema(ctx, field, obj)
		case "typeRef":
			out.Values[i] = ec._InputParameter_typeRef(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputTypeInstanceImplementors = []string{"InputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _InputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *InputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputTypeInstance")
		case "name":
			out.Values[i] = ec._InputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._InputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "verbs":
			out.Values[i] = ec._InputTypeInstance_verbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceImplementors = []string{"Interface"}

func (ec *executionContext) _Interface(ctx context.Context, sel ast.SelectionSet, obj *Interface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interface")
		case "path":
			out.Values[i] = ec._Interface_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Interface_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Interface_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Interface_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Interface_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Interface_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceGroupImplementors = []string{"InterfaceGroup"}

func (ec *executionContext) _InterfaceGroup(ctx context.Context, sel ast.SelectionSet, obj *InterfaceGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceGroup")
		case "path":
			out.Values[i] = ec._InterfaceGroup_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._InterfaceGroup_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InterfaceGroup_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceInputImplementors = []string{"InterfaceInput"}

func (ec *executionContext) _InterfaceInput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceInput")
		case "parameters":
			out.Values[i] = ec._InterfaceInput_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeInstances":
			out.Values[i] = ec._InterfaceInput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceOutputImplementors = []string{"InterfaceOutput"}

func (ec *executionContext) _InterfaceOutput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceOutput")
		case "typeInstances":
			out.Values[i] = ec._InterfaceOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceReferenceImplementors = []string{"InterfaceReference"}

func (ec *executionContext) _InterfaceReference(ctx context.Context, sel ast.SelectionSet, obj *InterfaceReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceReference")
		case "path":
			out.Values[i] = ec._InterfaceReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._InterfaceReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceRevisionImplementors = []string{"InterfaceRevision"}

func (ec *executionContext) _InterfaceRevision(ctx context.Context, sel ast.SelectionSet, obj *InterfaceRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceRevision")
		case "revision":
			out.Values[i] = ec._InterfaceRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._InterfaceRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._InterfaceRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementationRevisions":
			out.Values[i] = ec._InterfaceRevision_implementationRevisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceSpecImplementors = []string{"InterfaceSpec"}

func (ec *executionContext) _InterfaceSpec(ctx context.Context, sel ast.SelectionSet, obj *InterfaceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceSpec")
		case "input":
			out.Values[i] = ec._InterfaceSpec_input(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "output":
			out.Values[i] = ec._InterfaceSpec_output(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var latestSemVerTaggingStrategyImplementors = []string{"LatestSemVerTaggingStrategy"}

func (ec *executionContext) _LatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *LatestSemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, latestSemVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LatestSemVerTaggingStrategy")
		case "pointsTo":
			out.Values[i] = ec._LatestSemVerTaggingStrategy_pointsTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var licenseImplementors = []string{"License"}

func (ec *executionContext) _License(ctx context.Context, sel ast.SelectionSet, obj *License) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, licenseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("License")
		case "name":
			out.Values[i] = ec._License_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Maintainer_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outputTypeInstanceImplementors = []string{"OutputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _OutputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *OutputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutputTypeInstance")
		case "name":
			out.Values[i] = ec._OutputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._OutputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "repoMetadata":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoMetadata(ctx, field)
				return res
			})
		case "interfaceGroups":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interfaceGroup":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroup(ctx, field)
				return res
			})
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interface":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interface(ctx, field)
				return res
			})
		case "types":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_types(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_type(ctx, field)
				return res
			})
		case "implementations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "implementation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementation(ctx, field)
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attributes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attribute":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attribute(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationAppVersionConfigImplementors = []string{"RepoImplementationAppVersionConfig"}

func (ec *executionContext) _RepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationAppVersionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationAppVersionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationAppVersionConfig")
		case "semVerTaggingStrategy":
			out.Values[i] = ec._RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationConfigImplementors = []string{"RepoImplementationConfig"}

func (ec *executionContext) _RepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationConfig")
		case "appVersion":
			out.Values[i] = ec._RepoImplementationConfig_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataImplementors = []string{"RepoMetadata"}

func (ec *executionContext) _RepoMetadata(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadata")
		case "path":
			out.Values[i] = ec._RepoMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._RepoMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._RepoMetadata_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._RepoMetadata_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoMetadata_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._RepoMetadata_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataRevisionImplementors = []string{"RepoMetadataRevision"}

func (ec *executionContext) _RepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataRevision")
		case "revision":
			out.Values[i] = ec._RepoMetadataRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._RepoMetadataRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._RepoMetadataRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataSpecImplementors = []string{"RepoMetadataSpec"}

func (ec *executionContext) _RepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataSpec")
		case "hubVersion":
			out.Values[i] = ec._RepoMetadataSpec_hubVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ocfVersion":
			out.Values[i] = ec._RepoMetadataSpec_ocfVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementation":
			out.Values[i] = ec._RepoMetadataSpec_implementation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoOCFVersionImplementors = []string{"RepoOCFVersion"}

func (ec *executionContext) _RepoOCFVersion(ctx context.Context, sel ast.SelectionSet, obj *RepoOCFVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoOCFVersionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoOCFVersion")
		case "supported":
			out.Values[i] = ec._RepoOCFVersion_supported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "default":
			out.Values[i] = ec._RepoOCFVersion_default(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var semVerTaggingStrategyImplementors = []string{"SemVerTaggingStrategy"}

func (ec *executionContext) _SemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *SemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, semVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SemVerTaggingStrategy")
		case "latest":
			out.Values[i] = ec._SemVerTaggingStrategy_latest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeImplementors = []string{"Type"}

func (ec *executionContext) _Type(ctx context.Context, sel ast.SelectionSet, obj *Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Type")
		case "path":
			out.Values[i] = ec._Type_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Type_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Type_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Type_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Type_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Type_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeInstanceRelationItemImplementors = []string{"TypeInstanceRelationItem"}

func (ec *executionContext) _TypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, obj *TypeInstanceRelationItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeInstanceRelationItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeInstanceRelationItem")
		case "typeInstanceName":
			out.Values[i] = ec._TypeInstanceRelationItem_typeInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "uses":
			out.Values[i] = ec._TypeInstanceRelationItem_uses(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeMetadataImplementors = []string{"TypeMetadata", "MetadataBaseFields"}

func (ec *executionContext) _TypeMetadata(ctx context.Context, sel ast.SelectionSet, obj *TypeMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeMetadata")
		case "path":
			out.Values[i] = ec._TypeMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._TypeMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._TypeMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._TypeMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._TypeMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._TypeMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._TypeMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._TypeMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._TypeMetadata_iconURL(ctx, field, obj)
		case "attributes":
			out.Values[i] = ec._TypeMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeReferenceImplementors = []string{"TypeReference"}

func (ec *executionContext) _TypeReference(ctx context.Context, sel ast.SelectionSet, obj *TypeReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeReference")
		case "path":
			out.Values[i] = ec._TypeReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._TypeReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeRevisionImplementors = []string{"TypeRevision"}

func (ec *executionContext) _TypeRevision(ctx context.Context, sel ast.SelectionSet, obj *TypeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeRevision")
		case "revision":
			out.Values[i] = ec._TypeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._TypeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._TypeRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeSpecImplementors = []string{"TypeSpec"}

func (ec *executionContext) _TypeSpec(ctx context.Context, sel ast.SelectionSet, obj *TypeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeSpec")
		case "additionalRefs":
			out.Values[i] = ec._TypeSpec_additionalRefs(ctx, field, obj)
		case "jsonSchema":
			out.Values[i] = ec._TypeSpec_jsonSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAttribute2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeᚄ(ctx context.Context, sel ast.SelectionSet, v []*Attribute) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttribute2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttribute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttribute2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAttributeFilterInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilterInput(ctx context.Context, v interface{}) (*AttributeFilterInput, error) {
	res, err := ec.unmarshalInputAttributeFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAttributeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevisionᚄ(ctx context.Context, sel ast.SelectionSet, v []*AttributeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttributeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttributeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGenericMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐGenericMetadata(ctx context.Context, sel ast.SelectionSet, v *GenericMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GenericMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementation2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationᚄ(ctx context.Context, sel ast.SelectionSet, v []*Implementation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementation2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementation2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationAction2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAction(ctx context.Context, sel ast.SelectionSet, v *ImplementationAction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationAction(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationAdditionalInputParameter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInputParameter(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalInputParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationAdditionalInputParameter(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImport2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImport(ctx context.Context, sel ast.SelectionSet, v *ImplementationImport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImport(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImportMethod2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportMethodᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImportMethod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImportMethod2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportMethod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationImportMethod2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, v *ImplementationImportMethod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImportMethod(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationMetadata(ctx context.Context, sel ast.SelectionSet, v *ImplementationMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirement2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirement2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirement2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirement(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirement(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirementItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirementItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirementItem2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirementItem2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirementItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirementItem(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevisionᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationSpec(ctx context.Context, sel ast.SelectionSet, v *ImplementationSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNInputParameter2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []*InputParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInputParameter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputParameter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputParameter(ctx context.Context, sel ast.SelectionSet, v *InputParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InputParameter(ctx, sel, v)
}

func (ec *executionContext) marshalNInputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNInterface2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceᚄ(ctx context.Context, sel ast.SelectionSet, v []*Interface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterface2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterface2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceGroup2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*InterfaceGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceGroup2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceGroup2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceInput(ctx context.Context, sel ast.SelectionSet, v *InterfaceInput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceInput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceOutput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceOutput(ctx context.Context, sel ast.SelectionSet, v *InterfaceOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceOutput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceReference2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceReferenceᚄ(ctx context.Context, sel ast.SelectionSet, v []*InterfaceReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceReference(ctx context.Context, sel ast.SelectionSet, v *InterfaceReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceReference(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevisionᚄ(ctx context.Context, sel ast.SelectionSet, v []*InterfaceRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceSpec(ctx context.Context, sel ast.SelectionSet, v *InterfaceSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNLatestSemVerTaggingStrategy2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐLatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *LatestSemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._LatestSemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNLicense2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐLicense(ctx context.Context, sel ast.SelectionSet, v *License) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._License(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainerᚄ(ctx context.Context, sel ast.SelectionSet, v []*Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v *Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeName2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeName2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePath2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNNodePath2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNNodePrefix2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePrefix2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNOutputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOutputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationAppVersionConfig2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationAppVersionConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationAppVersionConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationConfig2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevisionᚄ(ctx context.Context, sel ast.SelectionSet, v []*RepoMetadataRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepoMetadataRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepoMetadataRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoOCFVersion2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoOCFVersion(ctx context.Context, sel ast.SelectionSet, v *RepoOCFVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoOCFVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNSemVerTaggingStrategy2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *SemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSemVerTaggingStrategyTags2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐSemVerTaggingStrategyTags(ctx context.Context, v interface{}) (SemVerTaggingStrategyTags, error) {
	var res SemVerTaggingStrategyTags
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSemVerTaggingStrategyTags2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐSemVerTaggingStrategyTags(ctx context.Context, sel ast.SelectionSet, v SemVerTaggingStrategyTags) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNType2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []*Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNType2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNType2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerb(ctx context.Context, v interface{}) (TypeInstanceOperationVerb, error) {
	var res TypeInstanceOperationVerb
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerb(ctx context.Context, sel ast.SelectionSet, v TypeInstanceOperationVerb) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2ᚕcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerbᚄ(ctx context.Context, v interface{}) ([]TypeInstanceOperationVerb, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TypeInstanceOperationVerb, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceOperationVerb2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerb(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2ᚕcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerbᚄ(ctx context.Context, sel ast.SelectionSet, v []TypeInstanceOperationVerb) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceOperationVerb2capactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceOperationVerb(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceRelationItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*TypeInstanceRelationItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceRelationItem2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceRelationItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, v *TypeInstanceRelationItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeInstanceRelationItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceValue2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx context.Context, v interface{}) (*TypeInstanceValue, error) {
	res, err := ec.unmarshalInputTypeInstanceValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeMetadata(ctx context.Context, sel ast.SelectionSet, v *TypeMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx context.Context, sel ast.SelectionSet, v *TypeReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeReferenceInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceInput(ctx context.Context, v interface{}) (*TypeReferenceInput, error) {
	res, err := ec.unmarshalInputTypeReferenceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevisionᚄ(ctx context.Context, sel ast.SelectionSet, v []*TypeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeSpec(ctx context.Context, sel ast.SelectionSet, v *TypeSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersion2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNVersion2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersion2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNVersion2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNVersion2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNVersionRange2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionRange2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalAny(v)
}

func (ec *executionContext) marshalOAttribute2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAttributeFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilter(ctx context.Context, v interface{}) (*AttributeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAttributeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAttributeFilterInput2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilterInputᚄ(ctx context.Context, v interface{}) ([]*AttributeFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AttributeFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAttributeFilterInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAttributeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOAttributeSpec2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐAttributeSpec(ctx context.Context, sel ast.SelectionSet, v *AttributeSpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AttributeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) unmarshalOFilterRule2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐFilterRule(ctx context.Context, v interface{}) (*FilterRule, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FilterRule)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFilterRule2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐFilterRule(ctx context.Context, sel ast.SelectionSet, v *FilterRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOImplementation2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalInput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalInput(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalInputParameter2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInputParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationAdditionalInputParameter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationAdditionalInputParameter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalInputParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOImplementationAdditionalOutput2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImplementationFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationFilter(ctx context.Context, v interface{}) (*ImplementationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImplementationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImplementationImport2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImportᚄ(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImport2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationImport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOImplementationRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOInputTypeInstance2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalOInterface2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceFilter(ctx context.Context, v interface{}) (*InterfaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceGroup2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceGroupFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceGroupFilter(ctx context.Context, v interface{}) (*InterfaceGroupFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceGroupFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalONodePath2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONodePath2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalONodePathPattern2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePathPattern2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalONodePrefix2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePrefix2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOOutputTypeInstance2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadata2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadata(ctx context.Context, sel ast.SelectionSet, v *RepoMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadataRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOType2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypeFilter2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeFilter(ctx context.Context, v interface{}) (*TypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTypeInstanceValue2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx context.Context, v interface{}) ([]*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeInstanceValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTypeInstanceValue2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeInstanceValue2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValueᚄ(ctx context.Context, v interface{}) ([]*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeInstanceValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceValue2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeInstanceValue2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeInstanceValue(ctx context.Context, v interface{}) (*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeInstanceValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypeReference2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReference(ctx context.Context, sel ast.SelectionSet, v *TypeReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypeReferenceWithOptionalRevision2ᚕᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceWithOptionalRevision(ctx context.Context, v interface{}) ([]*TypeReferenceWithOptionalRevision, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeReferenceWithOptionalRevision, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTypeReferenceWithOptionalRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceWithOptionalRevision(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeReferenceWithOptionalRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeReferenceWithOptionalRevision(ctx context.Context, v interface{}) (*TypeReferenceWithOptionalRevision, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeReferenceWithOptionalRevision(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypeRevision2ᚖcapactᚗioᚋcapactᚋpkgᚋhubᚋapiᚋgraphqlᚋpublicᚐTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersion2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOVersionRange2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionRange2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
