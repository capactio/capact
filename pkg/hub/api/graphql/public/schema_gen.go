// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Attribute() AttributeResolver
	Implementation() ImplementationResolver
	ImplementationRevision() ImplementationRevisionResolver
	Interface() InterfaceResolver
	InterfaceGroup() InterfaceGroupResolver
	Query() QueryResolver
	RepoMetadata() RepoMetadataResolver
	Type() TypeResolver
}

type DirectiveRoot struct {
	AdditionalLabels func(ctx context.Context, obj interface{}, next graphql.Resolver, labels []*string) (res interface{}, err error)
	Cypher           func(ctx context.Context, obj interface{}, next graphql.Resolver, statement *string) (res interface{}, err error)
	Index            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Relation         func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string, direction *string, from *string, to *string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Attribute struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	AttributeRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	AttributeSpec struct {
		AdditionalRefs func(childComplexity int) int
	}

	GenericMetadata struct {
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	Implementation struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	ImplementationAction struct {
		Args            func(childComplexity int) int
		RunnerInterface func(childComplexity int) int
	}

	ImplementationAdditionalInput struct {
		Parameters    func(childComplexity int) int
		TypeInstances func(childComplexity int) int
	}

	ImplementationAdditionalInputParameter struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
	}

	ImplementationAdditionalOutput struct {
		TypeInstances func(childComplexity int) int
	}

	ImplementationImport struct {
		Alias              func(childComplexity int) int
		AppVersion         func(childComplexity int) int
		InterfaceGroupPath func(childComplexity int) int
		Methods            func(childComplexity int) int
	}

	ImplementationImportMethod struct {
		Name     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	ImplementationMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		License          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	ImplementationRequirement struct {
		AllOf  func(childComplexity int) int
		AnyOf  func(childComplexity int) int
		OneOf  func(childComplexity int) int
		Prefix func(childComplexity int) int
	}

	ImplementationRequirementItem struct {
		Alias            func(childComplexity int) int
		TypeRef          func(childComplexity int) int
		ValueConstraints func(childComplexity int) int
	}

	ImplementationRevision struct {
		Interfaces func(childComplexity int) int
		Metadata   func(childComplexity int) int
		Revision   func(childComplexity int) int
		Spec       func(childComplexity int) int
	}

	ImplementationSpec struct {
		Action                      func(childComplexity int) int
		AdditionalInput             func(childComplexity int) int
		AdditionalOutput            func(childComplexity int) int
		AppVersion                  func(childComplexity int) int
		Implements                  func(childComplexity int) int
		Imports                     func(childComplexity int) int
		OutputTypeInstanceRelations func(childComplexity int) int
		Requires                    func(childComplexity int) int
	}

	InputParameter struct {
		JSONSchema func(childComplexity int) int
		Name       func(childComplexity int) int
		TypeRef    func(childComplexity int) int
	}

	InputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
		Verbs   func(childComplexity int) int
	}

	Interface struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	InterfaceGroup struct {
		Interfaces func(childComplexity int, filter *InterfaceFilter) int
		Metadata   func(childComplexity int) int
		Path       func(childComplexity int) int
	}

	InterfaceInput struct {
		Parameters    func(childComplexity int) int
		TypeInstances func(childComplexity int) int
	}

	InterfaceOutput struct {
		TypeInstances func(childComplexity int) int
	}

	InterfaceReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	InterfaceRevision struct {
		ImplementationRevisions func(childComplexity int) int
		Metadata                func(childComplexity int) int
		Revision                func(childComplexity int) int
		Spec                    func(childComplexity int) int
	}

	InterfaceSpec struct {
		Input  func(childComplexity int) int
		Output func(childComplexity int) int
	}

	LatestSemVerTaggingStrategy struct {
		PointsTo func(childComplexity int) int
	}

	License struct {
		Name func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
		URL   func(childComplexity int) int
	}

	OutputTypeInstance struct {
		Name    func(childComplexity int) int
		TypeRef func(childComplexity int) int
	}

	Query struct {
		Attribute       func(childComplexity int, path string) int
		Attributes      func(childComplexity int, filter *AttributeFilter) int
		Implementation  func(childComplexity int, path string) int
		Implementations func(childComplexity int, filter *ImplementationFilter) int
		Interface       func(childComplexity int, path string) int
		InterfaceGroup  func(childComplexity int, path string) int
		InterfaceGroups func(childComplexity int, filter *InterfaceGroupFilter) int
		Interfaces      func(childComplexity int, filter *InterfaceFilter) int
		RepoMetadata    func(childComplexity int) int
		Type            func(childComplexity int, path string) int
		Types           func(childComplexity int, filter *TypeFilter) int
	}

	RepoImplementationAppVersionConfig struct {
		SemVerTaggingStrategy func(childComplexity int) int
	}

	RepoImplementationConfig struct {
		AppVersion func(childComplexity int) int
	}

	RepoMetadata struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	RepoMetadataRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	RepoMetadataSpec struct {
		HubVersion     func(childComplexity int) int
		Implementation func(childComplexity int) int
		OcfVersion     func(childComplexity int) int
	}

	RepoOCFVersion struct {
		Default   func(childComplexity int) int
		Supported func(childComplexity int) int
	}

	SemVerTaggingStrategy struct {
		Latest func(childComplexity int) int
	}

	Type struct {
		LatestRevision func(childComplexity int) int
		Name           func(childComplexity int) int
		Path           func(childComplexity int) int
		Prefix         func(childComplexity int) int
		Revision       func(childComplexity int, revision string) int
		Revisions      func(childComplexity int) int
	}

	TypeInstanceRelationItem struct {
		TypeInstanceName func(childComplexity int) int
		Uses             func(childComplexity int) int
	}

	TypeMetadata struct {
		Attributes       func(childComplexity int) int
		Description      func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		DocumentationURL func(childComplexity int) int
		IconURL          func(childComplexity int) int
		Maintainers      func(childComplexity int) int
		Name             func(childComplexity int) int
		Path             func(childComplexity int) int
		Prefix           func(childComplexity int) int
		SupportURL       func(childComplexity int) int
	}

	TypeReference struct {
		Path     func(childComplexity int) int
		Revision func(childComplexity int) int
	}

	TypeRevision struct {
		Metadata func(childComplexity int) int
		Revision func(childComplexity int) int
		Spec     func(childComplexity int) int
	}

	TypeSpec struct {
		AdditionalRefs func(childComplexity int) int
		JSONSchema     func(childComplexity int) int
	}
}

type AttributeResolver interface {
	Revision(ctx context.Context, obj *Attribute, revision string) (*AttributeRevision, error)
}
type ImplementationResolver interface {
	Revision(ctx context.Context, obj *Implementation, revision string) (*ImplementationRevision, error)
}
type ImplementationRevisionResolver interface {
	Interfaces(ctx context.Context, obj *ImplementationRevision) ([]*InterfaceRevision, error)
}
type InterfaceResolver interface {
	Revision(ctx context.Context, obj *Interface, revision string) (*InterfaceRevision, error)
}
type InterfaceGroupResolver interface {
	Interfaces(ctx context.Context, obj *InterfaceGroup, filter *InterfaceFilter) ([]*Interface, error)
}
type QueryResolver interface {
	RepoMetadata(ctx context.Context) (*RepoMetadata, error)
	InterfaceGroups(ctx context.Context, filter *InterfaceGroupFilter) ([]*InterfaceGroup, error)
	InterfaceGroup(ctx context.Context, path string) (*InterfaceGroup, error)
	Interfaces(ctx context.Context, filter *InterfaceFilter) ([]*Interface, error)
	Interface(ctx context.Context, path string) (*Interface, error)
	Types(ctx context.Context, filter *TypeFilter) ([]*Type, error)
	Type(ctx context.Context, path string) (*Type, error)
	Implementations(ctx context.Context, filter *ImplementationFilter) ([]*Implementation, error)
	Implementation(ctx context.Context, path string) (*Implementation, error)
	Attributes(ctx context.Context, filter *AttributeFilter) ([]*Attribute, error)
	Attribute(ctx context.Context, path string) (*Attribute, error)
}
type RepoMetadataResolver interface {
	Revision(ctx context.Context, obj *RepoMetadata, revision string) (*RepoMetadataRevision, error)
}
type TypeResolver interface {
	Revision(ctx context.Context, obj *Type, revision string) (*TypeRevision, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Attribute.latestRevision":
		if e.complexity.Attribute.LatestRevision == nil {
			break
		}

		return e.complexity.Attribute.LatestRevision(childComplexity), true

	case "Attribute.name":
		if e.complexity.Attribute.Name == nil {
			break
		}

		return e.complexity.Attribute.Name(childComplexity), true

	case "Attribute.path":
		if e.complexity.Attribute.Path == nil {
			break
		}

		return e.complexity.Attribute.Path(childComplexity), true

	case "Attribute.prefix":
		if e.complexity.Attribute.Prefix == nil {
			break
		}

		return e.complexity.Attribute.Prefix(childComplexity), true

	case "Attribute.revision":
		if e.complexity.Attribute.Revision == nil {
			break
		}

		args, err := ec.field_Attribute_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Attribute.Revision(childComplexity, args["revision"].(string)), true

	case "Attribute.revisions":
		if e.complexity.Attribute.Revisions == nil {
			break
		}

		return e.complexity.Attribute.Revisions(childComplexity), true

	case "AttributeRevision.metadata":
		if e.complexity.AttributeRevision.Metadata == nil {
			break
		}

		return e.complexity.AttributeRevision.Metadata(childComplexity), true

	case "AttributeRevision.revision":
		if e.complexity.AttributeRevision.Revision == nil {
			break
		}

		return e.complexity.AttributeRevision.Revision(childComplexity), true

	case "AttributeRevision.spec":
		if e.complexity.AttributeRevision.Spec == nil {
			break
		}

		return e.complexity.AttributeRevision.Spec(childComplexity), true

	case "AttributeSpec.additionalRefs":
		if e.complexity.AttributeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.AttributeSpec.AdditionalRefs(childComplexity), true

	case "GenericMetadata.description":
		if e.complexity.GenericMetadata.Description == nil {
			break
		}

		return e.complexity.GenericMetadata.Description(childComplexity), true

	case "GenericMetadata.displayName":
		if e.complexity.GenericMetadata.DisplayName == nil {
			break
		}

		return e.complexity.GenericMetadata.DisplayName(childComplexity), true

	case "GenericMetadata.documentationURL":
		if e.complexity.GenericMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.GenericMetadata.DocumentationURL(childComplexity), true

	case "GenericMetadata.iconURL":
		if e.complexity.GenericMetadata.IconURL == nil {
			break
		}

		return e.complexity.GenericMetadata.IconURL(childComplexity), true

	case "GenericMetadata.maintainers":
		if e.complexity.GenericMetadata.Maintainers == nil {
			break
		}

		return e.complexity.GenericMetadata.Maintainers(childComplexity), true

	case "GenericMetadata.name":
		if e.complexity.GenericMetadata.Name == nil {
			break
		}

		return e.complexity.GenericMetadata.Name(childComplexity), true

	case "GenericMetadata.path":
		if e.complexity.GenericMetadata.Path == nil {
			break
		}

		return e.complexity.GenericMetadata.Path(childComplexity), true

	case "GenericMetadata.prefix":
		if e.complexity.GenericMetadata.Prefix == nil {
			break
		}

		return e.complexity.GenericMetadata.Prefix(childComplexity), true

	case "GenericMetadata.supportURL":
		if e.complexity.GenericMetadata.SupportURL == nil {
			break
		}

		return e.complexity.GenericMetadata.SupportURL(childComplexity), true

	case "Implementation.latestRevision":
		if e.complexity.Implementation.LatestRevision == nil {
			break
		}

		return e.complexity.Implementation.LatestRevision(childComplexity), true

	case "Implementation.name":
		if e.complexity.Implementation.Name == nil {
			break
		}

		return e.complexity.Implementation.Name(childComplexity), true

	case "Implementation.path":
		if e.complexity.Implementation.Path == nil {
			break
		}

		return e.complexity.Implementation.Path(childComplexity), true

	case "Implementation.prefix":
		if e.complexity.Implementation.Prefix == nil {
			break
		}

		return e.complexity.Implementation.Prefix(childComplexity), true

	case "Implementation.revision":
		if e.complexity.Implementation.Revision == nil {
			break
		}

		args, err := ec.field_Implementation_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Implementation.Revision(childComplexity, args["revision"].(string)), true

	case "Implementation.revisions":
		if e.complexity.Implementation.Revisions == nil {
			break
		}

		return e.complexity.Implementation.Revisions(childComplexity), true

	case "ImplementationAction.args":
		if e.complexity.ImplementationAction.Args == nil {
			break
		}

		return e.complexity.ImplementationAction.Args(childComplexity), true

	case "ImplementationAction.runnerInterface":
		if e.complexity.ImplementationAction.RunnerInterface == nil {
			break
		}

		return e.complexity.ImplementationAction.RunnerInterface(childComplexity), true

	case "ImplementationAdditionalInput.parameters":
		if e.complexity.ImplementationAdditionalInput.Parameters == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInput.Parameters(childComplexity), true

	case "ImplementationAdditionalInput.typeInstances":
		if e.complexity.ImplementationAdditionalInput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInput.TypeInstances(childComplexity), true

	case "ImplementationAdditionalInputParameter.name":
		if e.complexity.ImplementationAdditionalInputParameter.Name == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInputParameter.Name(childComplexity), true

	case "ImplementationAdditionalInputParameter.typeRef":
		if e.complexity.ImplementationAdditionalInputParameter.TypeRef == nil {
			break
		}

		return e.complexity.ImplementationAdditionalInputParameter.TypeRef(childComplexity), true

	case "ImplementationAdditionalOutput.typeInstances":
		if e.complexity.ImplementationAdditionalOutput.TypeInstances == nil {
			break
		}

		return e.complexity.ImplementationAdditionalOutput.TypeInstances(childComplexity), true

	case "ImplementationImport.alias":
		if e.complexity.ImplementationImport.Alias == nil {
			break
		}

		return e.complexity.ImplementationImport.Alias(childComplexity), true

	case "ImplementationImport.appVersion":
		if e.complexity.ImplementationImport.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationImport.AppVersion(childComplexity), true

	case "ImplementationImport.interfaceGroupPath":
		if e.complexity.ImplementationImport.InterfaceGroupPath == nil {
			break
		}

		return e.complexity.ImplementationImport.InterfaceGroupPath(childComplexity), true

	case "ImplementationImport.methods":
		if e.complexity.ImplementationImport.Methods == nil {
			break
		}

		return e.complexity.ImplementationImport.Methods(childComplexity), true

	case "ImplementationImportMethod.name":
		if e.complexity.ImplementationImportMethod.Name == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Name(childComplexity), true

	case "ImplementationImportMethod.revision":
		if e.complexity.ImplementationImportMethod.Revision == nil {
			break
		}

		return e.complexity.ImplementationImportMethod.Revision(childComplexity), true

	case "ImplementationMetadata.attributes":
		if e.complexity.ImplementationMetadata.Attributes == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Attributes(childComplexity), true

	case "ImplementationMetadata.description":
		if e.complexity.ImplementationMetadata.Description == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Description(childComplexity), true

	case "ImplementationMetadata.displayName":
		if e.complexity.ImplementationMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DisplayName(childComplexity), true

	case "ImplementationMetadata.documentationURL":
		if e.complexity.ImplementationMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.DocumentationURL(childComplexity), true

	case "ImplementationMetadata.iconURL":
		if e.complexity.ImplementationMetadata.IconURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.IconURL(childComplexity), true

	case "ImplementationMetadata.license":
		if e.complexity.ImplementationMetadata.License == nil {
			break
		}

		return e.complexity.ImplementationMetadata.License(childComplexity), true

	case "ImplementationMetadata.maintainers":
		if e.complexity.ImplementationMetadata.Maintainers == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Maintainers(childComplexity), true

	case "ImplementationMetadata.name":
		if e.complexity.ImplementationMetadata.Name == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Name(childComplexity), true

	case "ImplementationMetadata.path":
		if e.complexity.ImplementationMetadata.Path == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Path(childComplexity), true

	case "ImplementationMetadata.prefix":
		if e.complexity.ImplementationMetadata.Prefix == nil {
			break
		}

		return e.complexity.ImplementationMetadata.Prefix(childComplexity), true

	case "ImplementationMetadata.supportURL":
		if e.complexity.ImplementationMetadata.SupportURL == nil {
			break
		}

		return e.complexity.ImplementationMetadata.SupportURL(childComplexity), true

	case "ImplementationRequirement.allOf":
		if e.complexity.ImplementationRequirement.AllOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AllOf(childComplexity), true

	case "ImplementationRequirement.anyOf":
		if e.complexity.ImplementationRequirement.AnyOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.AnyOf(childComplexity), true

	case "ImplementationRequirement.oneOf":
		if e.complexity.ImplementationRequirement.OneOf == nil {
			break
		}

		return e.complexity.ImplementationRequirement.OneOf(childComplexity), true

	case "ImplementationRequirement.prefix":
		if e.complexity.ImplementationRequirement.Prefix == nil {
			break
		}

		return e.complexity.ImplementationRequirement.Prefix(childComplexity), true

	case "ImplementationRequirementItem.alias":
		if e.complexity.ImplementationRequirementItem.Alias == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.Alias(childComplexity), true

	case "ImplementationRequirementItem.typeRef":
		if e.complexity.ImplementationRequirementItem.TypeRef == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.TypeRef(childComplexity), true

	case "ImplementationRequirementItem.valueConstraints":
		if e.complexity.ImplementationRequirementItem.ValueConstraints == nil {
			break
		}

		return e.complexity.ImplementationRequirementItem.ValueConstraints(childComplexity), true

	case "ImplementationRevision.interfaces":
		if e.complexity.ImplementationRevision.Interfaces == nil {
			break
		}

		return e.complexity.ImplementationRevision.Interfaces(childComplexity), true

	case "ImplementationRevision.metadata":
		if e.complexity.ImplementationRevision.Metadata == nil {
			break
		}

		return e.complexity.ImplementationRevision.Metadata(childComplexity), true

	case "ImplementationRevision.revision":
		if e.complexity.ImplementationRevision.Revision == nil {
			break
		}

		return e.complexity.ImplementationRevision.Revision(childComplexity), true

	case "ImplementationRevision.spec":
		if e.complexity.ImplementationRevision.Spec == nil {
			break
		}

		return e.complexity.ImplementationRevision.Spec(childComplexity), true

	case "ImplementationSpec.action":
		if e.complexity.ImplementationSpec.Action == nil {
			break
		}

		return e.complexity.ImplementationSpec.Action(childComplexity), true

	case "ImplementationSpec.additionalInput":
		if e.complexity.ImplementationSpec.AdditionalInput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalInput(childComplexity), true

	case "ImplementationSpec.additionalOutput":
		if e.complexity.ImplementationSpec.AdditionalOutput == nil {
			break
		}

		return e.complexity.ImplementationSpec.AdditionalOutput(childComplexity), true

	case "ImplementationSpec.appVersion":
		if e.complexity.ImplementationSpec.AppVersion == nil {
			break
		}

		return e.complexity.ImplementationSpec.AppVersion(childComplexity), true

	case "ImplementationSpec.implements":
		if e.complexity.ImplementationSpec.Implements == nil {
			break
		}

		return e.complexity.ImplementationSpec.Implements(childComplexity), true

	case "ImplementationSpec.imports":
		if e.complexity.ImplementationSpec.Imports == nil {
			break
		}

		return e.complexity.ImplementationSpec.Imports(childComplexity), true

	case "ImplementationSpec.outputTypeInstanceRelations":
		if e.complexity.ImplementationSpec.OutputTypeInstanceRelations == nil {
			break
		}

		return e.complexity.ImplementationSpec.OutputTypeInstanceRelations(childComplexity), true

	case "ImplementationSpec.requires":
		if e.complexity.ImplementationSpec.Requires == nil {
			break
		}

		return e.complexity.ImplementationSpec.Requires(childComplexity), true

	case "InputParameter.jsonSchema":
		if e.complexity.InputParameter.JSONSchema == nil {
			break
		}

		return e.complexity.InputParameter.JSONSchema(childComplexity), true

	case "InputParameter.name":
		if e.complexity.InputParameter.Name == nil {
			break
		}

		return e.complexity.InputParameter.Name(childComplexity), true

	case "InputParameter.typeRef":
		if e.complexity.InputParameter.TypeRef == nil {
			break
		}

		return e.complexity.InputParameter.TypeRef(childComplexity), true

	case "InputTypeInstance.name":
		if e.complexity.InputTypeInstance.Name == nil {
			break
		}

		return e.complexity.InputTypeInstance.Name(childComplexity), true

	case "InputTypeInstance.typeRef":
		if e.complexity.InputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.InputTypeInstance.TypeRef(childComplexity), true

	case "InputTypeInstance.verbs":
		if e.complexity.InputTypeInstance.Verbs == nil {
			break
		}

		return e.complexity.InputTypeInstance.Verbs(childComplexity), true

	case "Interface.latestRevision":
		if e.complexity.Interface.LatestRevision == nil {
			break
		}

		return e.complexity.Interface.LatestRevision(childComplexity), true

	case "Interface.name":
		if e.complexity.Interface.Name == nil {
			break
		}

		return e.complexity.Interface.Name(childComplexity), true

	case "Interface.path":
		if e.complexity.Interface.Path == nil {
			break
		}

		return e.complexity.Interface.Path(childComplexity), true

	case "Interface.prefix":
		if e.complexity.Interface.Prefix == nil {
			break
		}

		return e.complexity.Interface.Prefix(childComplexity), true

	case "Interface.revision":
		if e.complexity.Interface.Revision == nil {
			break
		}

		args, err := ec.field_Interface_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Interface.Revision(childComplexity, args["revision"].(string)), true

	case "Interface.revisions":
		if e.complexity.Interface.Revisions == nil {
			break
		}

		return e.complexity.Interface.Revisions(childComplexity), true

	case "InterfaceGroup.interfaces":
		if e.complexity.InterfaceGroup.Interfaces == nil {
			break
		}

		args, err := ec.field_InterfaceGroup_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InterfaceGroup.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "InterfaceGroup.metadata":
		if e.complexity.InterfaceGroup.Metadata == nil {
			break
		}

		return e.complexity.InterfaceGroup.Metadata(childComplexity), true

	case "InterfaceGroup.path":
		if e.complexity.InterfaceGroup.Path == nil {
			break
		}

		return e.complexity.InterfaceGroup.Path(childComplexity), true

	case "InterfaceInput.parameters":
		if e.complexity.InterfaceInput.Parameters == nil {
			break
		}

		return e.complexity.InterfaceInput.Parameters(childComplexity), true

	case "InterfaceInput.typeInstances":
		if e.complexity.InterfaceInput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceInput.TypeInstances(childComplexity), true

	case "InterfaceOutput.typeInstances":
		if e.complexity.InterfaceOutput.TypeInstances == nil {
			break
		}

		return e.complexity.InterfaceOutput.TypeInstances(childComplexity), true

	case "InterfaceReference.path":
		if e.complexity.InterfaceReference.Path == nil {
			break
		}

		return e.complexity.InterfaceReference.Path(childComplexity), true

	case "InterfaceReference.revision":
		if e.complexity.InterfaceReference.Revision == nil {
			break
		}

		return e.complexity.InterfaceReference.Revision(childComplexity), true

	case "InterfaceRevision.implementationRevisions":
		if e.complexity.InterfaceRevision.ImplementationRevisions == nil {
			break
		}

		return e.complexity.InterfaceRevision.ImplementationRevisions(childComplexity), true

	case "InterfaceRevision.metadata":
		if e.complexity.InterfaceRevision.Metadata == nil {
			break
		}

		return e.complexity.InterfaceRevision.Metadata(childComplexity), true

	case "InterfaceRevision.revision":
		if e.complexity.InterfaceRevision.Revision == nil {
			break
		}

		return e.complexity.InterfaceRevision.Revision(childComplexity), true

	case "InterfaceRevision.spec":
		if e.complexity.InterfaceRevision.Spec == nil {
			break
		}

		return e.complexity.InterfaceRevision.Spec(childComplexity), true

	case "InterfaceSpec.input":
		if e.complexity.InterfaceSpec.Input == nil {
			break
		}

		return e.complexity.InterfaceSpec.Input(childComplexity), true

	case "InterfaceSpec.output":
		if e.complexity.InterfaceSpec.Output == nil {
			break
		}

		return e.complexity.InterfaceSpec.Output(childComplexity), true

	case "LatestSemVerTaggingStrategy.pointsTo":
		if e.complexity.LatestSemVerTaggingStrategy.PointsTo == nil {
			break
		}

		return e.complexity.LatestSemVerTaggingStrategy.PointsTo(childComplexity), true

	case "License.name":
		if e.complexity.License.Name == nil {
			break
		}

		return e.complexity.License.Name(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Maintainer.url":
		if e.complexity.Maintainer.URL == nil {
			break
		}

		return e.complexity.Maintainer.URL(childComplexity), true

	case "OutputTypeInstance.name":
		if e.complexity.OutputTypeInstance.Name == nil {
			break
		}

		return e.complexity.OutputTypeInstance.Name(childComplexity), true

	case "OutputTypeInstance.typeRef":
		if e.complexity.OutputTypeInstance.TypeRef == nil {
			break
		}

		return e.complexity.OutputTypeInstance.TypeRef(childComplexity), true

	case "Query.attribute":
		if e.complexity.Query.Attribute == nil {
			break
		}

		args, err := ec.field_Query_attribute_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attribute(childComplexity, args["path"].(string)), true

	case "Query.attributes":
		if e.complexity.Query.Attributes == nil {
			break
		}

		args, err := ec.field_Query_attributes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Attributes(childComplexity, args["filter"].(*AttributeFilter)), true

	case "Query.implementation":
		if e.complexity.Query.Implementation == nil {
			break
		}

		args, err := ec.field_Query_implementation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementation(childComplexity, args["path"].(string)), true

	case "Query.implementations":
		if e.complexity.Query.Implementations == nil {
			break
		}

		args, err := ec.field_Query_implementations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Implementations(childComplexity, args["filter"].(*ImplementationFilter)), true

	case "Query.interface":
		if e.complexity.Query.Interface == nil {
			break
		}

		args, err := ec.field_Query_interface_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interface(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroup":
		if e.complexity.Query.InterfaceGroup == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroup(childComplexity, args["path"].(string)), true

	case "Query.interfaceGroups":
		if e.complexity.Query.InterfaceGroups == nil {
			break
		}

		args, err := ec.field_Query_interfaceGroups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InterfaceGroups(childComplexity, args["filter"].(*InterfaceGroupFilter)), true

	case "Query.interfaces":
		if e.complexity.Query.Interfaces == nil {
			break
		}

		args, err := ec.field_Query_interfaces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Interfaces(childComplexity, args["filter"].(*InterfaceFilter)), true

	case "Query.repoMetadata":
		if e.complexity.Query.RepoMetadata == nil {
			break
		}

		return e.complexity.Query.RepoMetadata(childComplexity), true

	case "Query.type":
		if e.complexity.Query.Type == nil {
			break
		}

		args, err := ec.field_Query_type_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Type(childComplexity, args["path"].(string)), true

	case "Query.types":
		if e.complexity.Query.Types == nil {
			break
		}

		args, err := ec.field_Query_types_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Types(childComplexity, args["filter"].(*TypeFilter)), true

	case "RepoImplementationAppVersionConfig.semVerTaggingStrategy":
		if e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy == nil {
			break
		}

		return e.complexity.RepoImplementationAppVersionConfig.SemVerTaggingStrategy(childComplexity), true

	case "RepoImplementationConfig.appVersion":
		if e.complexity.RepoImplementationConfig.AppVersion == nil {
			break
		}

		return e.complexity.RepoImplementationConfig.AppVersion(childComplexity), true

	case "RepoMetadata.latestRevision":
		if e.complexity.RepoMetadata.LatestRevision == nil {
			break
		}

		return e.complexity.RepoMetadata.LatestRevision(childComplexity), true

	case "RepoMetadata.name":
		if e.complexity.RepoMetadata.Name == nil {
			break
		}

		return e.complexity.RepoMetadata.Name(childComplexity), true

	case "RepoMetadata.path":
		if e.complexity.RepoMetadata.Path == nil {
			break
		}

		return e.complexity.RepoMetadata.Path(childComplexity), true

	case "RepoMetadata.prefix":
		if e.complexity.RepoMetadata.Prefix == nil {
			break
		}

		return e.complexity.RepoMetadata.Prefix(childComplexity), true

	case "RepoMetadata.revision":
		if e.complexity.RepoMetadata.Revision == nil {
			break
		}

		args, err := ec.field_RepoMetadata_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RepoMetadata.Revision(childComplexity, args["revision"].(string)), true

	case "RepoMetadata.revisions":
		if e.complexity.RepoMetadata.Revisions == nil {
			break
		}

		return e.complexity.RepoMetadata.Revisions(childComplexity), true

	case "RepoMetadataRevision.metadata":
		if e.complexity.RepoMetadataRevision.Metadata == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Metadata(childComplexity), true

	case "RepoMetadataRevision.revision":
		if e.complexity.RepoMetadataRevision.Revision == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Revision(childComplexity), true

	case "RepoMetadataRevision.spec":
		if e.complexity.RepoMetadataRevision.Spec == nil {
			break
		}

		return e.complexity.RepoMetadataRevision.Spec(childComplexity), true

	case "RepoMetadataSpec.hubVersion":
		if e.complexity.RepoMetadataSpec.HubVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.HubVersion(childComplexity), true

	case "RepoMetadataSpec.implementation":
		if e.complexity.RepoMetadataSpec.Implementation == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.Implementation(childComplexity), true

	case "RepoMetadataSpec.ocfVersion":
		if e.complexity.RepoMetadataSpec.OcfVersion == nil {
			break
		}

		return e.complexity.RepoMetadataSpec.OcfVersion(childComplexity), true

	case "RepoOCFVersion.default":
		if e.complexity.RepoOCFVersion.Default == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Default(childComplexity), true

	case "RepoOCFVersion.supported":
		if e.complexity.RepoOCFVersion.Supported == nil {
			break
		}

		return e.complexity.RepoOCFVersion.Supported(childComplexity), true

	case "SemVerTaggingStrategy.latest":
		if e.complexity.SemVerTaggingStrategy.Latest == nil {
			break
		}

		return e.complexity.SemVerTaggingStrategy.Latest(childComplexity), true

	case "Type.latestRevision":
		if e.complexity.Type.LatestRevision == nil {
			break
		}

		return e.complexity.Type.LatestRevision(childComplexity), true

	case "Type.name":
		if e.complexity.Type.Name == nil {
			break
		}

		return e.complexity.Type.Name(childComplexity), true

	case "Type.path":
		if e.complexity.Type.Path == nil {
			break
		}

		return e.complexity.Type.Path(childComplexity), true

	case "Type.prefix":
		if e.complexity.Type.Prefix == nil {
			break
		}

		return e.complexity.Type.Prefix(childComplexity), true

	case "Type.revision":
		if e.complexity.Type.Revision == nil {
			break
		}

		args, err := ec.field_Type_revision_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Type.Revision(childComplexity, args["revision"].(string)), true

	case "Type.revisions":
		if e.complexity.Type.Revisions == nil {
			break
		}

		return e.complexity.Type.Revisions(childComplexity), true

	case "TypeInstanceRelationItem.typeInstanceName":
		if e.complexity.TypeInstanceRelationItem.TypeInstanceName == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.TypeInstanceName(childComplexity), true

	case "TypeInstanceRelationItem.uses":
		if e.complexity.TypeInstanceRelationItem.Uses == nil {
			break
		}

		return e.complexity.TypeInstanceRelationItem.Uses(childComplexity), true

	case "TypeMetadata.attributes":
		if e.complexity.TypeMetadata.Attributes == nil {
			break
		}

		return e.complexity.TypeMetadata.Attributes(childComplexity), true

	case "TypeMetadata.description":
		if e.complexity.TypeMetadata.Description == nil {
			break
		}

		return e.complexity.TypeMetadata.Description(childComplexity), true

	case "TypeMetadata.displayName":
		if e.complexity.TypeMetadata.DisplayName == nil {
			break
		}

		return e.complexity.TypeMetadata.DisplayName(childComplexity), true

	case "TypeMetadata.documentationURL":
		if e.complexity.TypeMetadata.DocumentationURL == nil {
			break
		}

		return e.complexity.TypeMetadata.DocumentationURL(childComplexity), true

	case "TypeMetadata.iconURL":
		if e.complexity.TypeMetadata.IconURL == nil {
			break
		}

		return e.complexity.TypeMetadata.IconURL(childComplexity), true

	case "TypeMetadata.maintainers":
		if e.complexity.TypeMetadata.Maintainers == nil {
			break
		}

		return e.complexity.TypeMetadata.Maintainers(childComplexity), true

	case "TypeMetadata.name":
		if e.complexity.TypeMetadata.Name == nil {
			break
		}

		return e.complexity.TypeMetadata.Name(childComplexity), true

	case "TypeMetadata.path":
		if e.complexity.TypeMetadata.Path == nil {
			break
		}

		return e.complexity.TypeMetadata.Path(childComplexity), true

	case "TypeMetadata.prefix":
		if e.complexity.TypeMetadata.Prefix == nil {
			break
		}

		return e.complexity.TypeMetadata.Prefix(childComplexity), true

	case "TypeMetadata.supportURL":
		if e.complexity.TypeMetadata.SupportURL == nil {
			break
		}

		return e.complexity.TypeMetadata.SupportURL(childComplexity), true

	case "TypeReference.path":
		if e.complexity.TypeReference.Path == nil {
			break
		}

		return e.complexity.TypeReference.Path(childComplexity), true

	case "TypeReference.revision":
		if e.complexity.TypeReference.Revision == nil {
			break
		}

		return e.complexity.TypeReference.Revision(childComplexity), true

	case "TypeRevision.metadata":
		if e.complexity.TypeRevision.Metadata == nil {
			break
		}

		return e.complexity.TypeRevision.Metadata(childComplexity), true

	case "TypeRevision.revision":
		if e.complexity.TypeRevision.Revision == nil {
			break
		}

		return e.complexity.TypeRevision.Revision(childComplexity), true

	case "TypeRevision.spec":
		if e.complexity.TypeRevision.Spec == nil {
			break
		}

		return e.complexity.TypeRevision.Spec(childComplexity), true

	case "TypeSpec.additionalRefs":
		if e.complexity.TypeSpec.AdditionalRefs == nil {
			break
		}

		return e.complexity.TypeSpec.AdditionalRefs(childComplexity), true

	case "TypeSpec.jsonSchema":
		if e.complexity.TypeSpec.JSONSchema == nil {
			break
		}

		return e.complexity.TypeSpec.JSONSchema(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../../hub-js/graphql/public/schema.graphql", Input: `# Neo4j-graphql-js adds some directives during parsing of the schema.
# To make it work for other GraphQL clients, we need to add them to the schema manually, based on:
# https://github.com/neo4j-graphql/neo4j-graphql-js/blob/master/src/augment/directives.js
directive @relation(
  name: String
  direction: String
  from: String
  to: String
) on FIELD_DEFINITION | OBJECT
directive @additionalLabels(labels: [String]) on OBJECT
directive @cypher(statement: String) on FIELD_DEFINITION
directive @index on FIELD_DEFINITION

"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Pattern of the path of a given node, e.g. cap.core.type.platform.*
"""
scalar NodePathPattern

"""
Path for the parent node, e.g. for Interface it is InterfaceGroup path.
"""
scalar NodePrefix

"""
Name of a given node. Name is immutable between different revisions of a given node.
"""
scalar NodeName

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

"""
Range of versions, e.g. "1.14.x, 1.15.0 - 1.15.3"
"""
scalar VersionRange

input InterfaceFilter {
  pathPattern: NodePathPattern
}

input ImplementationFilter {
  pathPattern: NodePathPattern
}

# TODO: Enable lint rule once the InterfaceRevision.implementationRevisionsForRequirements is implemented
# lint-disable defined-types-are-used
"""
Dedicated input type for filtering ImplementationRevisions in future resolver
` + "`" + `InterfaceRevision.implementationRevisionsForRequirements` + "`" + `.

Currently used only for Hub Go client package as the server-side resolver is not implemented.
"""
input ImplementationRevisionFilter {
  pathPattern: NodePathPattern

  """
  If provided, Implementations are filtered by the ones that have satisfied requirements with provided TypeInstance values.
  For example, to find all Implementations that can be run on a given system, user can provide values of all existing TypeInstances.
  """
  requirementsSatisfiedBy: [TypeInstanceValue!]

  """
  Filter by Implementations, which have requirements injection satisfied.
  If provided, all TypeInstance values are merged into ` + "`" + `requirementsSatisfiedBy` + "`" + ` filter values, and, in a result,
  both filters ` + "`" + `requirementsSatisfiedBy` + "`" + ` and ` + "`" + `requiredTypeInstancesInjectionSatisfiedBy` + "`" + ` are used.
  """
  requiredTypeInstancesInjectionSatisfiedBy: [TypeInstanceValue]

  attributes: [AttributeFilterInput!]

  """
  If provided, the ImplementationRevisions for a given Interface will be filtered
  according to provided Type references looked up in the ` + "`" + `Implementation.spec.requires` + "`" + ` field.

  For every item in the array, the returned ImplementationRevisions must specify
  such TypeReference in ` + "`" + `Implementation.spec.requires` + "`" + ` in any of the sections: oneOf, anyOf or allOf.
  """
  requires: [TypeReferenceWithOptionalRevision]
}
# lint-enable defined-types-are-used

input TypeInstanceValue {
  typeRef: TypeReferenceInput!

  """
  Currently not supported.
  Value of the available requirement. If not provided, all valueConstraints conditions are treated as satisfied.
  """
  value: Any
}

input TypeReferenceWithOptionalRevision {
  path: NodePath!
  revision: Version
}

input TypeReferenceInput {
  path: NodePath!
  revision: Version!
}

input AttributeFilterInput {
  path: NodePath!
  rule: FilterRule = INCLUDE

  """
  If not provided, any revision of the Attribute applies to this filter
  """
  revision: Version
}

enum FilterRule {
  INCLUDE
  EXCLUDE
}

input InterfaceGroupFilter {
  pathPattern: NodePathPattern
}

input AttributeFilter {
  pathPattern: NodePathPattern
}

input TypeFilter {
  pathPattern: NodePathPattern
}

type RepoMetadata @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published {revision: $revision}) RETURN r"
    )
  revisions: [RepoMetadataRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type RepoMetadataRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: RepoMetadataSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type RepoMetadataSpec @additionalLabels(labels: ["published"]) {
  hubVersion: Version!
  ocfVersion: RepoOCFVersion! @relation(name: "SUPPORTS", direction: "OUT")
  implementation: RepoImplementationConfig!
    @relation(name: "CONFIGURED", direction: "OUT")
}

type RepoImplementationConfig @additionalLabels(labels: ["published"]) {
  appVersion: RepoImplementationAppVersionConfig!
    @relation(name: "APP_VERSION", direction: "OUT")
}

type RepoImplementationAppVersionConfig
  @additionalLabels(labels: ["published"]) {
  semVerTaggingStrategy: SemVerTaggingStrategy!
    @relation(name: "TAGGING_STRATEGY", direction: "OUT")
}

type SemVerTaggingStrategy @additionalLabels(labels: ["published"]) {
  latest: LatestSemVerTaggingStrategy!
    @relation(name: "LATEST", direction: "OUT")
}

type LatestSemVerTaggingStrategy @additionalLabels(labels: ["published"]) {
  pointsTo: SemVerTaggingStrategyTags!
}

enum SemVerTaggingStrategyTags {
  STABLE
  EDGE
}

type RepoOCFVersion @additionalLabels(labels: ["published"]) {
  supported: [Version!]!
  default: Version!
}

type InterfaceGroup @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  interfaces(filter: InterfaceFilter): [Interface!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type Interface @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published {revision: $revision}) RETURN ir"
    )
  revisions: [InterfaceRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type InterfaceRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: InterfaceSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")

  implementationRevisions: [ImplementationRevision!]!
    @relation(name: "IMPLEMENTS", direction: "IN")

  # TODO: Reimplement the resolver:
  # implementationRevisionsForRequirements(filter: ImplementationRevisionFilter): [ImplementationRevision!]!
  # See the initial implementation: https://github.com/capactio/capact/commit/18bded8aed9d4e7b8a90d23ffc17134d920290e0#diff-73bc98d8e409e7044514f7af22931d76cb7da73504c678421c398f0c0501ef92R203
}

type InterfaceSpec @additionalLabels(labels: ["published"]) {
  input: InterfaceInput! @relation(name: "HAS_INPUT", direction: "OUT")
  output: InterfaceOutput! @relation(name: "OUTPUTS", direction: "OUT")
}

type InterfaceInput @additionalLabels(labels: ["published"]) {
  parameters: [InputParameter!]! @relation(name: "HAS", direction: "OUT")
  typeInstances: [InputTypeInstance]! @relation(name: "HAS", direction: "OUT")
}

type InputParameter @additionalLabels(labels: ["published"]) {
  name: String!
  jsonSchema: Any
  typeRef: TypeReference @relation(name: "OF_TYPE", direction: "OUT")
}

type InterfaceOutput @additionalLabels(labels: ["published"]) {
  typeInstances: [OutputTypeInstance]!
    @relation(name: "OUTPUTS", direction: "OUT")
}

interface TypeInstanceFields {
  name: String!
  typeRef: TypeReference!
}

type InputTypeInstance implements TypeInstanceFields
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
  verbs: [TypeInstanceOperationVerb!]!
    @cypher(
      statement: """
      MATCH (this)
      RETURN [verb IN this.verbs | toUpper(verb)] as verbs
      """
    )
}

enum TypeInstanceOperationVerb {
  CREATE
  GET
  LIST
  UPDATE
  DELETE
}

type OutputTypeInstance implements TypeInstanceFields
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
}

type Type @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r {revision: $revision}) RETURN r"
    )
  revisions: [TypeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type TypeRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: TypeMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: TypeSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type TypeSpec @additionalLabels(labels: ["published"]) {
  additionalRefs: [NodePath!]
  jsonSchema: Any
}

type Implementation @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published {revision: $revision}) RETURN ir"
    )
  revisions: [ImplementationRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  metadata: ImplementationMetadata!
    @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: ImplementationSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  interfaces: [InterfaceRevision!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
}

type ImplementationSpec @additionalLabels(labels: ["published"]) {
  appVersion: VersionRange! @index

  implements: [InterfaceReference!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
  requires: [ImplementationRequirement!]!
    @relation(name: "REQUIRES", direction: "OUT")
  imports: [ImplementationImport!] @relation(name: "IMPORTS", direction: "OUT")
  action: ImplementationAction! @relation(name: "DOES", direction: "OUT")
  additionalInput: ImplementationAdditionalInput
    @relation(name: "USES", direction: "OUT")
  additionalOutput: ImplementationAdditionalOutput
    @relation(name: "OUTPUTS", direction: "OUT")
  outputTypeInstanceRelations: [TypeInstanceRelationItem!]!
    @relation(name: "RELATIONS", direction: "OUT")
}

type ImplementationAdditionalInput @additionalLabels(labels: ["published"]) {
  typeInstances: [InputTypeInstance!]
    @relation(name: "CONTAINS", direction: "OUT")
  parameters: [ImplementationAdditionalInputParameter!]
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationAdditionalInputParameter
  @additionalLabels(labels: ["published"]) {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
}

type ImplementationAdditionalOutput @additionalLabels(labels: ["published"]) {
  typeInstances: [OutputTypeInstance!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type TypeInstanceRelationItem @additionalLabels(labels: ["published"]) {
  typeInstanceName: String!

  """
  Contains list of Type Instance names, which a given TypeInstance uses (depends on)
  """
  uses: [String!]
}

type InterfaceReference @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  revision: Version! @index
}

type ImplementationRequirement @additionalLabels(labels: ["published"]) {
  prefix: NodePrefix!
  oneOf: [ImplementationRequirementItem!]!
    @relation(name: "ONE_OF", direction: "OUT")
  anyOf: [ImplementationRequirementItem!]!
    @relation(name: "ANY_OF", direction: "OUT")
  allOf: [ImplementationRequirementItem!]!
    @relation(name: "ALL_OF", direction: "OUT")
}

type ImplementationRequirementItem @additionalLabels(labels: ["published"]) {
  typeRef: TypeReference! @relation(name: "REFERENCES_TYPE", direction: "OUT")

  """
  Holds the configuration constraints for the given entry based on Type value.
  Currently not supported.
  """
  valueConstraints: Any

  """
  If provided, the TypeInstance of the Type, configured in policy, is injected to the workflow under the alias.
  """
  alias: String
}

type TypeReference @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  revision: Version! @index
}

type ImplementationImport @additionalLabels(labels: ["published"]) {
  interfaceGroupPath: NodePath!
  alias: String
  appVersion: VersionRange

  methods: [ImplementationImportMethod!]!
    @relation(name: "HAS", direction: "OUT")
}

type ImplementationImportMethod @additionalLabels(labels: ["published"]) {
  name: NodeName!

  """
  If not provided, latest revision for a given Interface is used
  """
  revision: Version
}

type ImplementationAction @additionalLabels(labels: ["published"]) {
  """
  The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
  """
  runnerInterface: String!
  args: Any
    @cypher(
      statement: """
      MATCH (this) RETURN apoc.convert.fromJsonMap(this.args) as args
      """
    )
}

type Attribute @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix! @index

  latestRevision: AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 2"
    )
  revision(revision: Version!): AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published {revision: $revision}) RETURN r"
    )
  revisions: [AttributeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type AttributeRevision @additionalLabels(labels: ["published"]) {
  revision: Version! @index

  spec: AttributeSpec @relation(name: "SPECIFIED_BY", direction: "OUT")
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
}

# It is defined to make sure that all metadata types have the same base fields.
# Unfortunately all Types that implement an Interface have to repeat the same fields,
# however it's the only way to do so.
interface MetadataBaseFields {
  name: NodeName
  prefix: NodePrefix
  path: NodePath
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type GenericMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type ImplementationMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  license: License! @relation(name: "LICENSED_WITH", direction: "OUT")
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type TypeMetadata implements MetadataBaseFields
  @additionalLabels(labels: ["published"]) {
  path: NodePath! @index
  name: NodeName! @index
  prefix: NodePrefix @index
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type License @additionalLabels(labels: ["published"]) {
  name: String! @index
}

type Maintainer @additionalLabels(labels: ["published"]) {
  name: String @index
  email: String! @index
  url: String
}

type AttributeSpec @additionalLabels(labels: ["published"]) {
  additionalRefs: [NodePath!]!
}

type Query @additionalLabels(labels: ["published"]) {
  repoMetadata: RepoMetadata

  interfaceGroups(filter: InterfaceGroupFilter = {}): [InterfaceGroup!]!
    @cypher(
      statement: """
      MATCH (this:InterfaceGroup:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  interfaceGroup(path: NodePath!): InterfaceGroup

  interfaces(filter: InterfaceFilter = {}): [Interface!]!
    @cypher(
      statement: """
      MATCH (this:Interface:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  interface(path: NodePath!): Interface

  types(filter: TypeFilter = {}): [Type!]!
    @cypher(
      statement: """
      // Find all children associated with a given path pattern
      OPTIONAL MATCH (b:VirtualType:published)-[:CONTAINS]->(children:Type:published)
      WHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = "*" OR b.path =~ $filter.pathPattern

      WITH children

      // Find all specific Types that matches a given pattern
      MATCH (type:Type:published)
      WHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = "*" OR type.path =~ $filter.pathPattern

      // Flat collection of specify Types and attached children
      UNWIND [type, children] AS res

      WITH res
      // OPTIONAL MATCH may produce NULL values
      WHERE res is NOT NULL
      // Get rid of duplicates
      RETURN DISTINCT res
      """
    )
  type(path: NodePath!): Type

  implementations(filter: ImplementationFilter = {}): [Implementation!]!
    @cypher(
      statement: """
      MATCH (this:Implementation:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )

  implementation(path: NodePath!): Implementation

  attributes(filter: AttributeFilter = {}): [Attribute!]!
    @cypher(
      statement: """
      MATCH (this:Attribute:published)
      WHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this
      """
    )
  attribute(path: NodePath!): Attribute
}

# TODO: Prepare directive for user authorization in https://github.com/capactio/capact/issues/508
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_additionalLabels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["labels"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) dir_cypher_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["statement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statement"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["statement"] = arg0
	return args, nil
}

func (ec *executionContext) dir_relation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["direction"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["direction"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["from"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["to"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["to"] = arg3
	return args, nil
}

func (ec *executionContext) field_Attribute_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Implementation_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_InterfaceGroup_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2capactiocapactpkghubapigraphqlpublicInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Interface_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attribute_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_attributes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *AttributeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOAttributeFilter2capactiocapactpkghubapigraphqlpublicAttributeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_implementations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ImplementationFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOImplementationFilter2capactiocapactpkghubapigraphqlpublicImplementationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaceGroups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceGroupFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceGroupFilter2capactiocapactpkghubapigraphqlpublicInterfaceGroupFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interface_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_interfaces_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *InterfaceFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOInterfaceFilter2capactiocapactpkghubapigraphqlpublicInterfaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
		arg0, err = ec.unmarshalNNodePath2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_types_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TypeFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTypeFilter2capactiocapactpkghubapigraphqlpublicTypeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_RepoMetadata_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field_Type_revision_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["revision"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
		arg0, err = ec.unmarshalNVersion2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["revision"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Attribute_path(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_name(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_prefix(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 2")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revision(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Attribute_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Attribute().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r:AttributeRevision:published {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeRevision)
	fc.Result = res
	return ec.marshalOAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Attribute_revisions(ctx context.Context, field graphql.CollectedField, obj *Attribute) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Attribute",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AttributeSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.AttributeSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AttributeSpec)
	fc.Result = res
	return ec.marshalOAttributeSpec2capactiocapactpkghubapigraphqlpublicAttributeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *AttributeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2capactiocapactpkghubapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _AttributeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *AttributeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AttributeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_path(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_name(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_description(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GenericMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *GenericMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "GenericMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_path(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_name(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_prefix(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revision(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Implementation_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Implementation().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision:published {revision: $revision}) RETURN ir")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationRevision)
	fc.Result = res
	return ec.marshalOImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Implementation_revisions(ctx context.Context, field graphql.CollectedField, obj *Implementation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Implementation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_runnerInterface(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunnerInterface, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAction_args(ctx context.Context, field graphql.CollectedField, obj *ImplementationAction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Args, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this) RETURN apoc.convert.fromJsonMap(this.args) as args")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive0, statement)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(interface{}); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be interface{}`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalOInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInput_parameters(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Parameters, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationAdditionalInputParameter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalInputParameter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ImplementationAdditionalInputParameter)
	fc.Result = res
	return ec.marshalOImplementationAdditionalInputParameter2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInputParameter(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInputParameter_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalInputParameter_typeRef(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalInputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalInputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationAdditionalOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *ImplementationAdditionalOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationAdditionalOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*OutputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.OutputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_interfaceGroupPath(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterfaceGroupPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersionRange2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImport_methods(ctx context.Context, field graphql.CollectedField, obj *ImplementationImport) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImport",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Methods, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationImportMethod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationImportMethod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImportMethod)
	fc.Result = res
	return ec.marshalNImplementationImportMethod2capactiocapactpkghubapigraphqlpublicImplementationImportMethod(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationImportMethod_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationImportMethod) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationImportMethod",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_path(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_name(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_description(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_license(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.License, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "LICENSED_WITH")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*License); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.License`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*License)
	fc.Result = res
	return ec.marshalNLicense2capactiocapactpkghubapigraphqlpublicLicense(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *ImplementationMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Attributes, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CHARACTERIZED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_prefix(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_oneOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OneOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "ONE_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_anyOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AnyOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "ANY_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirement_allOf(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirement) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirement",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AllOf, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "ALL_OF")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirementItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirementItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirementItem)
	fc.Result = res
	return ec.marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_typeRef(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "REFERENCES_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_valueConstraints(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValueConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRequirementItem_alias(ctx context.Context, field graphql.CollectedField, obj *ImplementationRequirementItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRequirementItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_revision(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationMetadata)
	fc.Result = res
	return ec.marshalNImplementationMetadata2capactiocapactpkghubapigraphqlpublicImplementationMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_spec(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationSpec)
	fc.Result = res
	return ec.marshalNImplementationSpec2capactiocapactpkghubapigraphqlpublicImplementationSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationRevision_interfaces(ctx context.Context, field graphql.CollectedField, obj *ImplementationRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.ImplementationRevision().Interfaces(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceRevision)
	fc.Result = res
	return ec.marshalNInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_appVersion(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionRange2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_implements(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Implements, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceReference)
	fc.Result = res
	return ec.marshalNInterfaceReference2capactiocapactpkghubapigraphqlpublicInterfaceReference(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_requires(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Requires, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "REQUIRES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRequirement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRequirement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRequirement)
	fc.Result = res
	return ec.marshalNImplementationRequirement2capactiocapactpkghubapigraphqlpublicImplementationRequirement(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_imports(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Imports, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "IMPORTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationImport); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationImport`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ImplementationImport)
	fc.Result = res
	return ec.marshalOImplementationImport2capactiocapactpkghubapigraphqlpublicImplementationImport(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_action(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Action, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DOES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImplementationAction)
	fc.Result = res
	return ec.marshalNImplementationAction2capactiocapactpkghubapigraphqlpublicImplementationAction(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalInput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdditionalInput, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "USES")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAdditionalInput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalInput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalInput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalInput2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_additionalOutput(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AdditionalOutput, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ImplementationAdditionalOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.ImplementationAdditionalOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ImplementationAdditionalOutput)
	fc.Result = res
	return ec.marshalOImplementationAdditionalOutput2capactiocapactpkghubapigraphqlpublicImplementationAdditionalOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _ImplementationSpec_outputTypeInstanceRelations(ctx context.Context, field graphql.CollectedField, obj *ImplementationSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ImplementationSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OutputTypeInstanceRelations, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "RELATIONS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeInstanceRelationItem); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.TypeInstanceRelationItem`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeInstanceRelationItem)
	fc.Result = res
	return ec.marshalNTypeInstanceRelationItem2capactiocapactpkghubapigraphqlpublicTypeInstanceRelationItem(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_name(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) _InputParameter_typeRef(ctx context.Context, field graphql.CollectedField, obj *InputParameter) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputParameter",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalOTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _InputTypeInstance_verbs(ctx context.Context, field graphql.CollectedField, obj *InputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Verbs, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)\nRETURN [verb IN this.verbs | toUpper(verb)] as verbs")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive0, statement)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]TypeInstanceOperationVerb); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []capact.io/capact/pkg/hub/api/graphql/public.TypeInstanceOperationVerb`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]TypeInstanceOperationVerb)
	fc.Result = res
	return ec.marshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_path(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_name(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_prefix(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published) RETURN ir ORDER BY ir.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revision(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Interface_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Interface().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision:published {revision: $revision}) RETURN ir")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceRevision)
	fc.Result = res
	return ec.marshalOInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Interface_revisions(ctx context.Context, field graphql.CollectedField, obj *Interface) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Interface",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceRevision)
	fc.Result = res
	return ec.marshalNInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_path(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2capactiocapactpkghubapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceGroup_interfaces(ctx context.Context, field graphql.CollectedField, obj *InterfaceGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceGroup",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_InterfaceGroup_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.InterfaceGroup().Interfaces(rctx, obj, args["filter"].(*InterfaceFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_parameters(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Parameters, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputParameter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputParameter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputParameter)
	fc.Result = res
	return ec.marshalNInputParameter2capactiocapactpkghubapigraphqlpublicInputParameter(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceInput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceInput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceInput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "HAS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InputTypeInstance)
	fc.Result = res
	return ec.marshalNInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceOutput_typeInstances(ctx context.Context, field graphql.CollectedField, obj *InterfaceOutput) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceOutput",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeInstances, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*OutputTypeInstance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.OutputTypeInstance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*OutputTypeInstance)
	fc.Result = res
	return ec.marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_path(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceReference_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_revision(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2capactiocapactpkghubapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_spec(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceSpec)
	fc.Result = res
	return ec.marshalNInterfaceSpec2capactiocapactpkghubapigraphqlpublicInterfaceSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceRevision_implementationRevisions(ctx context.Context, field graphql.CollectedField, obj *InterfaceRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ImplementationRevisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "IMPLEMENTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "IN")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ImplementationRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.ImplementationRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ImplementationRevision)
	fc.Result = res
	return ec.marshalNImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_input(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Input, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "HAS_INPUT")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceInput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceInput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceInput)
	fc.Result = res
	return ec.marshalNInterfaceInput2capactiocapactpkghubapigraphqlpublicInterfaceInput(ctx, field.Selections, res)
}

func (ec *executionContext) _InterfaceSpec_output(ctx context.Context, field graphql.CollectedField, obj *InterfaceSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "InterfaceSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Output, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OUTPUTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*InterfaceOutput)
	fc.Result = res
	return ec.marshalNInterfaceOutput2capactiocapactpkghubapigraphqlpublicInterfaceOutput(ctx, field.Selections, res)
}

func (ec *executionContext) _LatestSemVerTaggingStrategy_pointsTo(ctx context.Context, field graphql.CollectedField, obj *LatestSemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "LatestSemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointsTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(SemVerTaggingStrategyTags)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategyTags2capactiocapactpkghubapigraphqlpublicSemVerTaggingStrategyTags(ctx, field.Selections, res)
}

func (ec *executionContext) _License_name(ctx context.Context, field graphql.CollectedField, obj *License) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "License",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Email, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_url(ctx context.Context, field graphql.CollectedField, obj *Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Maintainer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_name(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OutputTypeInstance_typeRef(ctx context.Context, field graphql.CollectedField, obj *OutputTypeInstance) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "OutputTypeInstance",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeRef, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "OF_TYPE")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeReference); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeReference`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeReference)
	fc.Result = res
	return ec.marshalNTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_repoMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RepoMetadata(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadata)
	fc.Result = res
	return ec.marshalORepoMetadata2capactiocapactpkghubapigraphqlpublicRepoMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroups_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InterfaceGroups(rctx, args["filter"].(*InterfaceGroupFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this:InterfaceGroup:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InterfaceGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.InterfaceGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*InterfaceGroup)
	fc.Result = res
	return ec.marshalNInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaceGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaceGroup_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InterfaceGroup(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*InterfaceGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.InterfaceGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*InterfaceGroup)
	fc.Result = res
	return ec.marshalOInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interfaces(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interfaces_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interfaces(rctx, args["filter"].(*InterfaceFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this:Interface:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Interface)
	fc.Result = res
	return ec.marshalNInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_interface(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_interface_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Interface(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Interface); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Interface`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Interface)
	fc.Result = res
	return ec.marshalOInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_types(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_types_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Types(rctx, args["filter"].(*TypeFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "// Find all children associated with a given path pattern\nOPTIONAL MATCH (b:VirtualType:published)-[:CONTAINS]->(children:Type:published)\nWHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = \"*\" OR b.path =~ $filter.pathPattern\n\nWITH children\n\n// Find all specific Types that matches a given pattern\nMATCH (type:Type:published)\nWHERE $filter = {} OR $filter.pathPattern IS NULL OR $filter.pathPattern = \"*\" OR type.path =~ $filter.pathPattern\n\n// Flat collection of specify Types and attached children\nUNWIND [type, children] AS res\n\nWITH res\n// OPTIONAL MATCH may produce NULL values\nWHERE res is NOT NULL\n// Get rid of duplicates\nRETURN DISTINCT res")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Type); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Type`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Type)
	fc.Result = res
	return ec.marshalNType2capactiocapactpkghubapigraphqlpublicType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Type(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Type); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Type`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Type)
	fc.Result = res
	return ec.marshalOType2capactiocapactpkghubapigraphqlpublicType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementations_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Implementations(rctx, args["filter"].(*ImplementationFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this:Implementation:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Implementation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Implementation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Implementation)
	fc.Result = res
	return ec.marshalNImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_implementation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_implementation_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Implementation(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Implementation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Implementation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Implementation)
	fc.Result = res
	return ec.marshalOImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attributes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attributes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Attributes(rctx, args["filter"].(*AttributeFilter))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this:Attribute:published)\nWHERE $filter = {} OR this.path =~ $filter.pathPattern RETURN this")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, nil, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Attribute); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Attribute`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Attribute)
	fc.Result = res
	return ec.marshalNAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_attribute(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_attribute_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Attribute(rctx, args["path"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, nil, directive0, labels)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Attribute); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.Attribute`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Attribute)
	fc.Result = res
	return ec.marshalOAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationAppVersionConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationAppVersionConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.SemVerTaggingStrategy, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "TAGGING_STRATEGY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SemVerTaggingStrategy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.SemVerTaggingStrategy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNSemVerTaggingStrategy2capactiocapactpkghubapigraphqlpublicSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoImplementationConfig_appVersion(ctx context.Context, field graphql.CollectedField, obj *RepoImplementationConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoImplementationConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "APP_VERSION")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoImplementationAppVersionConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoImplementationAppVersionConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationAppVersionConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationAppVersionConfig2capactiocapactpkghubapigraphqlpublicRepoImplementationAppVersionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_path(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_name(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_latestRevision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published) RETURN r ORDER BY r.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_RepoMetadata_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.RepoMetadata().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision:published {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalORepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadata_revisions(ctx context.Context, field graphql.CollectedField, obj *RepoMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*RepoMetadataRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*RepoMetadataRevision)
	fc.Result = res
	return ec.marshalNRepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_revision(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GenericMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.GenericMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GenericMetadata)
	fc.Result = res
	return ec.marshalNGenericMetadata2capactiocapactpkghubapigraphqlpublicGenericMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataRevision_spec(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoMetadataSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoMetadataSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoMetadataSpec)
	fc.Result = res
	return ec.marshalNRepoMetadataSpec2capactiocapactpkghubapigraphqlpublicRepoMetadataSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_hubVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_ocfVersion(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.OcfVersion, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SUPPORTS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoOCFVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoOCFVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoOCFVersion)
	fc.Result = res
	return ec.marshalNRepoOCFVersion2capactiocapactpkghubapigraphqlpublicRepoOCFVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoMetadataSpec_implementation(ctx context.Context, field graphql.CollectedField, obj *RepoMetadataSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoMetadataSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Implementation, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONFIGURED")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RepoImplementationConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.RepoImplementationConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoImplementationConfig)
	fc.Result = res
	return ec.marshalNRepoImplementationConfig2capactiocapactpkghubapigraphqlpublicRepoImplementationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_supported(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepoOCFVersion_default(ctx context.Context, field graphql.CollectedField, obj *RepoOCFVersion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RepoOCFVersion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SemVerTaggingStrategy_latest(ctx context.Context, field graphql.CollectedField, obj *SemVerTaggingStrategy) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "SemVerTaggingStrategy",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Latest, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "LATEST")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*LatestSemVerTaggingStrategy); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.LatestSemVerTaggingStrategy`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LatestSemVerTaggingStrategy)
	fc.Result = res
	return ec.marshalNLatestSemVerTaggingStrategy2capactiocapactpkghubapigraphqlpublicLatestSemVerTaggingStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_path(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_name(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_prefix(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_latestRevision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LatestRevision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r) RETURN r ORDER BY r.revision DESC LIMIT 1")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revision(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Type_revision_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Type().Revision(rctx, obj, args["revision"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			statement, err := ec.unmarshalOString2string(ctx, "MATCH (this)-[:CONTAINS]->(r {revision: $revision}) RETURN r")
			if err != nil {
				return nil, err
			}
			if ec.directives.Cypher == nil {
				return nil, errors.New("directive cypher is not implemented")
			}
			return ec.directives.Cypher(ctx, obj, directive1, statement)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeRevision)
	fc.Result = res
	return ec.marshalOTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _Type_revisions(ctx context.Context, field graphql.CollectedField, obj *Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Type",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revisions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CONTAINS")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.TypeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeRevision)
	fc.Result = res
	return ec.marshalNTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_typeInstanceName(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeInstanceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeInstanceRelationItem_uses(ctx context.Context, field graphql.CollectedField, obj *TypeInstanceRelationItem) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeInstanceRelationItem",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_path(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_name(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodeName2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_prefix(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Prefix, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalONodePrefix2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_description(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_maintainers(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Maintainers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "MAINTAINED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Maintainer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.Maintainer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_documentationURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentationURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_supportURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_iconURL(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeMetadata_attributes(ctx context.Context, field graphql.CollectedField, obj *TypeMetadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeMetadata",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Attributes, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "CHARACTERIZED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*AttributeRevision); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*capact.io/capact/pkg/hub/api/graphql/public.AttributeRevision`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AttributeRevision)
	fc.Result = res
	return ec.marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_path(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNNodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeReference_revision(ctx context.Context, field graphql.CollectedField, obj *TypeReference) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeReference",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_revision(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Revision, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Index == nil {
				return nil, errors.New("directive index is not implemented")
			}
			return ec.directives.Index(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersion2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_metadata(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Metadata, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "DESCRIBED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeMetadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeMetadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeMetadata)
	fc.Result = res
	return ec.marshalNTypeMetadata2capactiocapactpkghubapigraphqlpublicTypeMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeRevision_spec(ctx context.Context, field graphql.CollectedField, obj *TypeRevision) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeRevision",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Spec, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			labels, err := ec.unmarshalOString2string(ctx, []interface{}{"published"})
			if err != nil {
				return nil, err
			}
			if ec.directives.AdditionalLabels == nil {
				return nil, errors.New("directive additionalLabels is not implemented")
			}
			return ec.directives.AdditionalLabels(ctx, obj, directive0, labels)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalOString2string(ctx, "SPECIFIED_BY")
			if err != nil {
				return nil, err
			}
			direction, err := ec.unmarshalOString2string(ctx, "OUT")
			if err != nil {
				return nil, err
			}
			if ec.directives.Relation == nil {
				return nil, errors.New("directive relation is not implemented")
			}
			return ec.directives.Relation(ctx, obj, directive1, name, direction, nil, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeSpec); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *capact.io/capact/pkg/hub/api/graphql/public.TypeSpec`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeSpec)
	fc.Result = res
	return ec.marshalNTypeSpec2capactiocapactpkghubapigraphqlpublicTypeSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_additionalRefs(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalONodePath2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeSpec_jsonSchema(ctx context.Context, field graphql.CollectedField, obj *TypeSpec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeSpec",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSONSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAttributeFilter(ctx context.Context, obj interface{}) (AttributeFilter, error) {
	var it AttributeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAttributeFilterInput(ctx context.Context, obj interface{}) (AttributeFilterInput, error) {
	var it AttributeFilterInput
	var asMap = obj.(map[string]interface{})

	if _, present := asMap["rule"]; !present {
		asMap["rule"] = "INCLUDE"
	}

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "rule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rule"))
			it.Rule, err = ec.unmarshalOFilterRule2capactiocapactpkghubapigraphqlpublicFilterRule(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationFilter(ctx context.Context, obj interface{}) (ImplementationFilter, error) {
	var it ImplementationFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImplementationRevisionFilter(ctx context.Context, obj interface{}) (ImplementationRevisionFilter, error) {
	var it ImplementationRevisionFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "requirementsSatisfiedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requirementsSatisfiedBy"))
			it.RequirementsSatisfiedBy, err = ec.unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "requiredTypeInstancesInjectionSatisfiedBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requiredTypeInstancesInjectionSatisfiedBy"))
			it.RequiredTypeInstancesInjectionSatisfiedBy, err = ec.unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOAttributeFilterInput2capactiocapactpkghubapigraphqlpublicAttributeFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "requires":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requires"))
			it.Requires, err = ec.unmarshalOTypeReferenceWithOptionalRevision2capactiocapactpkghubapigraphqlpublicTypeReferenceWithOptionalRevision(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceFilter(ctx context.Context, obj interface{}) (InterfaceFilter, error) {
	var it InterfaceFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInterfaceGroupFilter(ctx context.Context, obj interface{}) (InterfaceGroupFilter, error) {
	var it InterfaceGroupFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeFilter(ctx context.Context, obj interface{}) (TypeFilter, error) {
	var it TypeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathPattern":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathPattern"))
			it.PathPattern, err = ec.unmarshalONodePathPattern2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeInstanceValue(ctx context.Context, obj interface{}) (TypeInstanceValue, error) {
	var it TypeInstanceValue
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeRef":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeRef"))
			it.TypeRef, err = ec.unmarshalNTypeReferenceInput2capactiocapactpkghubapigraphqlpublicTypeReferenceInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeReferenceInput(ctx context.Context, obj interface{}) (TypeReferenceInput, error) {
	var it TypeReferenceInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalNVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeReferenceWithOptionalRevision(ctx context.Context, obj interface{}) (TypeReferenceWithOptionalRevision, error) {
	var it TypeReferenceWithOptionalRevision
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			it.Path, err = ec.unmarshalNNodePath2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "revision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			it.Revision, err = ec.unmarshalOVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _MetadataBaseFields(ctx context.Context, sel ast.SelectionSet, obj MetadataBaseFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case GenericMetadata:
		return ec._GenericMetadata(ctx, sel, &obj)
	case *GenericMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._GenericMetadata(ctx, sel, obj)
	case ImplementationMetadata:
		return ec._ImplementationMetadata(ctx, sel, &obj)
	case *ImplementationMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImplementationMetadata(ctx, sel, obj)
	case TypeMetadata:
		return ec._TypeMetadata(ctx, sel, &obj)
	case *TypeMetadata:
		if obj == nil {
			return graphql.Null
		}
		return ec._TypeMetadata(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TypeInstanceFields(ctx context.Context, sel ast.SelectionSet, obj TypeInstanceFields) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case InputTypeInstance:
		return ec._InputTypeInstance(ctx, sel, &obj)
	case *InputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._InputTypeInstance(ctx, sel, obj)
	case OutputTypeInstance:
		return ec._OutputTypeInstance(ctx, sel, &obj)
	case *OutputTypeInstance:
		if obj == nil {
			return graphql.Null
		}
		return ec._OutputTypeInstance(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var attributeImplementors = []string{"Attribute"}

func (ec *executionContext) _Attribute(ctx context.Context, sel ast.SelectionSet, obj *Attribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Attribute")
		case "path":
			out.Values[i] = ec._Attribute_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Attribute_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Attribute_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Attribute_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Attribute_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Attribute_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeRevisionImplementors = []string{"AttributeRevision"}

func (ec *executionContext) _AttributeRevision(ctx context.Context, sel ast.SelectionSet, obj *AttributeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeRevision")
		case "revision":
			out.Values[i] = ec._AttributeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._AttributeRevision_spec(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._AttributeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var attributeSpecImplementors = []string{"AttributeSpec"}

func (ec *executionContext) _AttributeSpec(ctx context.Context, sel ast.SelectionSet, obj *AttributeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, attributeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AttributeSpec")
		case "additionalRefs":
			out.Values[i] = ec._AttributeSpec_additionalRefs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var genericMetadataImplementors = []string{"GenericMetadata", "MetadataBaseFields"}

func (ec *executionContext) _GenericMetadata(ctx context.Context, sel ast.SelectionSet, obj *GenericMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, genericMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GenericMetadata")
		case "path":
			out.Values[i] = ec._GenericMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._GenericMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._GenericMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._GenericMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GenericMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._GenericMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._GenericMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._GenericMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._GenericMetadata_iconURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImplementors = []string{"Implementation"}

func (ec *executionContext) _Implementation(ctx context.Context, sel ast.SelectionSet, obj *Implementation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Implementation")
		case "path":
			out.Values[i] = ec._Implementation_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Implementation_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Implementation_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Implementation_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Implementation_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Implementation_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationActionImplementors = []string{"ImplementationAction"}

func (ec *executionContext) _ImplementationAction(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationActionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAction")
		case "runnerInterface":
			out.Values[i] = ec._ImplementationAction_runnerInterface(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec._ImplementationAction_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalInputImplementors = []string{"ImplementationAdditionalInput"}

func (ec *executionContext) _ImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalInput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalInput_typeInstances(ctx, field, obj)
		case "parameters":
			out.Values[i] = ec._ImplementationAdditionalInput_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalInputParameterImplementors = []string{"ImplementationAdditionalInputParameter"}

func (ec *executionContext) _ImplementationAdditionalInputParameter(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalInputParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalInputParameterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalInputParameter")
		case "name":
			out.Values[i] = ec._ImplementationAdditionalInputParameter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._ImplementationAdditionalInputParameter_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationAdditionalOutputImplementors = []string{"ImplementationAdditionalOutput"}

func (ec *executionContext) _ImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, obj *ImplementationAdditionalOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationAdditionalOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationAdditionalOutput")
		case "typeInstances":
			out.Values[i] = ec._ImplementationAdditionalOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportImplementors = []string{"ImplementationImport"}

func (ec *executionContext) _ImplementationImport(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImport")
		case "interfaceGroupPath":
			out.Values[i] = ec._ImplementationImport_interfaceGroupPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "alias":
			out.Values[i] = ec._ImplementationImport_alias(ctx, field, obj)
		case "appVersion":
			out.Values[i] = ec._ImplementationImport_appVersion(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._ImplementationImport_methods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationImportMethodImplementors = []string{"ImplementationImportMethod"}

func (ec *executionContext) _ImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, obj *ImplementationImportMethod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationImportMethodImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationImportMethod")
		case "name":
			out.Values[i] = ec._ImplementationImportMethod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._ImplementationImportMethod_revision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationMetadataImplementors = []string{"ImplementationMetadata", "MetadataBaseFields"}

func (ec *executionContext) _ImplementationMetadata(ctx context.Context, sel ast.SelectionSet, obj *ImplementationMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationMetadata")
		case "path":
			out.Values[i] = ec._ImplementationMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._ImplementationMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._ImplementationMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ImplementationMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ImplementationMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._ImplementationMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._ImplementationMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._ImplementationMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._ImplementationMetadata_iconURL(ctx, field, obj)
		case "license":
			out.Values[i] = ec._ImplementationMetadata_license(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attributes":
			out.Values[i] = ec._ImplementationMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementImplementors = []string{"ImplementationRequirement"}

func (ec *executionContext) _ImplementationRequirement(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirement")
		case "prefix":
			out.Values[i] = ec._ImplementationRequirement_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "oneOf":
			out.Values[i] = ec._ImplementationRequirement_oneOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "anyOf":
			out.Values[i] = ec._ImplementationRequirement_anyOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "allOf":
			out.Values[i] = ec._ImplementationRequirement_allOf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRequirementItemImplementors = []string{"ImplementationRequirementItem"}

func (ec *executionContext) _ImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRequirementItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRequirementItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRequirementItem")
		case "typeRef":
			out.Values[i] = ec._ImplementationRequirementItem_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "valueConstraints":
			out.Values[i] = ec._ImplementationRequirementItem_valueConstraints(ctx, field, obj)
		case "alias":
			out.Values[i] = ec._ImplementationRequirementItem_alias(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationRevisionImplementors = []string{"ImplementationRevision"}

func (ec *executionContext) _ImplementationRevision(ctx context.Context, sel ast.SelectionSet, obj *ImplementationRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationRevision")
		case "revision":
			out.Values[i] = ec._ImplementationRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._ImplementationRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "spec":
			out.Values[i] = ec._ImplementationRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImplementationRevision_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var implementationSpecImplementors = []string{"ImplementationSpec"}

func (ec *executionContext) _ImplementationSpec(ctx context.Context, sel ast.SelectionSet, obj *ImplementationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, implementationSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImplementationSpec")
		case "appVersion":
			out.Values[i] = ec._ImplementationSpec_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implements":
			out.Values[i] = ec._ImplementationSpec_implements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requires":
			out.Values[i] = ec._ImplementationSpec_requires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imports":
			out.Values[i] = ec._ImplementationSpec_imports(ctx, field, obj)
		case "action":
			out.Values[i] = ec._ImplementationSpec_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "additionalInput":
			out.Values[i] = ec._ImplementationSpec_additionalInput(ctx, field, obj)
		case "additionalOutput":
			out.Values[i] = ec._ImplementationSpec_additionalOutput(ctx, field, obj)
		case "outputTypeInstanceRelations":
			out.Values[i] = ec._ImplementationSpec_outputTypeInstanceRelations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputParameterImplementors = []string{"InputParameter"}

func (ec *executionContext) _InputParameter(ctx context.Context, sel ast.SelectionSet, obj *InputParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputParameterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputParameter")
		case "name":
			out.Values[i] = ec._InputParameter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jsonSchema":
			out.Values[i] = ec._InputParameter_jsonSchema(ctx, field, obj)
		case "typeRef":
			out.Values[i] = ec._InputParameter_typeRef(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var inputTypeInstanceImplementors = []string{"InputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _InputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *InputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InputTypeInstance")
		case "name":
			out.Values[i] = ec._InputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._InputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "verbs":
			out.Values[i] = ec._InputTypeInstance_verbs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceImplementors = []string{"Interface"}

func (ec *executionContext) _Interface(ctx context.Context, sel ast.SelectionSet, obj *Interface) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Interface")
		case "path":
			out.Values[i] = ec._Interface_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Interface_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Interface_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Interface_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Interface_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Interface_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceGroupImplementors = []string{"InterfaceGroup"}

func (ec *executionContext) _InterfaceGroup(ctx context.Context, sel ast.SelectionSet, obj *InterfaceGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceGroup")
		case "path":
			out.Values[i] = ec._InterfaceGroup_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._InterfaceGroup_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._InterfaceGroup_interfaces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceInputImplementors = []string{"InterfaceInput"}

func (ec *executionContext) _InterfaceInput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceInputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceInput")
		case "parameters":
			out.Values[i] = ec._InterfaceInput_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeInstances":
			out.Values[i] = ec._InterfaceInput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceOutputImplementors = []string{"InterfaceOutput"}

func (ec *executionContext) _InterfaceOutput(ctx context.Context, sel ast.SelectionSet, obj *InterfaceOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceOutputImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceOutput")
		case "typeInstances":
			out.Values[i] = ec._InterfaceOutput_typeInstances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceReferenceImplementors = []string{"InterfaceReference"}

func (ec *executionContext) _InterfaceReference(ctx context.Context, sel ast.SelectionSet, obj *InterfaceReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceReference")
		case "path":
			out.Values[i] = ec._InterfaceReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._InterfaceReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceRevisionImplementors = []string{"InterfaceRevision"}

func (ec *executionContext) _InterfaceRevision(ctx context.Context, sel ast.SelectionSet, obj *InterfaceRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceRevision")
		case "revision":
			out.Values[i] = ec._InterfaceRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._InterfaceRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._InterfaceRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementationRevisions":
			out.Values[i] = ec._InterfaceRevision_implementationRevisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var interfaceSpecImplementors = []string{"InterfaceSpec"}

func (ec *executionContext) _InterfaceSpec(ctx context.Context, sel ast.SelectionSet, obj *InterfaceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, interfaceSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InterfaceSpec")
		case "input":
			out.Values[i] = ec._InterfaceSpec_input(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "output":
			out.Values[i] = ec._InterfaceSpec_output(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var latestSemVerTaggingStrategyImplementors = []string{"LatestSemVerTaggingStrategy"}

func (ec *executionContext) _LatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *LatestSemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, latestSemVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LatestSemVerTaggingStrategy")
		case "pointsTo":
			out.Values[i] = ec._LatestSemVerTaggingStrategy_pointsTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var licenseImplementors = []string{"License"}

func (ec *executionContext) _License(ctx context.Context, sel ast.SelectionSet, obj *License) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, licenseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("License")
		case "name":
			out.Values[i] = ec._License_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Maintainer_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outputTypeInstanceImplementors = []string{"OutputTypeInstance", "TypeInstanceFields"}

func (ec *executionContext) _OutputTypeInstance(ctx context.Context, sel ast.SelectionSet, obj *OutputTypeInstance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outputTypeInstanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutputTypeInstance")
		case "name":
			out.Values[i] = ec._OutputTypeInstance_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "typeRef":
			out.Values[i] = ec._OutputTypeInstance_typeRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "repoMetadata":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoMetadata(ctx, field)
				return res
			})
		case "interfaceGroups":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interfaceGroup":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaceGroup(ctx, field)
				return res
			})
		case "interfaces":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interfaces(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "interface":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_interface(ctx, field)
				return res
			})
		case "types":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_types(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_type(ctx, field)
				return res
			})
		case "implementations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "implementation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_implementation(ctx, field)
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attributes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attribute":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_attribute(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationAppVersionConfigImplementors = []string{"RepoImplementationAppVersionConfig"}

func (ec *executionContext) _RepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationAppVersionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationAppVersionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationAppVersionConfig")
		case "semVerTaggingStrategy":
			out.Values[i] = ec._RepoImplementationAppVersionConfig_semVerTaggingStrategy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoImplementationConfigImplementors = []string{"RepoImplementationConfig"}

func (ec *executionContext) _RepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, obj *RepoImplementationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoImplementationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoImplementationConfig")
		case "appVersion":
			out.Values[i] = ec._RepoImplementationConfig_appVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataImplementors = []string{"RepoMetadata"}

func (ec *executionContext) _RepoMetadata(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadata")
		case "path":
			out.Values[i] = ec._RepoMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._RepoMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._RepoMetadata_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._RepoMetadata_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoMetadata_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._RepoMetadata_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataRevisionImplementors = []string{"RepoMetadataRevision"}

func (ec *executionContext) _RepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataRevision")
		case "revision":
			out.Values[i] = ec._RepoMetadataRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._RepoMetadataRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._RepoMetadataRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoMetadataSpecImplementors = []string{"RepoMetadataSpec"}

func (ec *executionContext) _RepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, obj *RepoMetadataSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoMetadataSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoMetadataSpec")
		case "hubVersion":
			out.Values[i] = ec._RepoMetadataSpec_hubVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ocfVersion":
			out.Values[i] = ec._RepoMetadataSpec_ocfVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "implementation":
			out.Values[i] = ec._RepoMetadataSpec_implementation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoOCFVersionImplementors = []string{"RepoOCFVersion"}

func (ec *executionContext) _RepoOCFVersion(ctx context.Context, sel ast.SelectionSet, obj *RepoOCFVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoOCFVersionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoOCFVersion")
		case "supported":
			out.Values[i] = ec._RepoOCFVersion_supported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "default":
			out.Values[i] = ec._RepoOCFVersion_default(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var semVerTaggingStrategyImplementors = []string{"SemVerTaggingStrategy"}

func (ec *executionContext) _SemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, obj *SemVerTaggingStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, semVerTaggingStrategyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SemVerTaggingStrategy")
		case "latest":
			out.Values[i] = ec._SemVerTaggingStrategy_latest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeImplementors = []string{"Type"}

func (ec *executionContext) _Type(ctx context.Context, sel ast.SelectionSet, obj *Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Type")
		case "path":
			out.Values[i] = ec._Type_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Type_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prefix":
			out.Values[i] = ec._Type_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latestRevision":
			out.Values[i] = ec._Type_latestRevision(ctx, field, obj)
		case "revision":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Type_revision(ctx, field, obj)
				return res
			})
		case "revisions":
			out.Values[i] = ec._Type_revisions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeInstanceRelationItemImplementors = []string{"TypeInstanceRelationItem"}

func (ec *executionContext) _TypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, obj *TypeInstanceRelationItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeInstanceRelationItemImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeInstanceRelationItem")
		case "typeInstanceName":
			out.Values[i] = ec._TypeInstanceRelationItem_typeInstanceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "uses":
			out.Values[i] = ec._TypeInstanceRelationItem_uses(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeMetadataImplementors = []string{"TypeMetadata", "MetadataBaseFields"}

func (ec *executionContext) _TypeMetadata(ctx context.Context, sel ast.SelectionSet, obj *TypeMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeMetadata")
		case "path":
			out.Values[i] = ec._TypeMetadata_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._TypeMetadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prefix":
			out.Values[i] = ec._TypeMetadata_prefix(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._TypeMetadata_displayName(ctx, field, obj)
		case "description":
			out.Values[i] = ec._TypeMetadata_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._TypeMetadata_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentationURL":
			out.Values[i] = ec._TypeMetadata_documentationURL(ctx, field, obj)
		case "supportURL":
			out.Values[i] = ec._TypeMetadata_supportURL(ctx, field, obj)
		case "iconURL":
			out.Values[i] = ec._TypeMetadata_iconURL(ctx, field, obj)
		case "attributes":
			out.Values[i] = ec._TypeMetadata_attributes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeReferenceImplementors = []string{"TypeReference"}

func (ec *executionContext) _TypeReference(ctx context.Context, sel ast.SelectionSet, obj *TypeReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeReference")
		case "path":
			out.Values[i] = ec._TypeReference_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":
			out.Values[i] = ec._TypeReference_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeRevisionImplementors = []string{"TypeRevision"}

func (ec *executionContext) _TypeRevision(ctx context.Context, sel ast.SelectionSet, obj *TypeRevision) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeRevisionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeRevision")
		case "revision":
			out.Values[i] = ec._TypeRevision_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._TypeRevision_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._TypeRevision_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeSpecImplementors = []string{"TypeSpec"}

func (ec *executionContext) _TypeSpec(ctx context.Context, sel ast.SelectionSet, obj *TypeSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeSpecImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeSpec")
		case "additionalRefs":
			out.Values[i] = ec._TypeSpec_additionalRefs(ctx, field, obj)
		case "jsonSchema":
			out.Values[i] = ec._TypeSpec_jsonSchema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v []*Attribute) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAttributeFilterInput2capactiocapactpkghubapigraphqlpublicAttributeFilterInput(ctx context.Context, v interface{}) (*AttributeFilterInput, error) {
	res, err := ec.unmarshalInputAttributeFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v []*AttributeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNGenericMetadata2capactiocapactpkghubapigraphqlpublicGenericMetadata(ctx context.Context, sel ast.SelectionSet, v *GenericMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GenericMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v []*Implementation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationAction2capactiocapactpkghubapigraphqlpublicImplementationAction(ctx context.Context, sel ast.SelectionSet, v *ImplementationAction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationAction(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationAdditionalInputParameter2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInputParameter(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalInputParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationAdditionalInputParameter(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImport2capactiocapactpkghubapigraphqlpublicImplementationImport(ctx context.Context, sel ast.SelectionSet, v *ImplementationImport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImport(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationImportMethod2capactiocapactpkghubapigraphqlpublicImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImportMethod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImportMethod2capactiocapactpkghubapigraphqlpublicImplementationImportMethod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationImportMethod2capactiocapactpkghubapigraphqlpublicImplementationImportMethod(ctx context.Context, sel ast.SelectionSet, v *ImplementationImportMethod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationImportMethod(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationMetadata2capactiocapactpkghubapigraphqlpublicImplementationMetadata(ctx context.Context, sel ast.SelectionSet, v *ImplementationMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirement2capactiocapactpkghubapigraphqlpublicImplementationRequirement(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirement2capactiocapactpkghubapigraphqlpublicImplementationRequirement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirement2capactiocapactpkghubapigraphqlpublicImplementationRequirement(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirement(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRequirementItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRequirementItem2capactiocapactpkghubapigraphqlpublicImplementationRequirementItem(ctx context.Context, sel ast.SelectionSet, v *ImplementationRequirementItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRequirementItem(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v []*ImplementationRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNImplementationSpec2capactiocapactpkghubapigraphqlpublicImplementationSpec(ctx context.Context, sel ast.SelectionSet, v *ImplementationSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImplementationSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNInputParameter2capactiocapactpkghubapigraphqlpublicInputParameter(ctx context.Context, sel ast.SelectionSet, v []*InputParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInputParameter2capactiocapactpkghubapigraphqlpublicInputParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputParameter2capactiocapactpkghubapigraphqlpublicInputParameter(ctx context.Context, sel ast.SelectionSet, v *InputParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InputParameter(ctx, sel, v)
}

func (ec *executionContext) marshalNInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v []*Interface) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v []*InterfaceGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceInput2capactiocapactpkghubapigraphqlpublicInterfaceInput(ctx context.Context, sel ast.SelectionSet, v *InterfaceInput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceInput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceOutput2capactiocapactpkghubapigraphqlpublicInterfaceOutput(ctx context.Context, sel ast.SelectionSet, v *InterfaceOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceOutput(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceReference2capactiocapactpkghubapigraphqlpublicInterfaceReference(ctx context.Context, sel ast.SelectionSet, v []*InterfaceReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceReference2capactiocapactpkghubapigraphqlpublicInterfaceReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceReference2capactiocapactpkghubapigraphqlpublicInterfaceReference(ctx context.Context, sel ast.SelectionSet, v *InterfaceReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceReference(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v []*InterfaceRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNInterfaceSpec2capactiocapactpkghubapigraphqlpublicInterfaceSpec(ctx context.Context, sel ast.SelectionSet, v *InterfaceSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._InterfaceSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNLatestSemVerTaggingStrategy2capactiocapactpkghubapigraphqlpublicLatestSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *LatestSemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._LatestSemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) marshalNLicense2capactiocapactpkghubapigraphqlpublicLicense(ctx context.Context, sel ast.SelectionSet, v *License) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._License(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx context.Context, sel ast.SelectionSet, v []*Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2capactiocapactpkghubapigraphqlpublicMaintainer(ctx context.Context, sel ast.SelectionSet, v *Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeName2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeName2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePath2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNNodePath2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNNodePath2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNNodePrefix2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodePrefix2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*OutputTypeInstance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationAppVersionConfig2capactiocapactpkghubapigraphqlpublicRepoImplementationAppVersionConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationAppVersionConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationAppVersionConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoImplementationConfig2capactiocapactpkghubapigraphqlpublicRepoImplementationConfig(ctx context.Context, sel ast.SelectionSet, v *RepoImplementationConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoImplementationConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v []*RepoMetadataRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoMetadataSpec2capactiocapactpkghubapigraphqlpublicRepoMetadataSpec(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoMetadataSpec(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoOCFVersion2capactiocapactpkghubapigraphqlpublicRepoOCFVersion(ctx context.Context, sel ast.SelectionSet, v *RepoOCFVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepoOCFVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNSemVerTaggingStrategy2capactiocapactpkghubapigraphqlpublicSemVerTaggingStrategy(ctx context.Context, sel ast.SelectionSet, v *SemVerTaggingStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SemVerTaggingStrategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSemVerTaggingStrategyTags2capactiocapactpkghubapigraphqlpublicSemVerTaggingStrategyTags(ctx context.Context, v interface{}) (SemVerTaggingStrategyTags, error) {
	var res SemVerTaggingStrategyTags
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSemVerTaggingStrategyTags2capactiocapactpkghubapigraphqlpublicSemVerTaggingStrategyTags(ctx context.Context, sel ast.SelectionSet, v SemVerTaggingStrategyTags) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNType2capactiocapactpkghubapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v []*Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNType2capactiocapactpkghubapigraphqlpublicType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNType2capactiocapactpkghubapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, v interface{}) (TypeInstanceOperationVerb, error) {
	var res TypeInstanceOperationVerb
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, sel ast.SelectionSet, v TypeInstanceOperationVerb) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, v interface{}) ([]TypeInstanceOperationVerb, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]TypeInstanceOperationVerb, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx context.Context, sel ast.SelectionSet, v []TypeInstanceOperationVerb) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceOperationVerb2capactiocapactpkghubapigraphqlpublicTypeInstanceOperationVerb(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2capactiocapactpkghubapigraphqlpublicTypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, v []*TypeInstanceRelationItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeInstanceRelationItem2capactiocapactpkghubapigraphqlpublicTypeInstanceRelationItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeInstanceRelationItem2capactiocapactpkghubapigraphqlpublicTypeInstanceRelationItem(ctx context.Context, sel ast.SelectionSet, v *TypeInstanceRelationItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeInstanceRelationItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) (*TypeInstanceValue, error) {
	res, err := ec.unmarshalInputTypeInstanceValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeMetadata2capactiocapactpkghubapigraphqlpublicTypeMetadata(ctx context.Context, sel ast.SelectionSet, v *TypeMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx context.Context, sel ast.SelectionSet, v *TypeReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeReferenceInput2capactiocapactpkghubapigraphqlpublicTypeReferenceInput(ctx context.Context, v interface{}) (*TypeReferenceInput, error) {
	res, err := ec.unmarshalInputTypeReferenceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v []*TypeRevision) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeSpec2capactiocapactpkghubapigraphqlpublicTypeSpec(ctx context.Context, sel ast.SelectionSet, v *TypeSpec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersion2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNVersion2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersion2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNVersion2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNVersion2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNVersionRange2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionRange2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalAny(v)
}

func (ec *executionContext) marshalOAttribute2capactiocapactpkghubapigraphqlpublicAttribute(ctx context.Context, sel ast.SelectionSet, v *Attribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Attribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAttributeFilter2capactiocapactpkghubapigraphqlpublicAttributeFilter(ctx context.Context, v interface{}) (*AttributeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAttributeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAttributeFilterInput2capactiocapactpkghubapigraphqlpublicAttributeFilterInput(ctx context.Context, v interface{}) ([]*AttributeFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*AttributeFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAttributeFilterInput2capactiocapactpkghubapigraphqlpublicAttributeFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAttributeRevision2capactiocapactpkghubapigraphqlpublicAttributeRevision(ctx context.Context, sel ast.SelectionSet, v *AttributeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AttributeRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOAttributeSpec2capactiocapactpkghubapigraphqlpublicAttributeSpec(ctx context.Context, sel ast.SelectionSet, v *AttributeSpec) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AttributeSpec(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) unmarshalOFilterRule2capactiocapactpkghubapigraphqlpublicFilterRule(ctx context.Context, v interface{}) (*FilterRule, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FilterRule)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFilterRule2capactiocapactpkghubapigraphqlpublicFilterRule(ctx context.Context, sel ast.SelectionSet, v *FilterRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOImplementation2capactiocapactpkghubapigraphqlpublicImplementation(ctx context.Context, sel ast.SelectionSet, v *Implementation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Implementation(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalInput2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalInput(ctx, sel, v)
}

func (ec *executionContext) marshalOImplementationAdditionalInputParameter2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInputParameter(ctx context.Context, sel ast.SelectionSet, v []*ImplementationAdditionalInputParameter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationAdditionalInputParameter2capactiocapactpkghubapigraphqlpublicImplementationAdditionalInputParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOImplementationAdditionalOutput2capactiocapactpkghubapigraphqlpublicImplementationAdditionalOutput(ctx context.Context, sel ast.SelectionSet, v *ImplementationAdditionalOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationAdditionalOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImplementationFilter2capactiocapactpkghubapigraphqlpublicImplementationFilter(ctx context.Context, v interface{}) (*ImplementationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImplementationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImplementationImport2capactiocapactpkghubapigraphqlpublicImplementationImport(ctx context.Context, sel ast.SelectionSet, v []*ImplementationImport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImplementationImport2capactiocapactpkghubapigraphqlpublicImplementationImport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOImplementationRevision2capactiocapactpkghubapigraphqlpublicImplementationRevision(ctx context.Context, sel ast.SelectionSet, v *ImplementationRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImplementationRevision(ctx, sel, v)
}

func (ec *executionContext) marshalOInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v []*InputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOInputTypeInstance2capactiocapactpkghubapigraphqlpublicInputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *InputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalOInterface2capactiocapactpkghubapigraphqlpublicInterface(ctx context.Context, sel ast.SelectionSet, v *Interface) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Interface(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceFilter2capactiocapactpkghubapigraphqlpublicInterfaceFilter(ctx context.Context, v interface{}) (*InterfaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceGroup2capactiocapactpkghubapigraphqlpublicInterfaceGroup(ctx context.Context, sel ast.SelectionSet, v *InterfaceGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInterfaceGroupFilter2capactiocapactpkghubapigraphqlpublicInterfaceGroupFilter(ctx context.Context, v interface{}) (*InterfaceGroupFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputInterfaceGroupFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInterfaceRevision2capactiocapactpkghubapigraphqlpublicInterfaceRevision(ctx context.Context, sel ast.SelectionSet, v *InterfaceRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InterfaceRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalONodePath2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNodePath2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalONodePath2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNNodePath2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalONodePathPattern2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePathPattern2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalONodePrefix2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONodePrefix2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOOutputTypeInstance2capactiocapactpkghubapigraphqlpublicOutputTypeInstance(ctx context.Context, sel ast.SelectionSet, v *OutputTypeInstance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OutputTypeInstance(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadata2capactiocapactpkghubapigraphqlpublicRepoMetadata(ctx context.Context, sel ast.SelectionSet, v *RepoMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalORepoMetadataRevision2capactiocapactpkghubapigraphqlpublicRepoMetadataRevision(ctx context.Context, sel ast.SelectionSet, v *RepoMetadataRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoMetadataRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOType2capactiocapactpkghubapigraphqlpublicType(ctx context.Context, sel ast.SelectionSet, v *Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypeFilter2capactiocapactpkghubapigraphqlpublicTypeFilter(ctx context.Context, v interface{}) (*TypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) ([]*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeInstanceValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) ([]*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeInstanceValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeInstanceValue2capactiocapactpkghubapigraphqlpublicTypeInstanceValue(ctx context.Context, v interface{}) (*TypeInstanceValue, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeInstanceValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypeReference2capactiocapactpkghubapigraphqlpublicTypeReference(ctx context.Context, sel ast.SelectionSet, v *TypeReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTypeReferenceWithOptionalRevision2capactiocapactpkghubapigraphqlpublicTypeReferenceWithOptionalRevision(ctx context.Context, v interface{}) ([]*TypeReferenceWithOptionalRevision, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*TypeReferenceWithOptionalRevision, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTypeReferenceWithOptionalRevision2capactiocapactpkghubapigraphqlpublicTypeReferenceWithOptionalRevision(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTypeReferenceWithOptionalRevision2capactiocapactpkghubapigraphqlpublicTypeReferenceWithOptionalRevision(ctx context.Context, v interface{}) (*TypeReferenceWithOptionalRevision, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTypeReferenceWithOptionalRevision(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTypeRevision2capactiocapactpkghubapigraphqlpublicTypeRevision(ctx context.Context, sel ast.SelectionSet, v *TypeRevision) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeRevision(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersion2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOVersionRange2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionRange2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
