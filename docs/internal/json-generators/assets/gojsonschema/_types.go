// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import "fmt"
import "encoding/json"
import "reflect"

// The description of an action and its prerequisites (dependencies). An
// implementation implements at least one interface.
type ImplementationJson struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind ImplementationJsonKind `json:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata ImplementationJsonMetadata `json:"metadata"`

	// OcfVersion corresponds to the JSON schema field "ocfVersion".
	OcfVersion ImplementationJsonOcfVersion `json:"ocfVersion"`

	// Version of the manifest content in the SemVer format.
	Revision string `json:"revision"`

	// Ensures the authenticity and integrity of a given manifest.
	Signature ImplementationJsonSignature `json:"signature"`

	// A container for the Implementation specification definition.
	Spec ImplementationJsonSpec `json:"spec"`

	// TestField corresponds to the JSON schema field "testField".
	TestField *JsonSchemaTypeJson `json:"testField,omitempty"`
}

type ImplementationJsonKind string

const ImplementationJsonKindImplementation ImplementationJsonKind = "Implementation"

type ImplementationJsonMetadata struct {
	// A short description of the OCF manifest. Must be a non-empty string.
	Description string `json:"description"`

	// The name of the OCF manifest to be displayed in graphical clients.
	DisplayName *string `json:"displayName,omitempty"`

	// Link to documentation page for the OCF manifest.
	DocumentationURL *string `json:"documentationURL,omitempty"`

	// The URL to an icon or a data URL containing an icon.
	IconURL *string `json:"iconURL,omitempty"`

	// This entry allows you to specify a license, so people know how they are
	// permitted to use it, and what kind of restrictions you are placing on it.
	License ImplementationJsonMetadataLicense `json:"license"`

	// The list of maintainers with contact information.
	Maintainers []ImplementationJsonMetadataMaintainersElem `json:"maintainers"`

	// The name of OCF manifest that uniquely identifies this object within the entity
	// sub-tree. Must be a non-empty string. We recommend using a CLI-friendly name.
	Name string `json:"name"`

	// The prefix value is automatically computed and set when storing manifest in
	// OCH.
	Prefix *string `json:"prefix,omitempty"`

	// Link to support page for the OCF manifest.
	SupportURL *string `json:"supportURL,omitempty"`

	// The tags is a list of key value, OCF Tags. Describes the OCF Implementation
	// (provides generic categorization) and are used to filter out a specific
	// Implementation.
	Tags ImplementationJsonMetadataTags `json:"tags,omitempty"`
}

// This entry allows you to specify a license, so people know how they are
// permitted to use it, and what kind of restrictions you are placing on it.
type ImplementationJsonMetadataLicense map[string]interface{}

type ImplementationJsonMetadataMaintainersElem struct {
	// Email corresponds to the JSON schema field "email".
	Email string `json:"email"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url *string `json:"url,omitempty"`
}

// The tags is a list of key value, OCF Tags. Describes the OCF Implementation
// (provides generic categorization) and are used to filter out a specific
// Implementation.
type ImplementationJsonMetadataTags map[string]interface{}

type ImplementationJsonOcfVersion string

const ImplementationJsonOcfVersionA001 ImplementationJsonOcfVersion = "0.0.1"

// Ensures the authenticity and integrity of a given manifest.
type ImplementationJsonSignature struct {
	// Och corresponds to the JSON schema field "och".
	Och string `json:"och"`
}

// A container for the Implementation specification definition.
type ImplementationJsonSpec struct {
	// An explanation about the purpose of this instance.
	Action ImplementationJsonSpecAction `json:"action"`

	// The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion"`

	// Defines what kind of interfaces this implementation fulfills.
	Implements []ImplementationJsonSpecImplementsElem `json:"implements"`

	// List of external Interfaces that this Implementation requires to be able to
	// execute the action.
	Imports []ImplementationJsonSpecImportsElem `json:"imports,omitempty"`

	// List of the system prerequisites that need to be present on the cluster. There
	// has to be an Instance for every concrete type.
	Requires ImplementationJsonSpecRequires `json:"requires,omitempty"`
}

// An explanation about the purpose of this instance.
type ImplementationJsonSpecAction struct {
	// Holds all parameters that should be passed to the selected runner, for example
	// repoUrl, or chartName for the Helm3 runner.
	Args ImplementationJsonSpecActionArgs `json:"args"`

	// The Interface or Implementation of a runner, which handles the execution, for
	// example, cap.interface.runner.helm3.run
	Type string `json:"type"`
}

// Holds all parameters that should be passed to the selected runner, for example
// repoUrl, or chartName for the Helm3 runner.
type ImplementationJsonSpecActionArgs map[string]interface{}

type ImplementationJsonSpecImplementsElem struct {
	// The Interface name, for example cap.interfaces.db.mysql.install
	Name string `json:"name"`

	// The Interface revision.
	Revision *string `json:"revision,omitempty"`
}

type ImplementationJsonSpecImportsElem struct {
	// The alias for the full name of the imported group name. It can be used later in
	// the workflow definition instead of using full name.
	Alias *string `json:"alias,omitempty"`

	// The supported application versions in SemVer2 format.
	AppVersion *string `json:"appVersion,omitempty"`

	// The list of all required actions’ names that must be imported.
	Methods []string `json:"methods"`

	// The name of the group that holds specific actions that you want to import, for
	// example cap.interfaces.db.mysql
	Name string `json:"name"`
}

// List of the system prerequisites that need to be present on the cluster. There
// has to be an Instance for every concrete type.
type ImplementationJsonSpecRequires map[string]interface{}

// The JSONSchema definition.
type JsonSchemaTypeJson struct {
	// Reference to JSON Schema definition object, for example,
	// cap.type.db.mysql.config
	Ref *JsonSchemaTypeJsonRef `json:"ref,omitempty"`

	// Inline JSON Schema definition for the parameters.
	Value *string `json:"value,omitempty"`
}

// Reference to JSON Schema definition object, for example,
// cap.type.db.mysql.config
type JsonSchemaTypeJsonRef struct {
	// Reference to OCF Type for example, cap.type.db.mysql.config
	Name string `json:"name"`

	// Revision corresponds to the JSON schema field "revision".
	Revision string `json:"revision"`
}

type RequireEntity struct {
	// The name of the Type. Root prefix can be skipped if it’s a core Type. If it is
	// a custom Type then it MUST be defined as full path to that Type. Custom Type
	// MUST extend the abstract node which is defined as a root prefix for that entry.
	Name string `json:"name"`

	// The revision version of the given Type.
	Revision string `json:"revision"`

	// Holds the configuration constraints for the given entry. It needs to be valid
	// against the Type JSONSchema.
	Value RequireEntityValue `json:"value,omitempty"`
}

// Holds the configuration constraints for the given entry. It needs to be valid
// against the Type JSONSchema.
type RequireEntityValue map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSignature) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["och"]; !ok || v == nil {
		return fmt.Errorf("field och: required")
	}
	type Plain ImplementationJsonSignature
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSignature(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecAction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain ImplementationJsonSpecAction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecAction(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonOcfVersion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImplementationJsonOcfVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImplementationJsonOcfVersion, v)
	}
	*j = ImplementationJsonOcfVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecImplementsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ImplementationJsonSpecImplementsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecImplementsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["license"]; !ok || v == nil {
		return fmt.Errorf("field license: required")
	}
	if v, ok := raw["maintainers"]; !ok || v == nil {
		return fmt.Errorf("field maintainers: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ImplementationJsonMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonMetadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecImportsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["methods"]; !ok || v == nil {
		return fmt.Errorf("field methods: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ImplementationJsonSpecImportsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecImportsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonMetadataMaintainersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	type Plain ImplementationJsonMetadataMaintainersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonMetadataMaintainersElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImplementationJsonKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImplementationJsonKind, v)
	}
	*j = ImplementationJsonKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["action"]; !ok || v == nil {
		return fmt.Errorf("field action: required")
	}
	if v, ok := raw["appVersion"]; !ok || v == nil {
		return fmt.Errorf("field appVersion: required")
	}
	if v, ok := raw["implements"]; !ok || v == nil {
		return fmt.Errorf("field implements: required")
	}
	type Plain ImplementationJsonSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequireEntity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["revision"]; !ok || v == nil {
		return fmt.Errorf("field revision: required")
	}
	type Plain RequireEntity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RequireEntity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *JsonSchemaTypeJsonRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["revision"]; !ok || v == nil {
		return fmt.Errorf("field revision: required")
	}
	type Plain JsonSchemaTypeJsonRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = JsonSchemaTypeJsonRef(plain)
	return nil
}

var enumValues_ImplementationJsonKind = []interface{}{
	"Implementation",
}
var enumValues_ImplementationJsonOcfVersion = []interface{}{
	"0.0.1",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["ocfVersion"]; !ok || v == nil {
		return fmt.Errorf("field ocfVersion: required")
	}
	if v, ok := raw["revision"]; !ok || v == nil {
		return fmt.Errorf("field revision: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec: required")
	}
	type Plain ImplementationJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJson(plain)
	return nil
}
