// Code generated by schema-generate. DO NOT EDIT.

package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"reflect"
)

func ValueTypeToString(valueType jsoniter.ValueType) string {
	switch valueType {
	case jsoniter.StringValue:
		return "string"
	case jsoniter.NumberValue:
		return "number"
	case jsoniter.NilValue:
		return "nil"
	case jsoniter.BoolValue:
		return "bool"
	case jsoniter.ArrayValue:
		return "array"
	case jsoniter.ObjectValue:
		return "object"
	default:
		return "invalid"
	}
}

type commaTracker struct {
	stream *jsoniter.Stream
	started bool
}

func (t *commaTracker) More() {
	if t.started {
		t.stream.WriteMore()
	} else {
		t.started = true
	}
}

type isEmptyChecker interface {
	IsEmpty() bool
}

// IsEmpty reports whether v is zero struct
// Does not support cycle pointers for performance, so as json
func IsEmpty(v interface{}) bool {
	if i, ok := v.(isEmptyChecker); ok {
		return i.IsEmpty()
	}
	rv := reflect.ValueOf(v)
	return !rv.IsValid() || rv.IsZero()
}

var (
	jsonNullValue = []byte("null")
)

// NewEmptyBool creates a non-empty EmptyBool
func NewEmptyBool(value bool) EmptyBool {
	return EmptyBool{value, true}
}

// EmptyBool is bool or nothing
type EmptyBool struct {
	Bool bool
	Valid bool // Valid is true if Bool is not empty
}

func (t EmptyBool) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyBool) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Bool)
	}
	return []byte("\"\""), nil
}

func (t *EmptyBool) Set(value bool) {
	t.Bool = value
	t.Valid = true
}

func (t *EmptyBool) Unset() {
	t.Bool = false
	t.Valid = false
}

func (t EmptyBool) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteBool(t.Bool)
	} else {
		stream.WriteBool(false)
	}
}

func (t *EmptyBool) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Bool = iter.ReadBool()
	t.Valid = iter.Error == nil
}

func (t *EmptyBool) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Bool); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyFloat64 creates a non-empty EmptyFloat64
func NewEmptyFloat64(value float64) EmptyFloat64 {
	return EmptyFloat64{value, true}
}

// EmptyFloat64 is float64 or nothing
type EmptyFloat64 struct {
	Float64 float64
	Valid bool // Valid is true if Float64 is not empty
}

func (t EmptyFloat64) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyFloat64) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Float64)
	}
	return []byte("\"\""), nil
}

func (t *EmptyFloat64) Set(value float64) {
	t.Float64 = value
	t.Valid = true
}

func (t *EmptyFloat64) Unset() {
	t.Float64 = 0.0
	t.Valid = false
}

func (t EmptyFloat64) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteFloat64(t.Float64)
	} else {
		stream.WriteFloat64(0.0)
	}
}

func (t *EmptyFloat64) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Float64 = iter.ReadFloat64()
	t.Valid = iter.Error == nil
}

func (t *EmptyFloat64) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Float64); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyInt creates a non-empty EmptyInt
func NewEmptyInt(value int) EmptyInt {
	return EmptyInt{value, true}
}

// EmptyInt is int or nothing
type EmptyInt struct {
	Int int
	Valid bool // Valid is true if Int is not empty
}

func (t EmptyInt) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyInt) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Int)
	}
	return []byte("\"\""), nil
}

func (t *EmptyInt) Set(value int) {
	t.Int = value
	t.Valid = true
}

func (t *EmptyInt) Unset() {
	t.Int = 0
	t.Valid = false
}

func (t EmptyInt) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteInt(t.Int)
	} else {
		stream.WriteInt(0)
	}
}

func (t *EmptyInt) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Int = iter.ReadInt()
	t.Valid = iter.Error == nil
}

func (t *EmptyInt) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Int); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyString creates a non-empty EmptyString
func NewEmptyString(value string) EmptyString {
	return EmptyString{value, true}
}

// EmptyString is string or nothing
type EmptyString struct {
	String string
	Valid bool // Valid is true if String is not empty
}

func (t EmptyString) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyString) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.String)
	}
	return []byte("\"\""), nil
}

func (t *EmptyString) Set(value string) {
	t.String = value
	t.Valid = true
}

func (t *EmptyString) Unset() {
	t.String = ""
	t.Valid = false
}

func (t EmptyString) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteString(t.String)
	} else {
		stream.WriteString("")
	}
}

func (t *EmptyString) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.String = iter.ReadString()
	t.Valid = iter.Error == nil
}

func (t *EmptyString) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.String); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// OneOfStringNull is a 'string' or a 'null', and can be emptied
type OneOfStringNull struct {
	currentType jsoniter.ValueType
	stringValue string
}

// NewOneOfStringNull creates a empty OneOfStringNull
func NewOneOfStringNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.InvalidValue, ""}
}

// NewOneOfStringNullString creates a OneOfStringNull of type string
func NewOneOfStringNullString(value string) OneOfStringNull {
	return OneOfStringNull{jsoniter.StringValue, value}
}

// NewOneOfStringNullNull creates a OneOfStringNull of type null
func NewOneOfStringNullNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.NilValue, ""}
}

// IsEmpty returns true if the value is empty
func (value *OneOfStringNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfStringNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsString returns true if the value is a string
func (value *OneOfStringNull) IsString() bool {
	return value.currentType == jsoniter.StringValue
}

// StringValue returns the current value if IsString() is true, "" otherwise
func (value *OneOfStringNull) StringValue() string {
	if value.currentType == jsoniter.StringValue {
		return value.stringValue
	}
	return ""
}

// NullString returns the current value as a sql.NullString
func (value *OneOfStringNull) NullString() sql.NullString {
	return sql.NullString{
		Valid:  value.currentType == jsoniter.StringValue,
		String: value.stringValue,
	}
}

// MarshalJSONStream serializes to a jsoniter Stream
func (value OneOfStringNull) MarshalJSONStream(stream *jsoniter.Stream) {
	if value.currentType == jsoniter.StringValue {
		stream.WriteString(value.stringValue)
	} else {
		stream.WriteNil()
	}
}

// MarshalJSON serialize to json
func (value OneOfStringNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.StringValue:
		return jsoniter.Marshal(value.stringValue)
	}
	return nil, fmt.Errorf(
		"OneOfStringNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

func (value *OneOfStringNull) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	switch t := iter.WhatIsNext(); t {
	case jsoniter.NilValue:
		iter.ReadNil()
		value.currentType = jsoniter.NilValue
	case jsoniter.StringValue:
		value.currentType = jsoniter.StringValue
		value.stringValue = iter.ReadString()
	default:
		iter.ReportError("Read", fmt.Sprintf("unexpected value type: %v", t))
	}
}

// UnmarshalJSON unserialize a OneOfStringNull from json
func (value *OneOfStringNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.stringValue); err != nil {
			return err
		}
		value.currentType = jsoniter.StringValue
	}
	return nil
}

// OneOfNumberNull is a 'string' or a 'null', and can be emptied
type OneOfNumberNull struct {
	currentType jsoniter.ValueType
	numberValue float64
}

// NewOneOfNumberNull creates a empty OneOfNumberNull
func NewOneOfNumberNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.InvalidValue, 0}
}

// NewOneOfNumberNullNumber creates a OneOfNumberNull of type number
func NewOneOfNumberNullNumber(value float64) OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NumberValue, value}
}

// NewOneOfNumberNullNull creates a OneOfNumberNull of type null
func NewOneOfNumberNullNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NilValue, 0}
}

// IsEmpty returns true if the value is empty
func (value *OneOfNumberNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfNumberNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsNumber returns true if the value is a number
func (value *OneOfNumberNull) IsNumber() bool {
	return value.currentType == jsoniter.NumberValue
}

// NumberValue returns the current value if IsNumber() is true, 0 otherwise
func (value *OneOfNumberNull) NumberValue() float64 {
	if value.currentType == jsoniter.NumberValue {
		return value.numberValue
	}
	return 0
}

// MarshalJSON serialize to json
func (value OneOfNumberNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.NumberValue:
		return jsoniter.Marshal(value.numberValue)
	}
	return nil, fmt.Errorf(
		"OneOfNumberNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfNumberNull from json
func (value *OneOfNumberNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.numberValue); err != nil {
			return err
		}
		value.currentType = jsoniter.NumberValue
	}
	return nil
}

// OneOfBoolNull is a 'bool' or a 'null', and can be emptied
type OneOfBoolNull struct {
	currentType jsoniter.ValueType
	boolValue   bool
}

// NewOneOfBoolNull creates a empty OneOfBoolNull
func NewOneOfBoolNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.InvalidValue, false}
}

// NewOneOfBoolNullBool creates a OneOfBoolNull of type number
func NewOneOfBoolNullBool(value bool) OneOfBoolNull {
	return OneOfBoolNull{jsoniter.BoolValue, value}
}

// NewOneOfBoolNullNull creates a OneOfBoolNull of type null
func NewOneOfBoolNullNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.NilValue, false}
}

// IsEmpty returns true if the value is empty
func (value *OneOfBoolNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfBoolNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsBool returns true if the value is a bool
func (value *OneOfBoolNull) IsBool() bool {
	return value.currentType == jsoniter.BoolValue
}

// BoolValue returns the current value if IsBool() is true, false otherwise
func (value *OneOfBoolNull) BoolValue() bool {
	if value.currentType == jsoniter.BoolValue {
		return value.boolValue
	}
	return false
}

// MarshalJSON serialize to json
func (value OneOfBoolNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.BoolValue:
		return jsoniter.Marshal(value.boolValue)
	}
	return nil, fmt.Errorf(
		"OneOfBoolNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfBoolNull from json
func (value *OneOfBoolNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.boolValue); err != nil {
			return err
		}
		value.currentType = jsoniter.BoolValue
	}
	return nil
}

// HoldsContactInformation 
type HoldsContactInformation struct {
	// Email 
	Email string `json:"email"`

	// Name 
	Name string `json:"name,omitempty"`

	// Url 
	Url string `json:"url,omitempty"`

}

// License This entry allows you to specify a license, so people know how they are permitted to use it, and what kind of restrictions you are placing on it.
type License struct {
}

// RequireEntity 
type RequireEntity struct {
	// Name The name of the Type. Root prefix can be skipped if it’s a core Type. If it is a custom Type then it MUST be defined as full path to that Type. Custom Type MUST extend the abstract node which is defined as a root prefix for that entry.
	Name string `json:"name"`

	// Revision The revision version of the given Type.
	Revision string `json:"revision"`

	// Value Holds the configuration constraints for the given entry. It needs to be valid against the Type JSONSchema.
	Value *TheValueSchema `json:"value,omitempty"`

}

// TagsItem 
type TagsItem struct {
	// Revision 
	Revision string `json:"revision"`

}

// TheActionSchema An explanation about the purpose of this instance.
type TheActionSchema struct {
	// Args Holds all parameters that should be passed to the selected runner, for example repoUrl, or chartName for the Helm3 runner.
	Args *TheArgsSchema `json:"args"`

	// Type The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
	Type string `json:"type"`

}

// TheArgsSchema Holds all parameters that should be passed to the selected runner, for example repoUrl, or chartName for the Helm3 runner.
type TheArgsSchema struct {
}

// TheImplementsSchemaItems 
type TheImplementsSchemaItems struct {
	// Name The Interface name, for example cap.interfaces.db.mysql.install
	Name string `json:"name"`

	// Revision The Interface revision.
	Revision string `json:"revision,omitempty"`

}

// TheImportsSchemaItems 
type TheImportsSchemaItems struct {
	// Alias The alias for the full name of the imported group name. It can be used later in the workflow definition instead of using full name.
	Alias string `json:"alias,omitempty"`

	// AppVersion The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion,omitempty"`

	// Methods The list of all required actions’ names that must be imported.
	Methods []string `json:"methods"`

	// Name The name of the group that holds specific actions that you want to import, for example cap.interfaces.db.mysql
	Name string `json:"name"`

}

// TheMetadataSchema 
type TheMetadataSchema struct {
	// Description A short description of the OCF manifest. Must be a non-empty string.
	Description string `json:"description"`

	// DisplayName The name of the OCF manifest to be displayed in graphical clients.
	DisplayName string `json:"displayName,omitempty"`

	// DocumentationURL Link to documentation page for the OCF manifest.
	DocumentationURL string `json:"documentationURL,omitempty"`

	// IconURL The URL to an icon or a data URL containing an icon.
	IconURL string `json:"iconURL,omitempty"`

	// License This entry allows you to specify a license, so people know how they are permitted to use it, and what kind of restrictions you are placing on it.
	License *License `json:"license"`

	// Maintainers The list of maintainers with contact information.
	Maintainers []*HoldsContactInformation `json:"maintainers"`

	// Name The name of OCF manifest that uniquely identifies this object within the entity sub-tree. Must be a non-empty string. We recommend using a CLI-friendly name.
	Name string `json:"name"`

	// Prefix The prefix value is automatically computed and set when storing manifest in OCH.
	Prefix string `json:"prefix,omitempty"`

	// SupportURL Link to support page for the OCF manifest.
	SupportURL string `json:"supportURL,omitempty"`

	// Tags The tags is a list of key value, OCF Tags. Describes the OCF Implementation (provides generic categorization) and are used to filter out a specific Implementation.
	Tags map[string]*TagsItem `json:"tags,omitempty"`

}

// TheOCFTypeManifestSchema Primitive, that holds the JSONSchema which describes that Type. It’s also used for validation. There are core and custom Types. Type can be also a composition of other Types.
type TheOCFTypeManifestSchema struct {
	// Kind 
	Kind string `json:"kind"`

	// Metadata 
	Metadata *TheMetadataSchema `json:"metadata"`

	// OcfVersion 
	OcfVersion string `json:"ocfVersion"`

	// Revision Version of the manifest content in the SemVer format.
	Revision string `json:"revision"`

	// Signature Ensures the authenticity and integrity of a given manifest.
	Signature *TheSignatureSchema `json:"signature"`

	// Spec A container for the Implementation specification definition.
	Spec *TheSpecSchema `json:"spec"`

}

// ThePrefixSchema Prefix MUST be an abstract node and represents a core abstract Type e.g. cap.core.type.platform. Custom Types are not allowed.
type ThePrefixSchema struct {
	// AllOf All of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	AllOf []*RequireEntity `json:"allOf,omitempty"`

	// AnyOf Any (one or more) of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	AnyOf []*RequireEntity `json:"anyOf,omitempty"`

	// OneOf Exactly one of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	OneOf []*RequireEntity `json:"oneOf,omitempty"`

}

// TheSignatureSchema Ensures the authenticity and integrity of a given manifest.
type TheSignatureSchema struct {
	// Och 
	Och string `json:"och"`

}

// TheSpecSchema A container for the Implementation specification definition.
type TheSpecSchema struct {
	// Action An explanation about the purpose of this instance.
	Action *TheActionSchema `json:"action"`

	// AppVersion The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion"`

	// Implements Defines what kind of interfaces this implementation fulfills.
	Implements []*TheImplementsSchemaItems `json:"implements"`

	// Imports List of external Interfaces that this Implementation requires to be able to execute the action.
	Imports []*TheImportsSchemaItems `json:"imports,omitempty"`

	// Requires List of the system prerequisites that need to be present on the cluster. There has to be an Instance for every concrete type.
	Requires map[string]*ThePrefixSchema `json:"requires,omitempty"`

}

// TheValueSchema Holds the configuration constraints for the given entry. It needs to be valid against the Type JSONSchema.
type TheValueSchema struct {
}


// MarshalJSON serializes to JSON
func (s *HoldsContactInformation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s HoldsContactInformation) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Email field
	ct.More()
	stream.WriteObjectField("email")
	stream.WriteString(s.Email)

	// Marshal the Name field
	if !IsEmpty(s.Name) {
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)
	}

	// Marshal the Url field
	if !IsEmpty(s.Url) {
	ct.More()
	stream.WriteObjectField("url")
	stream.WriteString(s.Url)
	}
	stream.WriteObjectEnd()
}

func (s *HoldsContactInformation) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *HoldsContactInformation) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	EmailReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "email":
			s.Email = iter.ReadString()
			if iter.Error != nil {
				return
			}
			EmailReceived = true
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "url":
			s.Url = iter.ReadString()
			if iter.Error != nil {
				return
			}
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !EmailReceived {
		iter.ReportError("validating HoldsContactInformation", "\"email\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *RequireEntity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s RequireEntity) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)

	// Marshal the Revision field
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)

	// Marshal the Value field
	if !IsEmpty(s.Value) {
	ct.More()
	stream.WriteObjectField("value")
	stream.WriteVal(s.Value)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *RequireEntity) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *RequireEntity) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	NameReceived := false
	RevisionReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
			RevisionReceived = true
		case "value":
			iter.ReadVal(&s.Value)
			if iter.Error != nil {
				return
			}
		default:
			iter.ReportError("reading RequireEntity", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !NameReceived {
		iter.ReportError("validating RequireEntity", "\"name\" is required but was not present")
	}

	if !RevisionReceived {
		iter.ReportError("validating RequireEntity", "\"revision\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TagsItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TagsItem) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Revision field
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)
	stream.WriteObjectEnd()
}

func (s *TagsItem) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TagsItem) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	RevisionReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
			RevisionReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !RevisionReceived {
		iter.ReportError("validating TagsItem", "\"revision\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TheActionSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheActionSchema) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Args field

	// Args is required
	if s.Args == nil {
		stream.Error = errors.New("Args (args) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("args")
	stream.WriteVal(s.Args)
	if stream.Error != nil {
		return
	}

	// Marshal the Type field
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	stream.WriteObjectEnd()
}

func (s *TheActionSchema) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheActionSchema) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	ArgsReceived := false
	TypeReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "args":
			iter.ReadVal(&s.Args)
			if iter.Error != nil {
				return
			}
			ArgsReceived = true
		case "type":
			s.Type = iter.ReadString()
			if iter.Error != nil {
				return
			}
			TypeReceived = true
		default:
			iter.ReportError("reading TheActionSchema", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !ArgsReceived {
		iter.ReportError("validating TheActionSchema", "\"args\" is required but was not present")
	}

	if !TypeReceived {
		iter.ReportError("validating TheActionSchema", "\"type\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *TheImplementsSchemaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheImplementsSchemaItems) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)

	// Marshal the Revision field
	if !IsEmpty(s.Revision) {
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)
	}
	stream.WriteObjectEnd()
}

func (s *TheImplementsSchemaItems) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheImplementsSchemaItems) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	NameReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
		default:
			iter.ReportError("reading TheImplementsSchemaItems", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !NameReceived {
		iter.ReportError("validating TheImplementsSchemaItems", "\"name\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TheImportsSchemaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheImportsSchemaItems) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Alias field
	if !IsEmpty(s.Alias) {
	ct.More()
	stream.WriteObjectField("alias")
	stream.WriteString(s.Alias)
	}

	// Marshal the AppVersion field
	if !IsEmpty(s.AppVersion) {
	ct.More()
	stream.WriteObjectField("appVersion")
	stream.WriteString(s.AppVersion)
	}

	// Marshal the Methods field
	ct.More()
	stream.WriteObjectField("methods")
	stream.WriteVal(s.Methods)
	if stream.Error != nil {
		return
	}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)
	stream.WriteObjectEnd()
}

func (s *TheImportsSchemaItems) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheImportsSchemaItems) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	MethodsReceived := false
	NameReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "alias":
			s.Alias = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "appVersion":
			s.AppVersion = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "methods":
			iter.ReadVal(&s.Methods)
			if iter.Error != nil {
				return
			}
			MethodsReceived = true
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		default:
			iter.ReportError("reading TheImportsSchemaItems", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !MethodsReceived {
		iter.ReportError("validating TheImportsSchemaItems", "\"methods\" is required but was not present")
	}

	if !NameReceived {
		iter.ReportError("validating TheImportsSchemaItems", "\"name\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TheMetadataSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheMetadataSchema) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Description field
	ct.More()
	stream.WriteObjectField("description")
	stream.WriteString(s.Description)

	// Marshal the DisplayName field
	if !IsEmpty(s.DisplayName) {
	ct.More()
	stream.WriteObjectField("displayName")
	stream.WriteString(s.DisplayName)
	}

	// Marshal the DocumentationURL field
	if !IsEmpty(s.DocumentationURL) {
	ct.More()
	stream.WriteObjectField("documentationURL")
	stream.WriteString(s.DocumentationURL)
	}

	// Marshal the IconURL field
	if !IsEmpty(s.IconURL) {
	ct.More()
	stream.WriteObjectField("iconURL")
	stream.WriteString(s.IconURL)
	}

	// Marshal the License field

	// License is required
	if s.License == nil {
		stream.Error = errors.New("License (license) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("license")
	stream.WriteVal(s.License)
	if stream.Error != nil {
		return
	}

	// Marshal the Maintainers field
	ct.More()
	stream.WriteObjectField("maintainers")
	stream.WriteVal(s.Maintainers)
	if stream.Error != nil {
		return
	}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)

	// Marshal the Prefix field
	if !IsEmpty(s.Prefix) {
	ct.More()
	stream.WriteObjectField("prefix")
	stream.WriteString(s.Prefix)
	}

	// Marshal the SupportURL field
	if !IsEmpty(s.SupportURL) {
	ct.More()
	stream.WriteObjectField("supportURL")
	stream.WriteString(s.SupportURL)
	}

	// Marshal the Tags field
	if !IsEmpty(s.Tags) {
	ct.More()
	stream.WriteObjectField("tags")
	stream.WriteVal(s.Tags)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *TheMetadataSchema) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheMetadataSchema) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	DescriptionReceived := false
	LicenseReceived := false
	MaintainersReceived := false
	NameReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "description":
			s.Description = iter.ReadString()
			if iter.Error != nil {
				return
			}
			DescriptionReceived = true
		case "displayName":
			s.DisplayName = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "documentationURL":
			s.DocumentationURL = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "iconURL":
			s.IconURL = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "license":
			iter.ReadVal(&s.License)
			if iter.Error != nil {
				return
			}
			LicenseReceived = true
		case "maintainers":
			iter.ReadVal(&s.Maintainers)
			if iter.Error != nil {
				return
			}
			MaintainersReceived = true
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		case "prefix":
			s.Prefix = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "supportURL":
			s.SupportURL = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "tags":
			iter.ReadVal(&s.Tags)
			if iter.Error != nil {
				return
			}
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !DescriptionReceived {
		iter.ReportError("validating TheMetadataSchema", "\"description\" is required but was not present")
	}

	if !LicenseReceived {
		iter.ReportError("validating TheMetadataSchema", "\"license\" is required but was not present")
	}

	if !MaintainersReceived {
		iter.ReportError("validating TheMetadataSchema", "\"maintainers\" is required but was not present")
	}

	if !NameReceived {
		iter.ReportError("validating TheMetadataSchema", "\"name\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TheOCFTypeManifestSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheOCFTypeManifestSchema) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Kind field
	ct.More()
	stream.WriteObjectField("kind")
	stream.WriteString(s.Kind)

	// Marshal the Metadata field

	// Metadata is required
	if s.Metadata == nil {
		stream.Error = errors.New("Metadata (metadata) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("metadata")
	stream.WriteVal(s.Metadata)
	if stream.Error != nil {
		return
	}

	// Marshal the OcfVersion field
	ct.More()
	stream.WriteObjectField("ocfVersion")
	stream.WriteString(s.OcfVersion)

	// Marshal the Revision field
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)

	// Marshal the Signature field

	// Signature is required
	if s.Signature == nil {
		stream.Error = errors.New("Signature (signature) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("signature")
	stream.WriteVal(s.Signature)
	if stream.Error != nil {
		return
	}

	// Marshal the Spec field

	// Spec is required
	if s.Spec == nil {
		stream.Error = errors.New("Spec (spec) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("spec")
	stream.WriteVal(s.Spec)
	if stream.Error != nil {
		return
	}
	stream.WriteObjectEnd()
}

func (s *TheOCFTypeManifestSchema) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheOCFTypeManifestSchema) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	KindReceived := false
	MetadataReceived := false
	OcfVersionReceived := false
	RevisionReceived := false
	SignatureReceived := false
	SpecReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "kind":
			s.Kind = iter.ReadString()
			if s.Kind != "Implementation" {
				iter.ReportError(
					"kind",
					fmt.Sprintf("Expected %s, got \"%s\"", "Implementation", s.Kind),
				)
			}
			if iter.Error != nil {
				return
			}
			KindReceived = true
		case "metadata":
			iter.ReadVal(&s.Metadata)
			if iter.Error != nil {
				return
			}
			MetadataReceived = true
		case "ocfVersion":
			s.OcfVersion = iter.ReadString()
			if s.OcfVersion != "0.0.1" {
				iter.ReportError(
					"ocfVersion",
					fmt.Sprintf("Expected %s, got \"%s\"", "0.0.1", s.OcfVersion),
				)
			}
			if iter.Error != nil {
				return
			}
			OcfVersionReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
			RevisionReceived = true
		case "signature":
			iter.ReadVal(&s.Signature)
			if iter.Error != nil {
				return
			}
			SignatureReceived = true
		case "spec":
			iter.ReadVal(&s.Spec)
			if iter.Error != nil {
				return
			}
			SpecReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !KindReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"kind\" is required but was not present")
	}

	if !MetadataReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"metadata\" is required but was not present")
	}

	if !OcfVersionReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"ocfVersion\" is required but was not present")
	}

	if !RevisionReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"revision\" is required but was not present")
	}

	if !SignatureReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"signature\" is required but was not present")
	}

	if !SpecReceived {
		iter.ReportError("validating TheOCFTypeManifestSchema", "\"spec\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *TheSignatureSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheSignatureSchema) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Och field
	ct.More()
	stream.WriteObjectField("och")
	stream.WriteString(s.Och)
	stream.WriteObjectEnd()
}

func (s *TheSignatureSchema) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheSignatureSchema) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	OchReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "och":
			s.Och = iter.ReadString()
			if iter.Error != nil {
				return
			}
			OchReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !OchReceived {
		iter.ReportError("validating TheSignatureSchema", "\"och\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *TheSpecSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s TheSpecSchema) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Action field

	// Action is required
	if s.Action == nil {
		stream.Error = errors.New("Action (action) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("action")
	stream.WriteVal(s.Action)
	if stream.Error != nil {
		return
	}

	// Marshal the AppVersion field
	ct.More()
	stream.WriteObjectField("appVersion")
	stream.WriteString(s.AppVersion)

	// Marshal the Implements field
	ct.More()
	stream.WriteObjectField("implements")
	stream.WriteVal(s.Implements)
	if stream.Error != nil {
		return
	}

	// Marshal the Imports field
	if !IsEmpty(s.Imports) {
	ct.More()
	stream.WriteObjectField("imports")
	stream.WriteVal(s.Imports)
	if stream.Error != nil {
		return
	}
	}

	// Marshal the Requires field
	if !IsEmpty(s.Requires) {
	ct.More()
	stream.WriteObjectField("requires")
	stream.WriteVal(s.Requires)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *TheSpecSchema) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *TheSpecSchema) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	ActionReceived := false
	AppVersionReceived := false
	ImplementsReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "action":
			iter.ReadVal(&s.Action)
			if iter.Error != nil {
				return
			}
			ActionReceived = true
		case "appVersion":
			s.AppVersion = iter.ReadString()
			if iter.Error != nil {
				return
			}
			AppVersionReceived = true
		case "implements":
			iter.ReadVal(&s.Implements)
			if iter.Error != nil {
				return
			}
			ImplementsReceived = true
		case "imports":
			iter.ReadVal(&s.Imports)
			if iter.Error != nil {
				return
			}
		case "requires":
			iter.ReadVal(&s.Requires)
			if iter.Error != nil {
				return
			}
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !ActionReceived {
		iter.ReportError("validating TheSpecSchema", "\"action\" is required but was not present")
	}

	if !AppVersionReceived {
		iter.ReportError("validating TheSpecSchema", "\"appVersion\" is required but was not present")
	}

	if !ImplementsReceived {
		iter.ReportError("validating TheSpecSchema", "\"implements\" is required but was not present")
	}
}
