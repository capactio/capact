// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package gojsonschema

import "fmt"
import "encoding/json"
import "reflect"

// The description of an action and its prerequisites (dependencies). An
// implementation implements at least one interface.
type ImplementationJson struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind ImplementationJsonKind `json:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata ImplementationJsonMetadata `json:"metadata"`

	// OcfVersion corresponds to the JSON schema field "ocfVersion".
	OcfVersion string `json:"ocfVersion"`

	// Version of the manifest content in the SemVer format.
	Revision string `json:"revision"`

	// Ensures the authenticity and integrity of a given manifest.
	Signature ImplementationJsonSignature `json:"signature"`

	// A container for the Implementation specification definition.
	Spec ImplementationJsonSpec `json:"spec"`
}

type ImplementationJsonKind string

const ImplementationJsonKindImplementation ImplementationJsonKind = "Implementation"

type ImplementationJsonMetadata map[string]interface{}

// Ensures the authenticity and integrity of a given manifest.
type ImplementationJsonSignature struct {
	// Och corresponds to the JSON schema field "och".
	Och string `json:"och"`
}

// A container for the Implementation specification definition.
type ImplementationJsonSpec struct {
	// An explanation about the purpose of this instance.
	Action ImplementationJsonSpecAction `json:"action"`

	// The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion"`

	// Defines what kind of interfaces this implementation fulfills.
	Implements []ImplementationJsonSpecImplementsElem `json:"implements"`

	// List of external Interfaces that this Implementation requires to be able to
	// execute the action.
	Imports []ImplementationJsonSpecImportsElem `json:"imports,omitempty"`

	// List of the system prerequisites that need to be present on the cluster. There
	// has to be an Instance for every concrete type.
	Requires ImplementationJsonSpecRequires `json:"requires,omitempty"`
}

// An explanation about the purpose of this instance.
type ImplementationJsonSpecAction struct {
	// Holds all parameters that should be passed to the selected runner, for example
	// repoUrl, or chartName for the Helm3 runner.
	Args ImplementationJsonSpecActionArgs `json:"args"`

	// The Interface or Implementation of a runner, which handles the execution, for
	// example, cap.interface.runner.helm3.run
	Type string `json:"type"`
}

// Holds all parameters that should be passed to the selected runner, for example
// repoUrl, or chartName for the Helm3 runner.
type ImplementationJsonSpecActionArgs map[string]interface{}

type ImplementationJsonSpecImplementsElem struct {
	// The Interface name, for example cap.interfaces.db.mysql.install
	Name string `json:"name"`

	// The Interface revision.
	Revision *string `json:"revision,omitempty"`
}

type ImplementationJsonSpecImportsElem struct {
	// The alias for the full name of the imported group name. It can be used later in
	// the workflow definition instead of using full name.
	Alias *string `json:"alias,omitempty"`

	// The supported application versions in SemVer2 format.
	AppVersion *string `json:"appVersion,omitempty"`

	// The list of all required actions’ names that must be imported.
	Methods []string `json:"methods"`

	// The name of the group that holds specific actions that you want to import, for
	// example cap.interfaces.db.mysql
	Name string `json:"name"`
}

// List of the system prerequisites that need to be present on the cluster. There
// has to be an Instance for every concrete type.
type ImplementationJsonSpecRequires map[string]interface{}

type RequireEntity struct {
	// The name of the Type. Root prefix can be skipped if it’s a core Type. If it is
	// a custom Type then it MUST be defined as full path to that Type. Custom Type
	// MUST extend the abstract node which is defined as a root prefix for that entry.
	Name string `json:"name"`

	// The revision version of the given Type.
	Revision string `json:"revision"`

	// Holds the configuration constraints for the given entry. It needs to be valid
	// against the Type JSONSchema.
	Value RequireEntityValue `json:"value,omitempty"`
}

// Holds the configuration constraints for the given entry. It needs to be valid
// against the Type JSONSchema.
type RequireEntityValue map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecAction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain ImplementationJsonSpecAction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecAction(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecImplementsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ImplementationJsonSpecImplementsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecImplementsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSignature) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["och"]; !ok || v == nil {
		return fmt.Errorf("field och: required")
	}
	type Plain ImplementationJsonSignature
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSignature(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpecImportsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["methods"]; !ok || v == nil {
		return fmt.Errorf("field methods: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ImplementationJsonSpecImportsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpecImportsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ImplementationJsonKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ImplementationJsonKind, v)
	}
	*j = ImplementationJsonKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RequireEntity) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["revision"]; !ok || v == nil {
		return fmt.Errorf("field revision: required")
	}
	type Plain RequireEntity
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RequireEntity(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJsonSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["action"]; !ok || v == nil {
		return fmt.Errorf("field action: required")
	}
	if v, ok := raw["appVersion"]; !ok || v == nil {
		return fmt.Errorf("field appVersion: required")
	}
	if v, ok := raw["implements"]; !ok || v == nil {
		return fmt.Errorf("field implements: required")
	}
	type Plain ImplementationJsonSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJsonSpec(plain)
	return nil
}

var enumValues_ImplementationJsonKind = []interface{}{
	"Implementation",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImplementationJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata: required")
	}
	if v, ok := raw["ocfVersion"]; !ok || v == nil {
		return fmt.Errorf("field ocfVersion: required")
	}
	if v, ok := raw["revision"]; !ok || v == nil {
		return fmt.Errorf("field revision: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec: required")
	}
	type Plain ImplementationJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImplementationJson(plain)
	return nil
}
