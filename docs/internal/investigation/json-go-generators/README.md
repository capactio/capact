# Generators from JSON Schema to Go structs

This document describes the available open-source libraries that are able to generate the Go structs from the [JSON Schema draft-07](https://json-schema.org/draft-07/json-schema-release-notes.html).

## Motivation

The OCF Manifests are described using JSON Schemas draft-07. To improve our development process we should be able to 
generate Go code from our [OCF JSON Schemas](../../../ocf-spec/0.0.1/schema). In that way, we can maintain a single source of truth for our OCF manifests.

## Suggested solution
 
Additional research showed that other specifications such as AsyncAPI, CNAB, CloudEvents are just not using any complex syntax from JSON Schema. Some of them are not even generating Go struct from that schemas.

Based on the [comparison](#comparison) between different libraries, I selected the most powerful one and removed all unsupported features from JSON Schemas:

- replace the `const` with `enum` 
- get rid of `patternProperties` and replace with `additionalProperties` 
- get rid of the `title` property and leave only `description`
- remove the `allOf` from the root of the schema at the expense of the DRY concept. Now the root fields need to be redefined in each OCF Schema file.
- defined `$ref` with a reference to `https` URLs
 
The best option is a `quicktype` generator. Check the [comparison](#comparison) section for more details about the pros and cons.

The most problematic part of `quicktype` is that, it does not provide a dedicated Unmarshal/Marshal methods with a proper validation. Instead, we will need
to use the JSON Schema validator. This can be more CPU and memory consuming, but we can compile the schemas and create a benchmark tests to select the best library for validation. There are already benchmarks for most popular validators [here](https://github.com/wbvinc/go-jsonschema-validator-benchmarks).

## Investigation

I was not able to find any open-source library that supports `patternProperties`, `const`, `allOf`, `anyOf` and `oneOf` features.  The possible workaround was to:

- Get rid of more complex statements
    
    Status: **Accepted**
    
    Note: Based on the comparison between different libraries, I selected the most powerful one and removed all unsupported features from JSON Schemas.  

- Convert JSON Schema to proto and then to Go struct
    
    Status: **Rejected**
    
    Note: There is no mature library for converting JSON Schemas to proto files. 

- Convert JSON Schema to Open API 3.0 and then to Go struct
    
    Status: **Rejected**
    
    Note: There is a lib [json-schema-to-openapi-schema](https://github.com/openapi-contrib/json-schema-to-openapi-schema) which is working quite well,
     but still most of the features are not supported by [OpenAPI 3.0 generator](https://github.com/OpenAPITools/openapi-generator). Additionally, we need 
     to simulate a full OpenAPI spec, so it means that we need to model an endpoint that is returning all those OCF objects. This is overkill for now.  

- Fork a given lib and add adjust for our needs

    Status: **Rejected**
    
    Note: Too much time-consuming. This can be done later as a part of hardening.

- Generate types and add missing structures manually 

    Status: **Rejected**
    
    Note: Too much time-consuming, it's error-prone and slows down the development process.


## Comparison

This section contains the result of the comparison between different libraries that generates Go structs from JSON Schemas.

### go-jsonschema

Github: https://github.com/atombender/go-jsonschema

Last release: v0.7.0 on Mar 12, 2019

Last update: Mar 29, 2020

#### Generation

The Go structs were generated by executing this command:
```
gojsonschema -p types ./ocf-spec/0.0.1/schema/implementation.json > ./docs/investigation/json-generators/assets/gojsonschema/_implementation.go
``` 

The output is [available here](./assets/gojsonschema/_implementation.go).

#### Pros 

1. The generated boilerplate struct is smaller and more readable than the schema-generate.
2. Support dedicated Marhshal/Unmarshal methods.
3. Expose options to customize to Go struct output

#### Cons 

1. Fail fast during Unmarshal action. If first element in struct is invalid then rest elements are not checked.
2. Does not support `additionalItems` field, returns error:
   ```
   json: cannot unmarshal bool into Go struct field Type.properties.allOf.properties.properties.additionalItems of type schemas.Type
   ```
3. Does not support the `allOf`, `anyOf` and `oneOf` features. All properties are skipped from the generation process.
4. Does not support additionalProperties feature.
5. Does not support overriding the extensions that should be used for `$ref` property. 

### generate

Github: https://github.com/a-h/generate

Last release: none

Last update: Feb 4, 2019

#### Generation

The Go structs were generated by executing this command:
```
schema-generate ./ocf-spec/0.0.1/schema/implementation.json > ./docs/investigation/json-generators/assets/schema-generate/_implementation.go
``` 

The output is [available here](./assets/schema-generate/_implementation.go).

#### Pros
 
1. Checks for all validation problems during Unmarhal action.
2. Support dedicate Marshal/Unmarshal methods.
3. Expose options to customize to Go struct output

#### Cons 

1. Generates a lof of boilerplate.
2. Struct are named by the description.  
3. Does not support the `allOf`, `anyOf` and `oneOf` features.
4. Does not support enum and const.
5. Uses `title` property for naming types.
6. Does not support overriding the extensions that should be used for `$ref` property. 


#### Forks

Github: https://github.com/orus-io/json-schema-generate

Last release: none

Last update: Apr 22, 2020

#### Pros

1. Fixes bugs and adds features:
    - Add UnmarshalJSONIterator to OneOfStringNull
    - Support enum validation
    - Support oneOf
    - Add other empty types
    - Use jsoniter.ValueType instead of our own DataType
    - Implements a omit empty mechanism

#### Cons

1. Generates a lof of boilerplate.
2. Struct are named by the description.
3. Does not support the `allOf` and `anyOf` features.
4. Limited support for `oneOf` feature.
5. Does not support `const`.
6. Uses `title` property for naming types.

### quicktype

Github: https://github.com/quicktype/quicktype

Last release: Sep 5, 2020

Last update: Oct 6, 2020 

#### Generation

The Go structs were generated by executing this command:
```
quicktype -o ./docs/investigation/json-generators/assets/quicktype/_implementation.go -l go -s schema --package types --src ./ocf-spec/0.0.1/schema/implementation.json -S ./ocf-spec/0.0.1/schema/common/metadata.json -S ./ocf-spec/0.0.1/schema/common/json-schema-type.json
``` 

The output is [available here](./assets/quicktype/_implementation.go).

#### Pros

1. Supports the allOf, oneOf, anyOf at least in the minimal way.
2. Combine similar structs if they are common between different schemas.
3. Supports overriding the extensions that should be used for `$ref` property. 
    
#### Cons

1. Do not generate dedicated Marshal/Unmarshal methods with validation rules.
2. Uses `title` property for naming types.
3. Does not support `const`.
    
#### Known Issues
    
1. OneOf generates the struct with both fields as a pointer and there is no validator that both cannot be set, e.g.

    From such JSON Schema:
    ```
    "license": {
                  "$id": "#/properties/metadata/properties/license",
                  "type": "object",
                  "description": "This entry allows you to specify a license, so people know how they are permitted to use it, and what kind of restrictions you are placing on it.",
                  "oneOf": [
                    {
                      "required": [
                        "name"
                      ],
                      "properties": {
                        "name": {
                          "$id": "#/properties/metadata/properties/license/name",
                          "type": "string",
                          "description": "If you are using a common license such as BSD-2-Clause or MIT, add a current SPDX license identifier for the license you’re using e.g. BSD-3-Clause. If your package is licensed under multiple common licenses, use an SPDX license expression syntax version 2.0 string, e.g. (ISC OR GPL-3.0)"
                        }
                      }
                    },
                    {
                      "required": [
                        "ref"
                      ],
                      "properties": {
                        "ref": {
                          "$id": "#/properties/metadata/properties/license/ref",
                          "type": "string",
                          "description": "If you are using a license that hasn’t been assigned an SPDX identifier, or if you are using a custom license, use the direct link to the license file e.g. https://raw.githubusercontent.com/project/v1/license.md. The resource under given link MUST be immutable and publicly accessible."
                        }
                      }
                    }
                  ]
                }
    ```
    
    generates such struct:
    ```
    type License struct {
        Name *string `json:"name,omitempty"`// If you are using a common license such as BSD-2-Clause or MIT, add a current SPDX license; identifier for the license you’re using e.g. BSD-3-Clause. If your package is licensed; under multiple common licenses, use an SPDX license expression syntax version 2.0 string,; e.g. (ISC OR GPL-3.0)
        Ref  *string `json:"ref,omitempty"` // If you are using a license that hasn’t been assigned an SPDX identifier, or if you are; using a custom license, use the direct link to the license file e.g.; https://raw.githubusercontent.com/project/v1/license.md. The resource under given link; MUST be immutable and publicly accessible.
    }
    ```

### Schematic

Github: https://github.com/interagent/schematic/
 
>**NOTE:** Does not support references. This library focuses on client generation and not the Go structs.
