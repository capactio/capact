// Code generated by GoGM v1.0.1. DO NOT EDIT
package graphql

import (
	"errors"
)

//LinkToInterfaceGroupOnFieldInterfaceGroup links GenericMetadata to InterfaceGroup on the fields GenericMetadata.InterfaceGroup and InterfaceGroup.Metadata
func (l *GenericMetadata) LinkToInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = target

	target.Metadata = l

	return nil
}

//UnlinkFromInterfaceGroupOnFieldInterfaceGroup unlinks GenericMetadata from InterfaceGroup on the fields GenericMetadata.InterfaceGroup and InterfaceGroup.Metadata
func (l *GenericMetadata) UnlinkFromInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = nil

	target.Metadata = nil

	return nil
}

//LinkToInterfaceRevisionOnFieldInterfaceRevision links GenericMetadata to InterfaceRevision on the fields GenericMetadata.InterfaceRevision and InterfaceRevision.Metadata
func (l *GenericMetadata) LinkToInterfaceRevisionOnFieldInterfaceRevision(target *InterfaceRevision) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceRevision = target

	target.Metadata = l

	return nil
}

//UnlinkFromInterfaceRevisionOnFieldInterfaceRevision unlinks GenericMetadata from InterfaceRevision on the fields GenericMetadata.InterfaceRevision and InterfaceRevision.Metadata
func (l *GenericMetadata) UnlinkFromInterfaceRevisionOnFieldInterfaceRevision(target *InterfaceRevision) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceRevision = nil

	target.Metadata = nil

	return nil
}

// LinkToMaintainerOnFieldMaintainers links GenericMetadata to Maintainer on the fields GenericMetadata.Maintainers and Maintainer.GenericMetadata
func (l *GenericMetadata) LinkToMaintainerOnFieldMaintainers(targets ...*Maintainer) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Maintainers == nil {
			l.Maintainers = make([]*Maintainer, 1, 1)
			l.Maintainers[0] = target
		} else {
			l.Maintainers = append(l.Maintainers, target)
		}

		target.GenericMetadata = l
	}

	return nil
}

//UnlinkFromMaintainerOnFieldMaintainers unlinks GenericMetadata from Maintainer on the fields GenericMetadata.Maintainers and Maintainer.GenericMetadata
func (l *GenericMetadata) UnlinkFromMaintainerOnFieldMaintainers(targets ...*Maintainer) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Maintainers != nil {
			for i, unlinkTarget := range l.Maintainers {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Maintainers
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.GenericMetadata = nil
	}

	return nil
}

//LinkToInterfaceGroupOnFieldInterfaceGroup links Interface to InterfaceGroup on the fields Interface.InterfaceGroup and InterfaceGroup.Interfaces
func (l *Interface) LinkToInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = target

	if target.Interfaces == nil {
		target.Interfaces = make([]*Interface, 1, 1)
		target.Interfaces[0] = l
	} else {
		target.Interfaces = append(target.Interfaces, l)
	}

	return nil
}

//UnlinkFromInterfaceGroupOnFieldInterfaceGroup unlinks Interface from InterfaceGroup on the fields Interface.InterfaceGroup and InterfaceGroup.Interfaces
func (l *Interface) UnlinkFromInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = nil

	if target.Interfaces != nil {
		for i, unlinkTarget := range target.Interfaces {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Interfaces
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToInterfaceRevisionOnFieldRevisions links Interface to InterfaceRevision on the fields Interface.Revisions and InterfaceRevision.Interface
func (l *Interface) LinkToInterfaceRevisionOnFieldRevisions(targets ...*InterfaceRevision) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Revisions == nil {
			l.Revisions = make([]*InterfaceRevision, 1, 1)
			l.Revisions[0] = target
		} else {
			l.Revisions = append(l.Revisions, target)
		}

		target.Interface = l
	}

	return nil
}

//UnlinkFromInterfaceRevisionOnFieldRevisions unlinks Interface from InterfaceRevision on the fields Interface.Revisions and InterfaceRevision.Interface
func (l *Interface) UnlinkFromInterfaceRevisionOnFieldRevisions(targets ...*InterfaceRevision) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Revisions != nil {
			for i, unlinkTarget := range l.Revisions {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Revisions
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Interface = nil
	}

	return nil
}

//LinkToSignatureOnFieldSignature links InterfaceGroup to Signature on the fields InterfaceGroup.Signature and Signature.InterfaceGroup
func (l *InterfaceGroup) LinkToSignatureOnFieldSignature(target *Signature) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Signature = target

	target.InterfaceGroup = l

	return nil
}

//UnlinkFromSignatureOnFieldSignature unlinks InterfaceGroup from Signature on the fields InterfaceGroup.Signature and Signature.InterfaceGroup
func (l *InterfaceGroup) UnlinkFromSignatureOnFieldSignature(target *Signature) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Signature = nil

	target.InterfaceGroup = nil

	return nil
}

//LinkToGenericMetadataOnFieldMetadata links InterfaceGroup to GenericMetadata on the fields InterfaceGroup.Metadata and GenericMetadata.InterfaceGroup
func (l *InterfaceGroup) LinkToGenericMetadataOnFieldMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Metadata = target

	target.InterfaceGroup = l

	return nil
}

//UnlinkFromGenericMetadataOnFieldMetadata unlinks InterfaceGroup from GenericMetadata on the fields InterfaceGroup.Metadata and GenericMetadata.InterfaceGroup
func (l *InterfaceGroup) UnlinkFromGenericMetadataOnFieldMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Metadata = nil

	target.InterfaceGroup = nil

	return nil
}

// LinkToInterfaceOnFieldInterfaces links InterfaceGroup to Interface on the fields InterfaceGroup.Interfaces and Interface.InterfaceGroup
func (l *InterfaceGroup) LinkToInterfaceOnFieldInterfaces(targets ...*Interface) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Interfaces == nil {
			l.Interfaces = make([]*Interface, 1, 1)
			l.Interfaces[0] = target
		} else {
			l.Interfaces = append(l.Interfaces, target)
		}

		target.InterfaceGroup = l
	}

	return nil
}

//UnlinkFromInterfaceOnFieldInterfaces unlinks InterfaceGroup from Interface on the fields InterfaceGroup.Interfaces and Interface.InterfaceGroup
func (l *InterfaceGroup) UnlinkFromInterfaceOnFieldInterfaces(targets ...*Interface) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Interfaces != nil {
			for i, unlinkTarget := range l.Interfaces {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Interfaces
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.InterfaceGroup = nil
	}

	return nil
}

//LinkToGenericMetadataOnFieldMetadata links InterfaceRevision to GenericMetadata on the fields InterfaceRevision.Metadata and GenericMetadata.InterfaceRevision
func (l *InterfaceRevision) LinkToGenericMetadataOnFieldMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Metadata = target

	target.InterfaceRevision = l

	return nil
}

//UnlinkFromGenericMetadataOnFieldMetadata unlinks InterfaceRevision from GenericMetadata on the fields InterfaceRevision.Metadata and GenericMetadata.InterfaceRevision
func (l *InterfaceRevision) UnlinkFromGenericMetadataOnFieldMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Metadata = nil

	target.InterfaceRevision = nil

	return nil
}

//LinkToInterfaceOnFieldInterface links InterfaceRevision to Interface on the fields InterfaceRevision.Interface and Interface.Revisions
func (l *InterfaceRevision) LinkToInterfaceOnFieldInterface(target *Interface) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Interface = target

	if target.Revisions == nil {
		target.Revisions = make([]*InterfaceRevision, 1, 1)
		target.Revisions[0] = l
	} else {
		target.Revisions = append(target.Revisions, l)
	}

	return nil
}

//UnlinkFromInterfaceOnFieldInterface unlinks InterfaceRevision from Interface on the fields InterfaceRevision.Interface and Interface.Revisions
func (l *InterfaceRevision) UnlinkFromInterfaceOnFieldInterface(target *Interface) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Interface = nil

	if target.Revisions != nil {
		for i, unlinkTarget := range target.Revisions {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Revisions
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

//LinkToGenericMetadataOnFieldGenericMetadata links Maintainer to GenericMetadata on the fields Maintainer.GenericMetadata and GenericMetadata.Maintainers
func (l *Maintainer) LinkToGenericMetadataOnFieldGenericMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.GenericMetadata = target

	if target.Maintainers == nil {
		target.Maintainers = make([]*Maintainer, 1, 1)
		target.Maintainers[0] = l
	} else {
		target.Maintainers = append(target.Maintainers, l)
	}

	return nil
}

//UnlinkFromGenericMetadataOnFieldGenericMetadata unlinks Maintainer from GenericMetadata on the fields Maintainer.GenericMetadata and GenericMetadata.Maintainers
func (l *Maintainer) UnlinkFromGenericMetadataOnFieldGenericMetadata(target *GenericMetadata) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.GenericMetadata = nil

	if target.Maintainers != nil {
		for i, unlinkTarget := range target.Maintainers {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Maintainers
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

//LinkToInterfaceGroupOnFieldInterfaceGroup links Signature to InterfaceGroup on the fields Signature.InterfaceGroup and InterfaceGroup.Signature
func (l *Signature) LinkToInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = target

	target.Signature = l

	return nil
}

//UnlinkFromInterfaceGroupOnFieldInterfaceGroup unlinks Signature from InterfaceGroup on the fields Signature.InterfaceGroup and InterfaceGroup.Signature
func (l *Signature) UnlinkFromInterfaceGroupOnFieldInterfaceGroup(target *InterfaceGroup) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.InterfaceGroup = nil

	target.Signature = nil

	return nil
}
