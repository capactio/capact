// Code generated by schema-generate. DO NOT EDIT.

package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"reflect"
)

func ValueTypeToString(valueType jsoniter.ValueType) string {
	switch valueType {
	case jsoniter.StringValue:
		return "string"
	case jsoniter.NumberValue:
		return "number"
	case jsoniter.NilValue:
		return "nil"
	case jsoniter.BoolValue:
		return "bool"
	case jsoniter.ArrayValue:
		return "array"
	case jsoniter.ObjectValue:
		return "object"
	default:
		return "invalid"
	}
}

type commaTracker struct {
	stream *jsoniter.Stream
	started bool
}

func (t *commaTracker) More() {
	if t.started {
		t.stream.WriteMore()
	} else {
		t.started = true
	}
}

type isEmptyChecker interface {
	IsEmpty() bool
}

// IsEmpty reports whether v is zero struct
// Does not support cycle pointers for performance, so as json
func IsEmpty(v interface{}) bool {
	if i, ok := v.(isEmptyChecker); ok {
		return i.IsEmpty()
	}
	rv := reflect.ValueOf(v)
	return !rv.IsValid() || rv.IsZero()
}

var (
	jsonNullValue = []byte("null")
)

// NewEmptyBool creates a non-empty EmptyBool
func NewEmptyBool(value bool) EmptyBool {
	return EmptyBool{value, true}
}

// EmptyBool is bool or nothing
type EmptyBool struct {
	Bool bool
	Valid bool // Valid is true if Bool is not empty
}

func (t EmptyBool) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyBool) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Bool)
	}
	return []byte("\"\""), nil
}

func (t *EmptyBool) Set(value bool) {
	t.Bool = value
	t.Valid = true
}

func (t *EmptyBool) Unset() {
	t.Bool = false
	t.Valid = false
}

func (t EmptyBool) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteBool(t.Bool)
	} else {
		stream.WriteBool(false)
	}
}

func (t *EmptyBool) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Bool = iter.ReadBool()
	t.Valid = iter.Error == nil
}

func (t *EmptyBool) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Bool); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyFloat64 creates a non-empty EmptyFloat64
func NewEmptyFloat64(value float64) EmptyFloat64 {
	return EmptyFloat64{value, true}
}

// EmptyFloat64 is float64 or nothing
type EmptyFloat64 struct {
	Float64 float64
	Valid bool // Valid is true if Float64 is not empty
}

func (t EmptyFloat64) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyFloat64) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Float64)
	}
	return []byte("\"\""), nil
}

func (t *EmptyFloat64) Set(value float64) {
	t.Float64 = value
	t.Valid = true
}

func (t *EmptyFloat64) Unset() {
	t.Float64 = 0.0
	t.Valid = false
}

func (t EmptyFloat64) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteFloat64(t.Float64)
	} else {
		stream.WriteFloat64(0.0)
	}
}

func (t *EmptyFloat64) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Float64 = iter.ReadFloat64()
	t.Valid = iter.Error == nil
}

func (t *EmptyFloat64) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Float64); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyInt creates a non-empty EmptyInt
func NewEmptyInt(value int) EmptyInt {
	return EmptyInt{value, true}
}

// EmptyInt is int or nothing
type EmptyInt struct {
	Int int
	Valid bool // Valid is true if Int is not empty
}

func (t EmptyInt) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyInt) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Int)
	}
	return []byte("\"\""), nil
}

func (t *EmptyInt) Set(value int) {
	t.Int = value
	t.Valid = true
}

func (t *EmptyInt) Unset() {
	t.Int = 0
	t.Valid = false
}

func (t EmptyInt) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteInt(t.Int)
	} else {
		stream.WriteInt(0)
	}
}

func (t *EmptyInt) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Int = iter.ReadInt()
	t.Valid = iter.Error == nil
}

func (t *EmptyInt) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Int); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyString creates a non-empty EmptyString
func NewEmptyString(value string) EmptyString {
	return EmptyString{value, true}
}

// EmptyString is string or nothing
type EmptyString struct {
	String string
	Valid bool // Valid is true if String is not empty
}

func (t EmptyString) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyString) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.String)
	}
	return []byte("\"\""), nil
}

func (t *EmptyString) Set(value string) {
	t.String = value
	t.Valid = true
}

func (t *EmptyString) Unset() {
	t.String = ""
	t.Valid = false
}

func (t EmptyString) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteString(t.String)
	} else {
		stream.WriteString("")
	}
}

func (t *EmptyString) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.String = iter.ReadString()
	t.Valid = iter.Error == nil
}

func (t *EmptyString) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.String); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// OneOfStringNull is a 'string' or a 'null', and can be emptied
type OneOfStringNull struct {
	currentType jsoniter.ValueType
	stringValue string
}

// NewOneOfStringNull creates a empty OneOfStringNull
func NewOneOfStringNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.InvalidValue, ""}
}

// NewOneOfStringNullString creates a OneOfStringNull of type string
func NewOneOfStringNullString(value string) OneOfStringNull {
	return OneOfStringNull{jsoniter.StringValue, value}
}

// NewOneOfStringNullNull creates a OneOfStringNull of type null
func NewOneOfStringNullNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.NilValue, ""}
}

// IsEmpty returns true if the value is empty
func (value *OneOfStringNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfStringNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsString returns true if the value is a string
func (value *OneOfStringNull) IsString() bool {
	return value.currentType == jsoniter.StringValue
}

// StringValue returns the current value if IsString() is true, "" otherwise
func (value *OneOfStringNull) StringValue() string {
	if value.currentType == jsoniter.StringValue {
		return value.stringValue
	}
	return ""
}

// NullString returns the current value as a sql.NullString
func (value *OneOfStringNull) NullString() sql.NullString {
	return sql.NullString{
		Valid:  value.currentType == jsoniter.StringValue,
		String: value.stringValue,
	}
}

// MarshalJSONStream serializes to a jsoniter Stream
func (value OneOfStringNull) MarshalJSONStream(stream *jsoniter.Stream) {
	if value.currentType == jsoniter.StringValue {
		stream.WriteString(value.stringValue)
	} else {
		stream.WriteNil()
	}
}

// MarshalJSON serialize to json
func (value OneOfStringNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.StringValue:
		return jsoniter.Marshal(value.stringValue)
	}
	return nil, fmt.Errorf(
		"OneOfStringNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

func (value *OneOfStringNull) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	switch t := iter.WhatIsNext(); t {
	case jsoniter.NilValue:
		iter.ReadNil()
		value.currentType = jsoniter.NilValue
	case jsoniter.StringValue:
		value.currentType = jsoniter.StringValue
		value.stringValue = iter.ReadString()
	default:
		iter.ReportError("Read", fmt.Sprintf("unexpected value type: %v", t))
	}
}

// UnmarshalJSON unserialize a OneOfStringNull from json
func (value *OneOfStringNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.stringValue); err != nil {
			return err
		}
		value.currentType = jsoniter.StringValue
	}
	return nil
}

// OneOfNumberNull is a 'string' or a 'null', and can be emptied
type OneOfNumberNull struct {
	currentType jsoniter.ValueType
	numberValue float64
}

// NewOneOfNumberNull creates a empty OneOfNumberNull
func NewOneOfNumberNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.InvalidValue, 0}
}

// NewOneOfNumberNullNumber creates a OneOfNumberNull of type number
func NewOneOfNumberNullNumber(value float64) OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NumberValue, value}
}

// NewOneOfNumberNullNull creates a OneOfNumberNull of type null
func NewOneOfNumberNullNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NilValue, 0}
}

// IsEmpty returns true if the value is empty
func (value *OneOfNumberNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfNumberNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsNumber returns true if the value is a number
func (value *OneOfNumberNull) IsNumber() bool {
	return value.currentType == jsoniter.NumberValue
}

// NumberValue returns the current value if IsNumber() is true, 0 otherwise
func (value *OneOfNumberNull) NumberValue() float64 {
	if value.currentType == jsoniter.NumberValue {
		return value.numberValue
	}
	return 0
}

// MarshalJSON serialize to json
func (value OneOfNumberNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.NumberValue:
		return jsoniter.Marshal(value.numberValue)
	}
	return nil, fmt.Errorf(
		"OneOfNumberNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfNumberNull from json
func (value *OneOfNumberNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.numberValue); err != nil {
			return err
		}
		value.currentType = jsoniter.NumberValue
	}
	return nil
}

// OneOfBoolNull is a 'bool' or a 'null', and can be emptied
type OneOfBoolNull struct {
	currentType jsoniter.ValueType
	boolValue   bool
}

// NewOneOfBoolNull creates a empty OneOfBoolNull
func NewOneOfBoolNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.InvalidValue, false}
}

// NewOneOfBoolNullBool creates a OneOfBoolNull of type number
func NewOneOfBoolNullBool(value bool) OneOfBoolNull {
	return OneOfBoolNull{jsoniter.BoolValue, value}
}

// NewOneOfBoolNullNull creates a OneOfBoolNull of type null
func NewOneOfBoolNullNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.NilValue, false}
}

// IsEmpty returns true if the value is empty
func (value *OneOfBoolNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfBoolNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsBool returns true if the value is a bool
func (value *OneOfBoolNull) IsBool() bool {
	return value.currentType == jsoniter.BoolValue
}

// BoolValue returns the current value if IsBool() is true, false otherwise
func (value *OneOfBoolNull) BoolValue() bool {
	if value.currentType == jsoniter.BoolValue {
		return value.boolValue
	}
	return false
}

// MarshalJSON serialize to json
func (value OneOfBoolNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.BoolValue:
		return jsoniter.Marshal(value.boolValue)
	}
	return nil, fmt.Errorf(
		"OneOfBoolNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfBoolNull from json
func (value *OneOfBoolNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.boolValue); err != nil {
			return err
		}
		value.currentType = jsoniter.BoolValue
	}
	return nil
}

// Action An explanation about the purpose of this instance.
type Action struct {
	// Args Holds all parameters that should be passed to the selected runner, for example repoUrl, or chartName for the Helm3 runner.
	Args *Args `json:"args"`

	// Type The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
	Type string `json:"type"`

}

// Args Holds all parameters that should be passed to the selected runner, for example repoUrl, or chartName for the Helm3 runner.
type Args struct {
}

// ImplementsItems 
type ImplementsItems struct {
	// Name The Interface name, for example cap.interfaces.db.mysql.install
	Name string `json:"name"`

	// Revision The Interface revision.
	Revision string `json:"revision,omitempty"`

}

// ImportsItems 
type ImportsItems struct {
	// Alias The alias for the full name of the imported group name. It can be used later in the workflow definition instead of using full name.
	Alias string `json:"alias,omitempty"`

	// AppVersion The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion,omitempty"`

	// Methods The list of all required actions’ names that must be imported.
	Methods []string `json:"methods"`

	// Name The name of the group that holds specific actions that you want to import, for example cap.interfaces.db.mysql
	Name string `json:"name"`

}

// Metadata 
type Metadata struct {
}

// RequireEntity 
type RequireEntity struct {
	// Name The name of the Type. Root prefix can be skipped if it’s a core Type. If it is a custom Type then it MUST be defined as full path to that Type. Custom Type MUST extend the abstract node which is defined as a root prefix for that entry.
	Name string `json:"name"`

	// Revision The revision version of the given Type.
	Revision string `json:"revision"`

	// Value Holds the configuration constraints for the given entry. It needs to be valid against the Type JSONSchema.
	Value *Value `json:"value,omitempty"`

}

// RequiresItem Prefix MUST be an abstract node and represents a core abstract Type e.g. cap.core.type.platform. Custom Types are not allowed.
type RequiresItem struct {
	// AllOf All of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	AllOf []*RequireEntity `json:"allOf,omitempty"`

	// AnyOf Any (one or more) of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	AnyOf []*RequireEntity `json:"anyOf,omitempty"`

	// OneOf Exactly one of the given types MUST have an Instance on the cluster. Element on the list MUST resolves to concrete Type.
	OneOf []*RequireEntity `json:"oneOf,omitempty"`

}

// Root The description of an action and its prerequisites (dependencies). An implementation implements at least one interface.
type Root struct {
	// Kind 
	Kind string `json:"kind"`

	// Metadata 
	Metadata *Metadata `json:"metadata"`

	// OcfVersion 
	OcfVersion string `json:"ocfVersion"`

	// Revision Version of the manifest content in the SemVer format.
	Revision string `json:"revision"`

	// Signature Ensures the authenticity and integrity of a given manifest.
	Signature *Signature `json:"signature"`

	// Spec A container for the Implementation specification definition.
	Spec *Spec `json:"spec"`

}

// Signature Ensures the authenticity and integrity of a given manifest.
type Signature struct {
	// Och 
	Och string `json:"och"`

}

// Spec A container for the Implementation specification definition.
type Spec struct {
	// Action An explanation about the purpose of this instance.
	Action *Action `json:"action"`

	// AppVersion The supported application versions in SemVer2 format.
	AppVersion string `json:"appVersion"`

	// Implements Defines what kind of interfaces this implementation fulfills.
	Implements []*ImplementsItems `json:"implements"`

	// Imports List of external Interfaces that this Implementation requires to be able to execute the action.
	Imports []*ImportsItems `json:"imports,omitempty"`

	// Requires List of the system prerequisites that need to be present on the cluster. There has to be an Instance for every concrete type.
	Requires map[string]*RequiresItem `json:"requires,omitempty"`

}

// Value Holds the configuration constraints for the given entry. It needs to be valid against the Type JSONSchema.
type Value struct {
}


// MarshalJSON serializes to JSON
func (s *Action) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Action) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Args field

	// Args is required
	if s.Args == nil {
		stream.Error = errors.New("Args (args) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("args")
	stream.WriteVal(s.Args)
	if stream.Error != nil {
		return
	}

	// Marshal the Type field
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	stream.WriteObjectEnd()
}

func (s *Action) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Action) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	ArgsReceived := false
	TypeReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "args":
			iter.ReadVal(&s.Args)
			if iter.Error != nil {
				return
			}
			ArgsReceived = true
		case "type":
			s.Type = iter.ReadString()
			if iter.Error != nil {
				return
			}
			TypeReceived = true
		default:
			iter.ReportError("reading Action", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !ArgsReceived {
		iter.ReportError("validating Action", "\"args\" is required but was not present")
	}

	if !TypeReceived {
		iter.ReportError("validating Action", "\"type\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *ImplementsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s ImplementsItems) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)

	// Marshal the Revision field
	if !IsEmpty(s.Revision) {
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)
	}
	stream.WriteObjectEnd()
}

func (s *ImplementsItems) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *ImplementsItems) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	NameReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
		default:
			iter.ReportError("reading ImplementsItems", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !NameReceived {
		iter.ReportError("validating ImplementsItems", "\"name\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *ImportsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s ImportsItems) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Alias field
	if !IsEmpty(s.Alias) {
	ct.More()
	stream.WriteObjectField("alias")
	stream.WriteString(s.Alias)
	}

	// Marshal the AppVersion field
	if !IsEmpty(s.AppVersion) {
	ct.More()
	stream.WriteObjectField("appVersion")
	stream.WriteString(s.AppVersion)
	}

	// Marshal the Methods field
	ct.More()
	stream.WriteObjectField("methods")
	stream.WriteVal(s.Methods)
	if stream.Error != nil {
		return
	}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)
	stream.WriteObjectEnd()
}

func (s *ImportsItems) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *ImportsItems) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	MethodsReceived := false
	NameReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "alias":
			s.Alias = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "appVersion":
			s.AppVersion = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "methods":
			iter.ReadVal(&s.Methods)
			if iter.Error != nil {
				return
			}
			MethodsReceived = true
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		default:
			iter.ReportError("reading ImportsItems", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !MethodsReceived {
		iter.ReportError("validating ImportsItems", "\"methods\" is required but was not present")
	}

	if !NameReceived {
		iter.ReportError("validating ImportsItems", "\"name\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *RequireEntity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s RequireEntity) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Name field
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)

	// Marshal the Revision field
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)

	// Marshal the Value field
	if !IsEmpty(s.Value) {
	ct.More()
	stream.WriteObjectField("value")
	stream.WriteVal(s.Value)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *RequireEntity) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *RequireEntity) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	NameReceived := false
	RevisionReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
			NameReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
			RevisionReceived = true
		case "value":
			iter.ReadVal(&s.Value)
			if iter.Error != nil {
				return
			}
		default:
			iter.ReportError("reading RequireEntity", "additional property not allowed: \"" + field + "\"")
			return
		}
	}

	if !NameReceived {
		iter.ReportError("validating RequireEntity", "\"name\" is required but was not present")
	}

	if !RevisionReceived {
		iter.ReportError("validating RequireEntity", "\"revision\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *RequiresItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s RequiresItem) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the AllOf field
	if !IsEmpty(s.AllOf) {
	ct.More()
	stream.WriteObjectField("allOf")
	stream.WriteVal(s.AllOf)
	if stream.Error != nil {
		return
	}
	}

	// Marshal the AnyOf field
	if !IsEmpty(s.AnyOf) {
	ct.More()
	stream.WriteObjectField("anyOf")
	stream.WriteVal(s.AnyOf)
	if stream.Error != nil {
		return
	}
	}

	// Marshal the OneOf field
	if !IsEmpty(s.OneOf) {
	ct.More()
	stream.WriteObjectField("oneOf")
	stream.WriteVal(s.OneOf)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *RequiresItem) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *RequiresItem) UnmarshalJSONIterator(iter *jsoniter.Iterator) {

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "allOf":
			iter.ReadVal(&s.AllOf)
			if iter.Error != nil {
				return
			}
		case "anyOf":
			iter.ReadVal(&s.AnyOf)
			if iter.Error != nil {
				return
			}
		case "oneOf":
			iter.ReadVal(&s.OneOf)
			if iter.Error != nil {
				return
			}
		default:
			iter.ReportError("reading RequiresItem", "additional property not allowed: \"" + field + "\"")
			return
		}
	}
}


// MarshalJSON serializes to JSON
func (s *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Root) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Kind field
	ct.More()
	stream.WriteObjectField("kind")
	stream.WriteString(s.Kind)

	// Marshal the Metadata field

	// Metadata is required
	if s.Metadata == nil {
		stream.Error = errors.New("Metadata (metadata) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("metadata")
	stream.WriteVal(s.Metadata)
	if stream.Error != nil {
		return
	}

	// Marshal the OcfVersion field
	ct.More()
	stream.WriteObjectField("ocfVersion")
	stream.WriteString(s.OcfVersion)

	// Marshal the Revision field
	ct.More()
	stream.WriteObjectField("revision")
	stream.WriteString(s.Revision)

	// Marshal the Signature field

	// Signature is required
	if s.Signature == nil {
		stream.Error = errors.New("Signature (signature) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("signature")
	stream.WriteVal(s.Signature)
	if stream.Error != nil {
		return
	}

	// Marshal the Spec field

	// Spec is required
	if s.Spec == nil {
		stream.Error = errors.New("Spec (spec) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("spec")
	stream.WriteVal(s.Spec)
	if stream.Error != nil {
		return
	}
	stream.WriteObjectEnd()
}

func (s *Root) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Root) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	KindReceived := false
	MetadataReceived := false
	OcfVersionReceived := false
	RevisionReceived := false
	SignatureReceived := false
	SpecReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "kind":
			s.Kind = iter.ReadString()
			if s.Kind != "Implementation" {
				iter.ReportError(
					"kind",
					fmt.Sprintf("Expected %s, got \"%s\"", "Implementation", s.Kind),
				)
			}
			if iter.Error != nil {
				return
			}
			KindReceived = true
		case "metadata":
			iter.ReadVal(&s.Metadata)
			if iter.Error != nil {
				return
			}
			MetadataReceived = true
		case "ocfVersion":
			s.OcfVersion = iter.ReadString()
			if iter.Error != nil {
				return
			}
			OcfVersionReceived = true
		case "revision":
			s.Revision = iter.ReadString()
			if iter.Error != nil {
				return
			}
			RevisionReceived = true
		case "signature":
			iter.ReadVal(&s.Signature)
			if iter.Error != nil {
				return
			}
			SignatureReceived = true
		case "spec":
			iter.ReadVal(&s.Spec)
			if iter.Error != nil {
				return
			}
			SpecReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !KindReceived {
		iter.ReportError("validating Root", "\"kind\" is required but was not present")
	}

	if !MetadataReceived {
		iter.ReportError("validating Root", "\"metadata\" is required but was not present")
	}

	if !OcfVersionReceived {
		iter.ReportError("validating Root", "\"ocfVersion\" is required but was not present")
	}

	if !RevisionReceived {
		iter.ReportError("validating Root", "\"revision\" is required but was not present")
	}

	if !SignatureReceived {
		iter.ReportError("validating Root", "\"signature\" is required but was not present")
	}

	if !SpecReceived {
		iter.ReportError("validating Root", "\"spec\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *Signature) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Signature) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Och field
	ct.More()
	stream.WriteObjectField("och")
	stream.WriteString(s.Och)
	stream.WriteObjectEnd()
}

func (s *Signature) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Signature) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	OchReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "och":
			s.Och = iter.ReadString()
			if iter.Error != nil {
				return
			}
			OchReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !OchReceived {
		iter.ReportError("validating Signature", "\"och\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *Spec) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Spec) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Action field

	// Action is required
	if s.Action == nil {
		stream.Error = errors.New("Action (action) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("action")
	stream.WriteVal(s.Action)
	if stream.Error != nil {
		return
	}

	// Marshal the AppVersion field
	ct.More()
	stream.WriteObjectField("appVersion")
	stream.WriteString(s.AppVersion)

	// Marshal the Implements field
	ct.More()
	stream.WriteObjectField("implements")
	stream.WriteVal(s.Implements)
	if stream.Error != nil {
		return
	}

	// Marshal the Imports field
	if !IsEmpty(s.Imports) {
	ct.More()
	stream.WriteObjectField("imports")
	stream.WriteVal(s.Imports)
	if stream.Error != nil {
		return
	}
	}

	// Marshal the Requires field
	if !IsEmpty(s.Requires) {
	ct.More()
	stream.WriteObjectField("requires")
	stream.WriteVal(s.Requires)
	if stream.Error != nil {
		return
	}
	}
	stream.WriteObjectEnd()
}

func (s *Spec) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Spec) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	ActionReceived := false
	AppVersionReceived := false
	ImplementsReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "action":
			iter.ReadVal(&s.Action)
			if iter.Error != nil {
				return
			}
			ActionReceived = true
		case "appVersion":
			s.AppVersion = iter.ReadString()
			if iter.Error != nil {
				return
			}
			AppVersionReceived = true
		case "implements":
			iter.ReadVal(&s.Implements)
			if iter.Error != nil {
				return
			}
			ImplementsReceived = true
		case "imports":
			iter.ReadVal(&s.Imports)
			if iter.Error != nil {
				return
			}
		case "requires":
			iter.ReadVal(&s.Requires)
			if iter.Error != nil {
				return
			}
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !ActionReceived {
		iter.ReportError("validating Spec", "\"action\" is required but was not present")
	}

	if !AppVersionReceived {
		iter.ReportError("validating Spec", "\"appVersion\" is required but was not present")
	}

	if !ImplementsReceived {
		iter.ReportError("validating Spec", "\"implements\" is required but was not present")
	}
}
