# TODO neo4j-graphql-js adds some directives during parsing
# to make it work for other graphql client we need to add them to the schema manually, based on:
# https://github.com/neo4j-graphql/neo4j-graphql-js/blob/master/src/augment/directives.js
directive @relation(name: String, direction: String, from: String, to: String) on FIELD_DEFINITION | OBJECT

"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

type TypeInstance {
  resourceVersion: Int!
  metadata: TypeInstanceMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: TypeInstanceSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type TypeInstanceMetadata {
  id: ID!
  tags: [TagReference!]! @relation(name: "TAGGED_WITH", direction: "OUT")
}

type TypeInstanceSpec {
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
  value: Any!
  instrumentation: TypeInstanceInstrumentation @relation(name: "MONITORED_BY", direction: "OUT")
}

type TypeReference {
  path: NodePath!
  revision: Version!
}

input TagReferenceInput {
  path: NodePath!
  revision: Version!
}

type TagReference {
  path: NodePath!
  revision: Version!
}

type TypeInstanceInstrumentation {
  metrics: TypeInstanceInstrumentationMetrics @relation(name: "MEASURES", direction: "OUT")
  health: TypeInstanceInstrumentationHealth @relation(name: "INDICATED", direction: "OUT")
}

type TypeInstanceInstrumentationMetrics {
  endpoint: String
  regex: String # optional regex for scraping metrics
  dashboards: [TypeInstanceInstrumentationMetricsDashboard!]! @relation(name: "ON", direction: "OUT")
}

type TypeInstanceInstrumentationMetricsDashboard {
  url: String!
}

type TypeInstanceInstrumentationHealth {
  url: String
  method: HTTPRequestMethod

  # resolver, which does a HTTP call on a given URL
  # and expects status code greater than or equal to 200
  # and less than 400
  status: TypeInstanceInstrumentationHealthStatus
}

enum TypeInstanceInstrumentationHealthStatus {
  UNKNOWN
  READY
  FAILING
}

enum HTTPRequestMethod {
  GET
  POST
}

input TagFilterInput {
  path: NodePath!
  rule: FilterRule = INCLUDE

  """
  If not provided, latest revision for a given Tag is used
  """
  revision: Version
}

enum FilterRule {
  INCLUDE
  EXCLUDE
}

input TypeInstanceFilter {
  tag: [TagFilterInput]
  typeRef: TypeRefFilterInput
}

input TypeRefFilterInput {
  path: NodePath!

  """
  If not provided, latest revision for a given Type is used
  """
  revision: Version
}

input TypeReferenceInput {
  path: NodePath!
  revision: Version!
}

input CreateTypeInstanceInput {
  typeRef: TypeReferenceInput!
  tags: [TagReferenceInput!]
  value: Any
}

input UpdateTypeInstanceInput {
  typeRef: TypeReferenceInput
  tags: [TagReferenceInput!]
  value: Any
  resourceVersion: Int!
}

type Query {
  typeInstances(filter: TypeInstanceFilter): [TypeInstance!]!
  typeInstance(id: ID!): TypeInstance
}

type Mutation {
  createTypeInstance(in: CreateTypeInstanceInput!): TypeInstance! @cypher(statement: """
    CREATE (ti: TypeInstance {resourceVersion: 1})
    CREATE (ti)-[:DESCRIBED_BY]->(metadata: TypeInstanceMetadata {id: apoc.create.uuid()})
    CREATE (ti)-[:SPECIFIED_BY]->(spec: TypeInstanceSpec {value: $in.value})
    CREATE (spec)-[:OF_TYPE]->(typeRef: TypeReference {path: $in.typeRef.path, revision: $in.typeRef.revision})

    FOREACH (tag in $in.tags |
      CREATE (metadata)-[:TAGGED_WITH]->(tagRef: TagReference {path: tag.path, revision: tag.revision})
    )

    RETURN ti
  """)
  updateTypeInstance(id: ID!, in: UpdateTypeInstanceInput!): TypeInstance! @cypher(statement: """
    MATCH (metadata: TypeInstanceMetadata {id: $id})<-[:DESCRIBED_BY]-(ti: TypeInstance)
    MATCH (ti)-[:SPECIFIED_BY]->(spec: TypeInstanceSpec)
    MATCH (spec)-[:OF_TYPE]->(typeRef: TypeReference)

    CALL apoc.do.when(
      $in.value IS NOT NULL,
      'SET spec.value = in.value RETURN spec',
      '',
      {spec:spec, in: $in}
    ) YIELD value

    WITH ti, metadata, spec, typeRef
    CALL apoc.do.when(
      $in.typeRef IS NOT NULL,
      'SET typeRef.path = in.typeRef.path, typeRef.revision = in.typeRef.revision RETURN typeRef',
      '',
      {typeRef: typeRef, in: $in}
    ) YIELD value

    WITH ti, metadata, spec, typeRef
    CALL apoc.do.when(
      $in.tags IS NOT NULL,
      '
        // Remove current tag references
        OPTIONAL MATCH (metadata)-[:TAGGED_WITH]->(oldTagRef: TagReference) DETACH DELETE oldTagRef
        WITH metadata, in, collect(oldTagRef) as ignored
  
        // Add new tag refs
        FOREACH (tag in in.tags |
          CREATE (metadata)-[:TAGGED_WITH]->(tagRef: TagReference {path: tag.path, revision: tag.revision})
        )
        RETURN metadata
      ',
      '',
      {metadata: metadata, in: $in}
    ) YIELD value

    WITH ti, metadata, spec, typeRef
    SET ti.resourceVersion = $in.resourceVersion

    RETURN ti
  """)
  deleteTypeInstance(id: ID!): ID! @cypher(statement: """
    MATCH (metadata: TypeInstanceMetadata {id: $id})<-[:DESCRIBED_BY]-(ti: TypeInstance)
    MATCH (ti)-[:SPECIFIED_BY]->(spec: TypeInstanceSpec)
    MATCH (spec)-[:OF_TYPE]->(typeRef: TypeReference)
    OPTIONAL MATCH (metadata)-[:TAGGED_WITH]->(tagRef: TagReference)

    DETACH DELETE ti, metadata, spec, typeRef, tagRef
    RETURN $id
  """)
}

# TODO: Prepare directive for user authorization in https://cshark.atlassian.net/browse/SV-65
