# neo4j-graphql-js adds some directives during parsing
# To make it work for other graphql client we need to add them to the schema manually, based on:
# https://github.com/neo4j-graphql/neo4j-graphql-js/blob/master/src/augment/directives.js
directive @relation(
  name: String
  direction: String
  from: String
  to: String
) on FIELD_DEFINITION | OBJECT

directive @cypher(statement: String) on FIELD_DEFINITION
directive @index on FIELD_DEFINITION
directive @id on FIELD_DEFINITION

"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

type TypeInstance {
  id: ID! @id

  """
  Common properties for all TypeInstances which cannot be changed
  """
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
  uses: [TypeInstance!]! @relation(name: "USES", direction: "OUT")
  usedBy: [TypeInstance!]! @relation(name: "USES", direction: "IN")

  latestResourceVersion: TypeInstanceResourceVersion
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(tir:TypeInstanceResourceVersion) RETURN tir ORDER BY tir.resourceVersion DESC LIMIT 1"
    )
  firstResourceVersion: TypeInstanceResourceVersion
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(tir:TypeInstanceResourceVersion) RETURN tir ORDER BY tir.resourceVersion ASC LIMIT 1"
    )
  previousResourceVersion: TypeInstanceResourceVersion
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(tir:TypeInstanceResourceVersion) RETURN tir ORDER BY tir.resourceVersion DESC SKIP 1 LIMIT 1"
    )
  resourceVersion(resourceVersion: Int!): TypeInstanceResourceVersion
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(tir:TypeInstanceResourceVersion {resourceVersion: $resourceVersion}) RETURN tir"
    )
  resourceVersions: [TypeInstanceResourceVersion!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type TypeInstanceResourceVersion {
  resourceVersion: Int! @index
  metadata: TypeInstanceResourceVersionMetadata!
    @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: TypeInstanceResourceVersionSpec!
    @relation(name: "SPECIFIED_BY", direction: "OUT")
}

type TypeInstanceResourceVersionMetadata {
  id: ID! @id
  attributes: [AttributeReference!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type TypeInstanceResourceVersionSpec {
  value: Any!
    @cypher(
      statement: """
      RETURN apoc.convert.fromJsonMap(this.value)
      """
    )
  instrumentation: TypeInstanceInstrumentation
    @relation(name: "INSTRUMENTED_WITH", direction: "OUT")
}

type TypeReference {
  path: NodePath!
  revision: Version!
}

input AttributeReferenceInput {
  path: NodePath!
  revision: Version!
}

type AttributeReference {
  path: NodePath!
  revision: Version!
}

type TypeInstanceInstrumentation {
  metrics: TypeInstanceInstrumentationMetrics
    @relation(name: "MEASURED_BY", direction: "OUT")
  health: TypeInstanceInstrumentationHealth
    @relation(name: "INDICATED_BY", direction: "OUT")
}

type TypeInstanceInstrumentationMetrics {
  endpoint: String
  regex: String # optional regex for scraping metrics
  dashboards: [TypeInstanceInstrumentationMetricsDashboard!]!
    @relation(name: "ON", direction: "OUT")
}

type TypeInstanceInstrumentationMetricsDashboard {
  url: String!
}

type TypeInstanceInstrumentationHealth {
  url: String
  method: HTTPRequestMethod

  # resolver, which does a HTTP call on a given URL
  # and expects status code greater than or equal to 200
  # and less than 400
  # TODO implement TypeInstance health check, for resolution of this field
  status: TypeInstanceInstrumentationHealthStatus
}

enum TypeInstanceInstrumentationHealthStatus {
  UNKNOWN
  READY
  FAILING
}

enum HTTPRequestMethod {
  GET
  POST
}

input AttributeFilterInput {
  path: NodePath!
  rule: FilterRule = INCLUDE

  """
  If not provided, any revision of the Attribute applies to this filter
  """
  revision: Version
}

enum FilterRule {
  INCLUDE
  EXCLUDE
}

input TypeInstanceFilter {
  attributes: [AttributeFilterInput]
  typeRef: TypeRefFilterInput
}

input TypeRefFilterInput {
  path: NodePath!

  """
  If not provided, it returns TypeInstances for all revisions of given Type
  """
  revision: Version
}

input TypeReferenceInput {
  path: NodePath!
  revision: Version!
}

input CreateTypeInstanceInput {
  """
  Used to define the relationships, between the created TypeInstances
  """
  alias: String

  typeRef: TypeReferenceInput!
  attributes: [AttributeReferenceInput!]
  value: Any
}

input TypeInstanceUsesRelationInput {
  """
  Can be existing TypeInstance ID or alias of a TypeInstance from typeInstances list
  """
  from: String!

  """
  Can be existing TypeInstance ID or alias of a TypeInstance from typeInstances list
  """
  to: String!
}

input CreateTypeInstancesInput {
  typeInstances: [CreateTypeInstanceInput!]!
  usesRelations: [TypeInstanceUsesRelationInput!]!
}

type CreateTypeInstanceOutput {
  id: ID!
  alias: String!
}

input UpdateTypeInstanceInput {
  typeRef: TypeReferenceInput
  attributes: [AttributeReferenceInput!]
  value: Any
  """
  Provide the latest resourceVersion number of the TypeInstance that you want to modify
  """
  resourceVersion: Int!
}

input UpdateTypeInstancesInput {
  id: ID!
  typeInstance: UpdateTypeInstanceInput!
}

type Query {
  typeInstances(filter: TypeInstanceFilter = {}): [TypeInstance!]!
    @cypher(
      statement: """
      WITH [x IN $filter.attributes WHERE x.rule = "EXCLUDE" | x ] AS excluded,
        [x IN $filter.attributes WHERE x.rule = "INCLUDE" | x ] AS included

      CALL {
        WITH excluded
        UNWIND excluded AS f
        MATCH (ex:AttributeReference {path: f.path})
        WHERE (f.revision IS NULL) OR (ex.revision = f.revision)
        RETURN collect(ex) as excludedAttributes
      }

      MATCH (tir:TypeInstanceResourceVersion)-[:DESCRIBED_BY]->(meta:TypeInstanceResourceVersionMetadata)
      OPTIONAL MATCH (meta)-[:CHARACTERIZED_BY]->(attr:AttributeReference)
      MATCH (ti:TypeInstance)-[:OF_TYPE]->(typeRef:TypeReference)
      MATCH (ti:TypeInstance)-[:CONTAINS]->(tir)
      WHERE
      $filter = {} OR
      (
        (
          $filter.typeRef IS NULL
          OR
          (
            ($filter.typeRef.revision IS NULL AND typeRef.path = $filter.typeRef.path)
            OR
            (typeRef.path = $filter.typeRef.path AND typeRef.revision = $filter.typeRef.revision)
          )
        )
        AND
        (
        	$filter.attributes IS NULL
          OR
          (
            all(inc IN included WHERE
              (tir)-[:DESCRIBED_BY]->(meta:TypeInstanceResourceVersionMetadata)-[:CHARACTERIZED_BY]->(attr:AttributeReference {path: inc.path})
              AND
              (inc.revision IS NULL OR attr.revision = inc.revision)
            )
            AND
            none(exc IN excludedAttributes WHERE (tir)-[:DESCRIBED_BY]->(meta:TypeInstanceResourceVersionMetadata)-[:CHARACTERIZED_BY]->(exc))
          )
        )
      )

      RETURN DISTINCT ti
      """
    )

  typeInstance(id: ID!): TypeInstance
    @cypher(
      statement: """
      MATCH (this:TypeInstance {id: $id})
      RETURN this
      """
    )
}

type Mutation {
  """
  TODO: SV-262
  """
  createTypeInstances(
    in: CreateTypeInstancesInput!
  ): [CreateTypeInstanceOutput!]!

  # TODO extend input with TypeInstanceInstrumentation
  createTypeInstance(in: CreateTypeInstanceInput!): TypeInstance!
    @cypher(
      statement: """
      WITH apoc.convert.toJson($in.value) as value
      MERGE (typeRef:TypeReference {path: $in.typeRef.path, revision: $in.typeRef.revision})

      CREATE (ti:TypeInstance {id: apoc.create.uuid()})
      CREATE (ti)-[:OF_TYPE]->(typeRef)

      CREATE (tir: TypeInstanceResourceVersion {resourceVersion: 1})
      CREATE (ti)-[:CONTAINS]->(tir)

      CREATE (tir)-[:DESCRIBED_BY]->(metadata: TypeInstanceResourceVersionMetadata {id: apoc.create.uuid()})
      CREATE (tir)-[:SPECIFIED_BY]->(spec: TypeInstanceResourceVersionSpec {value: value})

      FOREACH (attr in $in.attributes |
        MERGE (attrRef: AttributeReference {path: attr.path, revision: attr.revision})
        CREATE (metadata)-[:CHARACTERIZED_BY]->(attrRef)
      )

      RETURN ti
      """
    )

  """
  TODO: SV-265
  """
  updateTypeInstance(id: ID!, in: UpdateTypeInstanceInput!): TypeInstance!

  """
  TODO: SV-265
  """
  updateTypeInstances(in: [UpdateTypeInstancesInput]!): [TypeInstance]!

  """
  TODO: SV-263, fix problem with not delete orphan typeRef
  """
  deleteTypeInstance(id: ID!): ID!
    @cypher(
      statement: """
      MATCH (ti:TypeInstance {id: $id})-[:CONTAINS]->(tirs: TypeInstanceResourceVersion)
      MATCH (ti)-[:OF_TYPE]->(typeRef: TypeReference)
      MATCH (metadata:TypeInstanceResourceVersionMetadata)<-[:DESCRIBED_BY]-(tirs)
      MATCH (tirs)-[:SPECIFIED_BY]->(spec: TypeInstanceResourceVersionSpec)
      OPTIONAL MATCH (metadata)-[:CHARACTERIZED_BY]->(attrRef: AttributeReference)

      DETACH DELETE ti, metadata, spec, attrRef, tirs

      RETURN $id
      """
    )
}

# TODO: Prepare directive for user authorization in https://cshark.atlassian.net/browse/SV-65
