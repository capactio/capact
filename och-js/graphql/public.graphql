# Neo4j-graphql-js adds some directives during parsing of the schema.
# To make it work for other GraphQL clients, we need to add them to the schema manually, based on:
# https://github.com/neo4j-graphql/neo4j-graphql-js/blob/master/src/augment/directives.js
directive @relation(
  name: String
  direction: String
  from: String
  to: String
) on FIELD_DEFINITION | OBJECT
directive @cypher(statement: String) on FIELD_DEFINITION

"""
Arbitrary data
"""
scalar Any

"""
Full path of a given node, e.g. cap.core.type.platform.kubernetes
"""
scalar NodePath

"""
Pattern of the path of a given node, e.g. cap.core.type.platform.*
"""
scalar NodePathPattern

"""
Path for the parent node, e.g. for Interface it is InterfaceGroup path.
"""
scalar NodePrefix

"""
Name of a given node. Name is immutable between different revisions of a given node.
"""
scalar NodeName

"""
Version in semantic versioning, e.g. 1.1.0
"""
scalar Version

"""
Range of versions, e.g. "1.14.x, 1.15.0 - 1.15.3"
"""
scalar VersionRange

input InterfaceFilter {
  prefixPattern: NodePathPattern
}

input ImplementationFilter {
  prefixPattern: NodePathPattern
}

input ImplementationRevisionFilter {
  prefixPattern: NodePathPattern

  """
  If provided, Implementations are filtered by the ones that have satisfied requirements with provided TypeInstance values.
  For example, to find all Implementations that can be run on a given system, user can provide values of all existing TypeInstances.
  """
  requirementsSatisfiedBy: [TypeInstanceValue!]
  attributes: [AttributeFilterInput!]
}

input TypeInstanceValue {
  typeRef: TypeReferenceInput

  """
  Value of the available requirement. If not provided, all valueConstraints conditions are treated as satisfied.
  Currently not supported.
  """
  value: Any
}

input TypeReferenceInput {
  path: NodePath!
  revision: Version!
}

input AttributeFilterInput {
  path: NodePath!
  rule: FilterRule = INCLUDE

  """
  If not provided, latest revision for a given Attribute is used
  """
  revision: Version
}

enum FilterRule {
  INCLUDE
  EXCLUDE
}

input InterfaceGroupFilter {
  prefixPattern: NodePathPattern
}

input AttributeFilter {
  prefixPattern: NodePathPattern
}

input TypeFilter {
  prefixPattern: NodePathPattern
}

type RepoMetadata {
  path: NodePath!
  name: NodeName!
  prefix: NodePrefix!

  latestRevision: RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): RepoMetadataRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:RepoMetadataRevision {revision: $revision}) RETURN r"
    )
  revisions: [RepoMetadataRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type RepoMetadataRevision {
  revision: Version!

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: RepoMetadataSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  signature: Signature! @relation(name: "SIGNED_WITH", direction: "OUT")
}

type RepoMetadataSpec {
  ochVersion: Version!
  ocfVersion: RepoOCFVersion! @relation(name: "SUPPORTS", direction: "OUT")
  implementation: RepoImplementationConfig!
    @relation(name: "CONFIGURED", direction: "OUT")
}

type RepoImplementationConfig {
  appVersion: RepoImplementationAppVersionConfig!
    @relation(name: "APP_VERSION", direction: "OUT")
}

type RepoImplementationAppVersionConfig {
  semVerTaggingStrategy: SemVerTaggingStrategy!
    @relation(name: "TAGGING_STRATEGY", direction: "OUT")
}

type SemVerTaggingStrategy {
  latest: LatestSemVerTaggingStrategy!
    @relation(name: "LATEST", direction: "OUT")
}

type LatestSemVerTaggingStrategy {
  pointsTo: SemVerTaggingStrategyTags!
}

enum SemVerTaggingStrategyTags {
  STABLE
  EDGE
}

type RepoOCFVersion {
  supported: [Version!]!
  default: Version!
}

type InterfaceGroup {
  path: NodePath!
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  signature: Signature! @relation(name: "SIGNED_WITH", direction: "OUT")
  interfaces(filter: InterfaceFilter): [Interface!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type Interface {
  path: NodePath!
  name: NodeName!
  prefix: NodePrefix!

  latestRevision: InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): InterfaceRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:InterfaceRevision {revision: $revision}) RETURN ir"
    )
  revisions: [InterfaceRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type InterfaceRevision {
  revision: Version!

  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: InterfaceSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  signature: Signature! @relation(name: "SIGNED_WITH", direction: "OUT")

  implementationRevisions: [ImplementationRevision!]!
    @relation(name: "IMPLEMENTS", direction: "IN")

  implementationRevisionsForRequirements(
    filter: ImplementationRevisionFilter = {}
  ): [ImplementationRevision!]!
    @cypher(
      statement: """
      WITH [x IN $filter.attributes WHERE x.rule = "EXCLUDE" | x ] AS excluded,
        [x IN $filter.attributes WHERE x.rule = "INCLUDE" | x ] AS included

      // Get all Attribute nodes, which cannot be in the Implementation graph.
      CALL {
        WITH excluded
        UNWIND excluded AS f
        MATCH (ex:AttributeRevision)-[:DESCRIBED_BY]->(meta:GenericMetadata {path: f.path})
        RETURN collect(ex) as excludedAttributes
      }

      // Get all Attribute nodes, which must be in the Implementation graph.
      CALL {
        WITH included
        UNWIND included AS f
        MATCH (ex:AttributeRevision)-[:DESCRIBED_BY]->(meta:GenericMetadata {path: f.path})
        RETURN collect(ex) as includedAttributes
      }

      // Get all ImplementationRequirementItem nodes, which are considered by the filter.
      CALL {
        UNWIND $filter.requirementsSatisfiedBy AS instance
        MATCH (items:ImplementationRequirementItem)-[:REFERENCES_TYPE]->(:TypeReference {path: instance.typeRef.path, revision: instance.typeRef.revision})
        RETURN collect(items) as matchedItems
      }

      // Flatten and group requirements for ImplementationRevision.
      MATCH (this)<-[:IMPLEMENTS]-(rev:ImplementationRevision)-[:SPECIFIED_BY]->(spec:ImplementationSpec)
      OPTIONAL MATCH (spec)-[:REQUIRES]->(requirement:ImplementationRequirement)

      CALL {
      	WITH requirement
        OPTIONAL MATCH (requirement)-[:ONE_OF]->(oneOfItem:ImplementationRequirementItem)
        WITH collect(oneOfItem) as oneOfReq
        RETURN [req IN collect(oneOfReq) WHERE req <> [] | req] as oneOfReqs
      }

      CALL {
      	WITH requirement
        OPTIONAL MATCH (requirement)-[:ANY_OF]->(anyOfItem:ImplementationRequirementItem)
        WITH collect(anyOfItem) as anyOfReq
        RETURN [req IN collect(anyOfReq) WHERE req <> [] | req] as anyOfReqs
      }

      CALL {
      	WITH requirement
        OPTIONAL MATCH (requirement)-[:ALL_OF]->(allOfItem:ImplementationRequirementItem)
        WITH collect(allOfItem) as allOfReq
        RETURN [req IN collect(allOfReq) WHERE req <> [] | req] as allOfReqs
      }

      MATCH (rev)-[:DESCRIBED_BY]->(meta:ImplementationMetadata)
      OPTIONAL MATCH (meta)-[:CHARACTERIZED_BY]->(attr:AttributeRevision)-[:DESCRIBED_BY]->(attrMeta:GenericMetadata)
      MATCH (rev)
      WHERE
        ($filter.prefixPattern IS null OR meta.prefix =~ $filter.prefixPattern)
        AND
        (
          all(oneOfReq IN oneOfReqs WHERE single(item in oneOfReq WHERE item in matchedItems))
          AND
          all(anyOfReq IN anyOfReqs WHERE any(item in anyOfReq WHERE item in matchedItems))
          AND
          all(allOfReq IN allOfReqs WHERE all(item in allOfReq WHERE item in matchedItems))
        )
        AND
        (
          $filter.attributes IS NULL
          OR
          (
            all(inc IN includedAttributes WHERE (meta)-[:CHARACTERIZED_BY]->(inc))
            AND
            none(exc IN excludedAttributes WHERE (meta)-[:CHARACTERIZED_BY]->(exc))
          )
        )

      RETURN rev
      """
    )
}

type InterfaceSpec {
  input: InterfaceInput! @relation(name: "HAS_INPUT", direction: "OUT")
  output: InterfaceOutput! @relation(name: "OUTPUTS", direction: "OUT")
}

type InterfaceInput {
  parameters: InputParameters @relation(name: "HAS", direction: "OUT")
  typeInstances: [InputTypeInstance]! @relation(name: "HAS", direction: "OUT")
}

type InputParameters {
  jsonSchema: Any
}

type InterfaceOutput {
  typeInstances: [OutputTypeInstance]!
    @relation(name: "OUTPUTS", direction: "OUT")
}

interface TypeInstanceFields {
  name: String!
  typeRef: TypeReference!
}

type InputTypeInstance implements TypeInstanceFields {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
  verbs: [TypeInstanceOperationVerb!]!
}

enum TypeInstanceOperationVerb {
  CREATE
  GET
  LIST
  UPDATE
  DELETE
}

type OutputTypeInstance implements TypeInstanceFields {
  name: String!
  typeRef: TypeReference! @relation(name: "OF_TYPE", direction: "OUT")
}

type Type {
  path: NodePath!
  name: NodeName!
  prefix: NodePrefix!

  latestRevision: TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r) RETURN r ORDER BY r.revision DESC LIMIT 1"
    )
  revision(revision: Version!): TypeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r {revision: $revision}) RETURN r"
    )
  revisions: [TypeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type TypeRevision {
  revision: Version!

  metadata: TypeMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: TypeSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  signature: Signature! @relation(name: "SIGNED_WITH", direction: "OUT")
}

type TypeSpec {
  additionalRefs: [NodePath!]
  jsonSchema: Any
}

type Implementation {
  path: NodePath!
  name: NodeName!
  prefix: NodePrefix!

  latestRevision: ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision) RETURN ir ORDER BY ir.revision DESC LIMIT 1"
    )
  revision(revision: Version!): ImplementationRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(ir:ImplementationRevision {revision: $revision}) RETURN ir"
    )
  revisions: [ImplementationRevision!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationRevision {
  revision: Version!
  signature: Signature!
    @relation(name: "SIGNED_WITH", direction: "OUT")

  metadata: ImplementationMetadata!
    @relation(name: "DESCRIBED_BY", direction: "OUT")
  spec: ImplementationSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  interfaces: [InterfaceRevision!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
}

type ImplementationSpec {
  appVersion: VersionRange!

  implements: [InterfaceReference!]!
    @relation(name: "IMPLEMENTS", direction: "OUT")
  requires: [ImplementationRequirement!]!
    @relation(name: "REQUIRES", direction: "OUT")
  imports: [ImplementationImport!] @relation(name: "IMPORTS", direction: "OUT")
  action: ImplementationAction! @relation(name: "DOES", direction: "OUT")
  additionalInput: ImplementationAdditionalInput
    @relation(name: "USES", direction: "OUT")
  additionalOutput: ImplementationAdditionalOutput
    @relation(name: "OUTPUTS", direction: "OUT")
}

type ImplementationAdditionalInput {
  typeInstances: [InputTypeInstance!]!
    @relation(name: "CONTAINS", direction: "OUT")
}

type ImplementationAdditionalOutput {
  typeInstances: [OutputTypeInstance!]!
    @relation(name: "CONTAINS", direction: "OUT")
  typeInstanceRelations: [TypeInstanceRelationItem!]!
    @relation(name: "RELATIONS", direction: "OUT")
}

type TypeInstanceRelationItem {
  typeInstanceName: String!

  """
  Contains list of Type Instance names, which a given TypeInstance uses (depends on)
  """
  uses: [String!]!
}

type InterfaceReference {
  path: NodePath!
  revision: Version!
}

type ImplementationRequirement {
  prefix: NodePrefix!
  oneOf: [ImplementationRequirementItem!]!
    @relation(name: "ONE_OF", direction: "OUT")
  anyOf: [ImplementationRequirementItem!]!
    @relation(name: "ANY_OF", direction: "OUT")
  allOf: [ImplementationRequirementItem!]!
    @relation(name: "ALL_OF", direction: "OUT")
}

type ImplementationRequirementItem {
  typeRef: TypeReference! @relation(name: "REFERENCES_TYPE", direction: "OUT")

  """
  Holds the configuration constraints for the given entry based on Type value.
  Currently not supported.
  """
  valueConstraints: Any
}

type TypeReference {
  path: NodePath!
  revision: Version!
}

type ImplementationImport {
  interfaceGroupPath: NodePath!
  alias: String
  appVersion: VersionRange

  methods: [ImplementationImportMethod!]!
    @relation(name: "HAS", direction: "OUT")
}

type ImplementationImportMethod {
  name: NodeName!

  """
  If not provided, latest revision for a given Interface is used
  """
  revision: Version
}

type ImplementationAction {
  """
  The Interface or Implementation of a runner, which handles the execution, for example, cap.interface.runner.helm3.run
  """
  runnerInterface: String!
  args: Any
}

type Attribute {
  path: NodePath!
  name: NodeName!
  prefix: NodePrefix!

  latestRevision: AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision) RETURN r ORDER BY r.revision DESC LIMIT 2"
    )
  revision(revision: Version!): AttributeRevision
    @cypher(
      statement: "MATCH (this)-[:CONTAINS]->(r:AttributeRevision {revision: $revision}) RETURN r"
    )
  revisions: [AttributeRevision!]! @relation(name: "CONTAINS", direction: "OUT")
}

type AttributeRevision {
  revision: Version!

  spec: AttributeSpec! @relation(name: "SPECIFIED_BY", direction: "OUT")
  signature: Signature! @relation(name: "SIGNED_WITH", direction: "OUT")
  metadata: GenericMetadata! @relation(name: "DESCRIBED_BY", direction: "OUT")
}

# It is defined to make sure that all metadata types have the same base fields.
# Unfortunately all Types that implement an Interface have to repeat the same fields,
# however it's the only way to do so.
interface MetadataBaseFields {
  name: NodeName
  prefix: NodePrefix
  path: NodePath
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type GenericMetadata implements MetadataBaseFields {
  path: NodePath
  name: NodeName
  prefix: NodePrefix

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
}

type ImplementationMetadata implements MetadataBaseFields {
  path: NodePath!
  name: NodeName
  prefix: NodePrefix

  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  license: License! @relation(name:"LICENSED_WITH", direction: "OUT")
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type TypeMetadata implements MetadataBaseFields {
  path: NodePath!
  name: NodeName
  prefix: NodePrefix
  displayName: String
  description: String!
  maintainers: [Maintainer!]! @relation(name: "MAINTAINED_BY", direction: "OUT")
  documentationURL: String
  supportURL: String
  iconURL: String
  attributes: [AttributeRevision!]!
    @relation(name: "CHARACTERIZED_BY", direction: "OUT")
}

type License {
  name: String!
}

type Signature {
  och: String!
}

type Maintainer {
  name: String
  email: String!
  url: String
}

type AttributeSpec {
  additionalRefs: [NodePath!]!
}

type Query {
  repoMetadata: RepoMetadata

  interfaceGroups(filter: InterfaceGroupFilter = {}): [InterfaceGroup!]!
    @cypher(
      statement: """
      MATCH (this:InterfaceGroup)
      WHERE $filter = {} OR this.prefix =~ $filter.prefixPattern RETURN this
      """
    )
  interfaceGroup(path: NodePath!): InterfaceGroup

  interfaces(filter: InterfaceFilter = {}): [Interface!]!
    @cypher(
      statement: """
      MATCH (this:Interface)
      WHERE $filter = {} OR this.prefix =~ $filter.prefixPattern RETURN this
      """
    )
  interface(path: NodePath!): Interface

  types(filter: TypeFilter = {}): [Type!]!
    @cypher(
      statement: """
      MATCH (this:Type)
      WHERE $filter = {} OR this.prefix =~ $filter.prefixPattern RETURN this
      """
    )
  type(path: NodePath!): Type

  implementations(filter: ImplementationFilter = {}): [Implementation!]!
    @cypher(
      statement: """
      MATCH (this:Implementation)
      WHERE $filter = {} OR this.prefix =~ $filter.prefixPattern RETURN this
      """
    )

  implementation(path: NodePath!): Implementation

  attributes(filter: AttributeFilter = {}): [Attribute!]!
    @cypher(
      statement: """
      MATCH (this:Attribute)
      WHERE $filter = {} OR this.prefix =~ $filter.prefixPattern RETURN this
      """
    )
  attribute(path: NodePath!): Attribute
}

# TODO: Prepare directive for user authorization in https://cshark.atlassian.net/browse/SV-65
